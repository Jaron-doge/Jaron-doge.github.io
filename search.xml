<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一章 开始</title>
    <url>/2020/09/04/C++/Chapter%201%20%E5%BC%80%E5%A7%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第一章-开始"><a class="markdownIt-Anchor" href="#第一章-开始"></a> 第一章 开始</h2>
<h3 id="11编写程序"><a class="markdownIt-Anchor" href="#11编写程序"></a> 1.1编写程序</h3>
<a id="more"></a>
<h3 id="12-输入输出"><a class="markdownIt-Anchor" href="#12-输入输出"></a> 1.2 输入输出</h3>
<ol>
<li>
<p>&lt;&lt;</p>
<p>接受两个运算对象：左侧的运算对象必须是一个ostream对象，右侧的运算对象是要打印的值，返回左侧对象作为运算结果</p>
</li>
<li>
<p>&gt;&gt;</p>
<p>左侧运算对象必须是一个istream对象，接受一个对象作为其右侧运算对象，返回其左侧运算对象作为计算结果</p>
</li>
</ol>
<h3 id="13-注释"><a class="markdownIt-Anchor" href="#13-注释"></a> 1.3 注释</h3>
<ul>
<li>
<p>两种形式：注释界定符、双斜线注释</p>
</li>
<li>
<p>注释界定符不能嵌套</p>
</li>
</ul>
<h3 id="14-控制流"><a class="markdownIt-Anchor" href="#14-控制流"></a> 1.4 控制流</h3>
<h4 id="141-while"><a class="markdownIt-Anchor" href="#141-while"></a> 1.4.1 while</h4>
<ul>
<li>
<p>while(std::cin &gt;&gt; value)</p>
<p>当我们使用一个istream对象作为条件时，其效果是检测流的状态。</p>
</li>
</ul>
<h4 id="142-for"><a class="markdownIt-Anchor" href="#142-for"></a> 1.4.2 for</h4>
<h4 id="144-if"><a class="markdownIt-Anchor" href="#144-if"></a> 1.4.4 if</h4>
<h3 id="15-类"><a class="markdownIt-Anchor" href="#15-类"></a> 1.5 类</h3>
<h4 id="152-成员函数"><a class="markdownIt-Anchor" href="#152-成员函数"></a> 1.5.2 成员函数</h4>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十二章 动态内存</title>
    <url>/2020/09/04/C++/Chapter%2012%20%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十二章-动态内存"><a class="markdownIt-Anchor" href="#第十二章-动态内存"></a> 第十二章 动态内存</h2>
<h3 id="121-动态内存与智能指针"><a class="markdownIt-Anchor" href="#121-动态内存与智能指针"></a> 12.1 动态内存与智能指针</h3>
<ul>
<li>
<p>智能指针</p>
<p>自动释放所指向的对象</p>
</li>
</ul>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="built_in">shared_ptr</span>			<span class="comment">// 多个指针指向同一个对象</span></span><br><span class="line"><span class="built_in">unique_ptr</span>			<span class="comment">// “独占”所指向的对象</span></span><br><span class="line">weak_ptr			<span class="comment">// 弱引用，指向shared_ptr所管理的对象</span></span><br></pre></td></tr></table></figure>
<h4 id="1211-shared_ptr类"><a class="markdownIt-Anchor" href="#1211-shared_ptr类"></a> 12.1.1 shared_ptr类</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="built_in">string</span>&gt; p1;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在一个条件判断中使用智能指针，效果是检测其是否为空</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">p.<span class="built_in">get</span>()				<span class="comment">// 返回p中保存的指针</span></span><br><span class="line">p.swap(q)			<span class="comment">// 交换指针</span></span><br><span class="line">make_share&lt;T&gt;(args)	<span class="comment">// 返回一个shared_ptr</span></span><br><span class="line">p.unique()			<span class="comment">// 若p.use_count()为1返回true</span></span><br><span class="line">p.use_count()		<span class="comment">// 返回与p共享对象的智能指针数量</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当进行拷贝或赋值操作时，每个shared_ptr都会记录有多少个其他shared_ptr指向相同的对象，<strong>当计数器变为0</strong>，它就会自动释放自己所管理的对象</p>
</li>
<li>
<p>程序使用动态内存的三个原因</p>
<ol>
<li>程序不知道自己需要使用多少对象</li>
<li>程序不知道所需对象的准确类型</li>
<li>程序需要在多个对象间共享数据</li>
</ol>
</li>
</ul>
<h4 id="1212-直接管理内存"><a class="markdownIt-Anchor" href="#1212-直接管理内存"></a> 12.1.2 直接管理内存</h4>
<ul>
<li>
<p>使用new动态分配和初始化对象</p>
<p>只有当括号中仅有一个单一初始化器时才可以使用auto</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> p1 = <span class="keyword">new</span> <span class="keyword">auto</span>(obj);			<span class="comment">// 该对象用obj进行初始化</span></span><br><span class="line"><span class="keyword">auto</span> p2 = <span class="keyword">new</span> <span class="keyword">auto</span>&#123;a, b, c&#125;;		<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>内存耗尽</p>
<p>默认情况下，new分配失败会抛出bad_alloc异常</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *p1 = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line"><span class="keyword">int</span> *p2 = <span class="keyword">new</span> (nothrow) <span class="keyword">int</span>;	<span class="comment">// 阻止异常抛出，返回空指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>释放动态内存</p>
<p>delete表达式执行两个动作：销毁给定的指针指向的对象；释放对应的内存。</p>
</li>
</ul>
<h4 id="1213-shared_ptr和new结合使用"><a class="markdownIt-Anchor" href="#1213-shared_ptr和new结合使用"></a> 12.1.3 shared_ptr和new结合使用</h4>
<ul>
<li>接受指针参数的智能指针构造函数是explicit的，不能将一个内置指针隐式转换为一个智能指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; p1 = <span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>);		<span class="comment">// 错误</span></span><br><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p2</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>(<span class="number">1024</span>))</span></span>;		<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>用来初始化智能指针的普通指针必须指向动态内存</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;T&gt; <span class="title">p</span><span class="params">(p2, d)</span></span></span><br><span class="line">p.reset()				// p是唯一指向其对象的s_p，释放此对象</span><br><span class="line">p.reset(q)				<span class="comment">// 传递了可选的参数内置指针q，p指向q</span></span><br><span class="line">p.reset(q, d)			<span class="comment">// 调用d而不是delete来释放q</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当将一个shared_ptr绑定到一个普通指针时，我们就将内存的管理责任交给了这个shared_ptr。一旦这样做了，我们就不应该再使用内置指针来访问shared_ptr所指向的内存了。</p>
</li>
<li>
<p>get返回一个内置指针，永远不要用get初始化另一个智能指针或者为另一个智能指针赋值。</p>
</li>
<li>
<p>在改变底层对象之前，检查自己是否是当前对象仅有的用户。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(!p.unique())</span><br><span class="line">    p.reset(<span class="keyword">new</span> <span class="built_in">string</span>(*p));	<span class="comment">// 不是唯一用户，分配新的拷贝</span></span><br><span class="line">*p += newVal;					<span class="comment">// 唯一用户，可以改变对象的值</span></span><br></pre></td></tr></table></figure>
<h4 id="1214-智能指针和异常"><a class="markdownIt-Anchor" href="#1214-智能指针和异常"></a> 12.1.4 智能指针和异常</h4>
<ul>
<li>
<p>若异常发生在new之后delete之前，则内存不能正常释放</p>
</li>
<li>
<p>使用我们自己的释放操作</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">destination</span>;</span>					<span class="comment">// 表示我们正在连接什么</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">connection</span>;</span>					<span class="comment">// 使用连接所需的信息</span></span><br><span class="line"><span class="function">connection <span class="title">connect</span><span class="params">(destination*)</span></span>;	<span class="comment">// 打开连接</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(connection)</span></span>;		<span class="comment">// 关闭给定的连接</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">end_connection</span><span class="params">(connection *p)</span></span>&#123; <span class="built_in">disconnect</span>(*p); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="function"><span class="built_in">shared_ptr</span>&lt;connection&gt; <span class="title">p</span><span class="params">(&amp;c, end_connection)</span></span>;</span><br><span class="line">    <span class="comment">// 当f退出时，connection会被正确关闭</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>智能指针陷阱
<ul>
<li>不使用相同的内置指针值初始化(或reset)多个智能指针</li>
<li>不delete get()返回的指针</li>
<li>如果使用get()返回的指针，当最后一个对应的智能指针销毁后，指针就变为无效了</li>
<li>如果使用智能指针管理的资源不是new分配的内存，记住传递给它一个删除器</li>
</ul>
</li>
</ul>
<h4 id="1215-unique_ptr"><a class="markdownIt-Anchor" href="#1215-unique_ptr"></a> 12.1.5 unique_ptr</h4>
<ul>
<li>
<p>没有类似make_shared的标准库函数，因此定义unique_ptr时需要将其绑定到一个new返回的指针上。</p>
</li>
<li>
<p>unique_ptr不支持普通的拷贝或赋值操作</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">unique_ptr</span>&lt;T&gt; u1</span><br><span class="line"><span class="built_in">unique_ptr</span>&lt;T, D&gt; u2			<span class="comment">// u2会使用一个可调用对象D释放指针</span></span><br><span class="line">u.<span class="built_in">release</span>()					<span class="comment">// 放弃对指针的控制权，返回指针</span></span><br><span class="line">u.reset()					<span class="comment">// 释放u指向的对象</span></span><br><span class="line">u.reset(q)					<span class="comment">// 如果提供内置指针q，令u指向q对象</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以通过调用release或reset将指针的所有权从一个unique转移给另一个:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">p2</span><span class="params">(p1,<span class="built_in">release</span>())</span></span>;	<span class="comment">// p1转移给p2</span></span><br><span class="line">p2.reset(p3.<span class="built_in">release</span>());		<span class="comment">// reset释放了p2原来指向的内存</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以拷贝或赋值一个将要被销毁的unique_ptr</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">clone</span><span class="params">(<span class="keyword">int</span> p)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">unique_ptr</span>&lt;<span class="keyword">int</span>&gt;(<span class="keyword">new</span> <span class="keyword">int</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>向unique_ptr传递删除器</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;objT, decT&gt; p(new objT, func);</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(destination &amp;d <span class="comment">/* 其他需要的参数 */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    connection c = <span class="built_in">connect</span>(&amp;d);</span><br><span class="line">    <span class="built_in">unique_ptr</span>&lt;connection, <span class="keyword">decltype</span>(end_connection)*&gt;</span><br><span class="line">        p(&amp;d, end_connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1216-weak_ptr"><a class="markdownIt-Anchor" href="#1216-weak_ptr"></a> 12.1.6 weak_ptr</h4>
<ul>
<li>weak_ptr指向一个由shared_ptr管理的对象，并且不改变shared_ptr的引用计数。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">w.reset()</span><br><span class="line">w.use_count()</span><br><span class="line">w.expired()					<span class="comment">// 若w.use_count()为0返回true</span></span><br><span class="line">w.lock()					<span class="comment">// 若expired为true，返回一个空								 shared_ptr；否则返回一个指向								w对象的shared_ptr</span></span><br></pre></td></tr></table></figure>
<h3 id="122-动态数组"><a class="markdownIt-Anchor" href="#122-动态数组"></a> 12.2 动态数组</h3>
<h4 id="1221-new和数组"><a class="markdownIt-Anchor" href="#1221-new和数组"></a> 12.2.1 new和数组</h4>
<ul>
<li>分配一个数组会得到一个元素类型的指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia = <span class="keyword">new</span> <span class="keyword">int</span>[get_size()];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *pia2 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]();			<span class="comment">// 值初始化</span></span><br><span class="line"><span class="keyword">int</span> *pia3 = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>]&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>释放动态数组</p>
<p>释放一个指向数组首元素的指针，元素被逆序销毁，空方括号对是必需的。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">delete</span> [] pa;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>unique_ptr</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;int[]&gt; up(new int[10]);</span><br><span class="line">up.<span class="built_in">release</span>();					<span class="comment">// 自动用delete[]销毁其指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>unique_ptr指向的时一个数组而不是单个对象，<strong>不能使用点和箭头成员运算符，可以使用下标运算符</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">unique_ptr&lt;T[]&gt; u(p)		// u指向内置指针p所指向的动态分配								  的数组</span><br><span class="line">u[i]</span><br></pre></td></tr></table></figure>
<ul>
<li>share_ptr不支持管理动态数组，如果希望使用，需要自己提供删除器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">shared_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">sp</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">10</span>], [](<span class="keyword">int</span> *p) &#123;<span class="keyword">delete</span>[]p;&#125;)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li>shared_ptr未定义下标运算符，智能指针类型不支持指针算术运算</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="number">10</span>; ++i)</span><br><span class="line">	*(sp.<span class="built_in">get</span>() + i) = i;		<span class="comment">// 使用get获取内置指针</span></span><br></pre></td></tr></table></figure>
<h4 id="1222-allocator类"><a class="markdownIt-Anchor" href="#1222-allocator类"></a> 12.2.2 allocator类</h4>
<ul>
<li>将内存分配和对象构造分离开来</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">allocator&lt;T&gt; a			<span class="comment">// 定义了一个名为a的allocator对象</span></span><br><span class="line">a.allocate(n)			<span class="comment">// 分配一段未构造的内存保存n个对象</span></span><br><span class="line">a.deallocate(p, n)		<span class="comment">// 释放从T*指针p地址开始的内存，p必须							 是一个先前由allocate返回的指针，且							 n必须是p创建时所要求的大小。</span></span><br><span class="line">a.construct(p, agrs)	<span class="comment">// p必须指向一块原始内存；用来在p指向							的内存中构造对象</span></span><br><span class="line">a.destroy(p)			<span class="comment">// 对p指向的对象执行析构函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>分配未构造的内存</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> q = p;</span><br><span class="line">alloc.construct(q++, <span class="number">10</span>, <span class="string">'c'</span>);	<span class="comment">// *q为cccccccccc</span></span><br></pre></td></tr></table></figure>
<ul>
<li>拷贝和填充未初始化内存的算法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">uninitialized_copy(b, e, b2)	<span class="comment">// 从b和e范围拷贝元素到b2指									定的原始内存中。 </span></span><br><span class="line">uninitialized_copy_n(b, n, b2)	<span class="comment">// 从b开始拷贝n个元素到b2中</span></span><br><span class="line">uninitialized_fill(b, e, t)		<span class="comment">// 在b和e范围中创建值为t对象</span></span><br><span class="line">uninitialized_fill_n(b, n, t)	<span class="comment">// 从b开始创建n个值为t的对象</span></span><br></pre></td></tr></table></figure>
<h3 id="123-文本查询程序"><a class="markdownIt-Anchor" href="#123-文本查询程序"></a> 12.3 文本查询程序</h3>
<h4 id="1231-文本查询程序设计"><a class="markdownIt-Anchor" href="#1231-文本查询程序设计"></a> 12.3.1 文本查询程序设计</h4>
<ul>
<li>用vector&lt;string&gt;保存整个输入文件的一份拷贝，每行作为vector中的一个元素</li>
<li>使用istringstream将每行分解为单词</li>
<li>使用set保存每个单词在输入文本中出现的行号</li>
<li>使用一个map将每个单词与它出现的行号set关联起来</li>
</ul>
<h4 id="1232-文本查询程序类的定义"><a class="markdownIt-Anchor" href="#1232-文本查询程序类的定义"></a> 12.3.2 文本查询程序类的定义</h4>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 泛型算法</title>
    <url>/2020/09/04/C++/Chapter%2010%20%E6%B3%9B%E5%9E%8B%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十章-泛型算法"><a class="markdownIt-Anchor" href="#第十章-泛型算法"></a> 第十章 泛型算法</h2>
<h3 id="101-概述"><a class="markdownIt-Anchor" href="#101-概述"></a> 10.1 概述</h3>
<h3 id="102-初始泛型算法"><a class="markdownIt-Anchor" href="#102-初始泛型算法"></a> 10.2 初始泛型算法</h3>
<h4 id="1021-只读算法"><a class="markdownIt-Anchor" href="#1021-只读算法"></a> 10.2.1 只读算法</h4>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">find</span>()</span><br><span class="line">count()</span><br><span class="line">accumulate(<span class="built_in">begin</span>, <span class="built_in">end</span>, <span class="number">0</span>)	  <span class="comment">// 序列中元素类型必须与第三个参数匹配</span></span><br><span class="line">equal(begin1, end1, begin2)	  <span class="comment">// 不能比较2个c-style strings</span></span><br></pre></td></tr></table></figure>
<h4 id="1022-写容器元素的算法"><a class="markdownIt-Anchor" href="#1022-写容器元素的算法"></a> 10.2.2 写容器元素的算法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">fill</span>(b, e, t)</span><br><span class="line">fill_n(b, n, t)</span><br><span class="line">fill_n(back_inserter(vec), <span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>拷贝算法</p>
<p>保留原序列，增加第三个迭代器参数指出调整后序列的保存位置</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">replace_copy(ilist.cbegin(), ilist.cend(), back_inserter(ivec), <span class="number">0</span>, <span class="number">42</span>);</span><br></pre></td></tr></table></figure>
<h4 id="1023-重排容器元素的算法"><a class="markdownIt-Anchor" href="#1023-重排容器元素的算法"></a> 10.2.3 重排容器元素的算法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(b, e)</span><br><span class="line">unique(b, e)</span><br></pre></td></tr></table></figure>
<h3 id="103-定制操作"><a class="markdownIt-Anchor" href="#103-定制操作"></a> 10.3 定制操作</h3>
<h4 id="1031-向算法传递函数"><a class="markdownIt-Anchor" href="#1031-向算法传递函数"></a> 10.3.1 向算法传递函数</h4>
<ul>
<li>
<p>谓词</p>
<p>谓词是一个可调用的表达式，其返回结果是一个能用作条件的值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isShorter</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s1, <span class="keyword">const</span> <span class="built_in">string</span>&amp; s2)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();&#125;</span><br><span class="line"><span class="comment">// 按长度排序</span></span><br><span class="line">sort(words.<span class="built_in">begin</span>(), words,<span class="built_in">end</span>(), isShorter);</span><br></pre></td></tr></table></figure>
<ul>
<li>排序算法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">stable_sort(b, e, isShorter)	<span class="comment">// 保持等长元素间的字典序</span></span><br></pre></td></tr></table></figure>
<h4 id="1032-lambda表达式"><a class="markdownIt-Anchor" href="#1032-lambda表达式"></a> 10.3.2 lambda表达式</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[capture <span class="built_in">list</span>](parameter <span class="built_in">list</span>) -&gt; <span class="keyword">return</span> type&#123;function body&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>capture list是一个lambda所在函数中定义的局部变量的列表（通常为空）</p>
</li>
<li>
<p>lambda必须使用尾置返回</p>
</li>
<li>
<p>可以忽略参数列表和返回类型，但必须永远包含捕获列表和函数体</p>
</li>
<li>
<p><strong>如果lambda的函数体包含任何单一return语句之外的内容，且未指定返回类型，则返回void</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [] &#123;<span class="keyword">return</span> <span class="number">42</span>;&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; f() &lt;&lt; <span class="built_in">endl</span>;		<span class="comment">// 打印42</span></span><br></pre></td></tr></table></figure>
<ul>
<li>向lambda传递参数</li>
<li>只对lambda所在函数中定义的(非static)变量使用捕获列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)</span><br><span class="line">&#123;<span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz;&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1033-lambda捕获和返回"><a class="markdownIt-Anchor" href="#1033-lambda捕获和返回"></a> 10.3.3 lambda捕获和返回</h4>
<ul>
<li>
<p>被捕获的变量的值是在lambda创建时拷贝</p>
</li>
<li>
<p>引用捕获</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">[&amp;os](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)&#123;os &lt;&lt; s ;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>隐式捕获</p>
<p>&amp;: 引用捕获</p>
<p>=: 值捕获</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// os隐式捕获，引用捕获方式；c显示捕获，值捕获方式</span></span><br><span class="line">[&amp;, c](<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) &#123;os &lt;&lt; s &lt;&lt; c;&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>可变lambda</p>
<p>在参数列表首加上关键字mutable可以改变被捕获变量的值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> f = [v1]()<span class="keyword">mutable</span>&#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line"><span class="keyword">auto</span> f2 = [&amp;v1]()&#123;<span class="keyword">return</span> ++v1;&#125;;</span><br><span class="line">v1 = <span class="number">0</span>;</span><br><span class="line">f() = <span class="number">43</span>; f2() = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>返回类型</p>
<p>当我们需要为一个lambda定义返回类型时，必须使用尾置返回类型</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">transform(vi.<span class="built_in">begin</span>(), vi.<span class="built_in">end</span>(), vi.<span class="built_in">begin</span>(), </span><br><span class="line">          [](<span class="keyword">int</span> i) -&gt; <span class="keyword">int</span> </span><br><span class="line">          &#123;<span class="keyword">if</span>(i &lt; <span class="number">0</span>) <span class="keyword">return</span> -i; <span class="keyword">else</span> <span class="keyword">return</span> i;&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="1034-参数绑定"><a class="markdownIt-Anchor" href="#1034-参数绑定"></a> 10.3.4 参数绑定</h4>
<ul>
<li>bind</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> newCallable = bind(callable, arg_list);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check_size</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s, <span class="built_in">string</span>::size_type sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz;&#125;</span><br><span class="line"><span class="comment">// 将第二个参数绑定到sz</span></span><br><span class="line"><span class="keyword">auto</span> check6 = bind(check_size, _1, sz);</span><br></pre></td></tr></table></figure>
<ul>
<li>绑定多个参数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> g = bind(f, a, b, _2, c, _1);</span><br><span class="line">g(X, Y) -&gt; f(a, b, Y, c, X)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>绑定引用参数</p>
<p>不能直接用bind来代替对os的捕获，必须使用标准库<strong>ref</strong>函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bind(<span class="built_in">print</span>, ref(os), _1, <span class="string">' '</span>);</span><br></pre></td></tr></table></figure>
<p>​		函数ref返回一个对象，包含给定的引用，此对象是可以拷贝的。</p>
<h3 id="104-再探迭代器"><a class="markdownIt-Anchor" href="#104-再探迭代器"></a> 10.4 再探迭代器</h3>
<ul>
<li>插入迭代器、流迭代器、反向迭代器、移动迭代器</li>
</ul>
<h4 id="1041-插入迭代器"><a class="markdownIt-Anchor" href="#1041-插入迭代器"></a> 10.4.1 插入迭代器</h4>
<ul>
<li>back_inserter创建一个使用push_back的迭代器</li>
<li>front_inserter创建一个使用push_front的迭代器</li>
<li>inserter创建一个使用insert的迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lst2, lst3;</span><br><span class="line">copy(lst.b, lst.e, front_inserter(lst2));	<span class="comment">// 4 3 2 1</span></span><br><span class="line">copy(lst.b, lst.e, inserter(lst3, lst3.b));	<span class="comment">// 1 2 3 4</span></span><br></pre></td></tr></table></figure>
<h4 id="1042-iostream迭代器"><a class="markdownIt-Anchor" href="#1042-iostream迭代器"></a> 10.4.2 iostream迭代器</h4>
<ul>
<li>istream_iterator操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream_iterator&lt;int&gt; in_iter(cin), eof;	// 从cin读取int</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(in_iter, eof)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用算法操作流迭代器</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; accumulate(in, eof, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>ostream_iterator操作</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ostream_iterator&lt;T&gt; <span class="title">out</span><span class="params">(os, d)</span></span>;		<span class="comment">// out将类型为T的值写到os中</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e : vec)					<span class="comment">// 打印</span></span><br><span class="line">    *out++ = e;</span><br><span class="line">copy(vec.b, vec.e, out);</span><br></pre></td></tr></table></figure>
<h4 id="1043-反向迭代器"><a class="markdownIt-Anchor" href="#1043-反向迭代器"></a> 10.4.3 反向迭代器</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">r.base();							<span class="comment">// 返回对应的普通迭代器</span></span><br></pre></td></tr></table></figure>
<h3 id="105-泛型算法结构"><a class="markdownIt-Anchor" href="#105-泛型算法结构"></a> 10.5 泛型算法结构</h3>
<ul>
<li>输入迭代器、输出迭代器、前向迭代器、双向迭代器、随机访问迭代器</li>
</ul>
<h4 id="1051-5类迭代器"><a class="markdownIt-Anchor" href="#1051-5类迭代器"></a> 10.5.1 5类迭代器</h4>
<ul>
<li>
<p>输入迭代器</p>
<p>必须支持==、!=、++、*、-&gt;运算符</p>
</li>
<li>
<p>输出迭代器</p>
<p>必须支持++、*运算符</p>
</li>
</ul>
<h4 id="1052-算法形参模式"><a class="markdownIt-Anchor" href="#1052-算法形参模式"></a> 10.5.2 算法形参模式</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">alg(beg, <span class="built_in">end</span>, other args);</span><br><span class="line">alg(beg, <span class="built_in">end</span>, dest, other args);	</span><br><span class="line">alg(beg, <span class="built_in">end</span>, beg2, other args);</span><br><span class="line">alg(beg, <span class="built_in">end</span>, beg2, end2, other args);</span><br></pre></td></tr></table></figure>
<ul>
<li>dest通常被绑定到一个插入迭代器或是一个ostream_iterator</li>
</ul>
<h4 id="1053-算法命名规范"><a class="markdownIt-Anchor" href="#1053-算法命名规范"></a> 10.5.3 算法命名规范</h4>
<ul>
<li>
<p>一些算法使用重载形式传递一个谓词</p>
</li>
<li>
<p>接受一个元素值的算法通常有另一个不同名的（不是重载的）版本，<strong>接收谓词参数的算法都有附加的_if前缀</strong></p>
</li>
<li>
<p><strong>将元素写到额外目的空间的算法都在名字后面附加一个_copy</strong></p>
</li>
<li>
<p>一些算法同时提供_copy和 _if版本</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将偶数元素从v1拷贝到v2；v1不变</span></span><br><span class="line">remove_copy_if(v1.<span class="built_in">begin</span>(), b1.<span class="built_in">end</span>(), back_inserter(v2), [](<span class="keyword">int</span> i)&#123;<span class="keyword">return</span> i % <span class="number">2</span>;&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="106-特定容器算法"><a class="markdownIt-Anchor" href="#106-特定容器算法"></a> 10.6 特定容器算法</h3>
<ul>
<li>list和forward_list成员函数版本的算法</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lst.merge(lst2)			<span class="comment">// 将lst2元素合并入lst中，使用&lt;运算符，</span></span><br><span class="line">lst.merge(lst2, comp)	<span class="comment">// lst2变为空，接受谓词</span></span><br><span class="line">    </span><br><span class="line">lst.<span class="built_in">remove</span>()			<span class="comment">// 接受谓词</span></span><br><span class="line">lst.reverse()</span><br><span class="line">lst.sort()				<span class="comment">// 接受谓词</span></span><br><span class="line">lst.unique()			<span class="comment">// 接受谓词</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lst.splce(args)</span><br><span class="line">flst.splice_after(args)</span><br><span class="line">(p, lst2)				<span class="comment">// p指向lst，将lst2元素移到p前，清空lst2</span></span><br><span class="line">(p, lst2, p2)			<span class="comment">// lst2可以是与lst相同的链表</span></span><br><span class="line">(p, lst2, b, e)</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章 关联容器</title>
    <url>/2020/09/04/C++/Chapter%2011%E5%85%B3%E8%81%94%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十一章-关联容器"><a class="markdownIt-Anchor" href="#第十一章-关联容器"></a> 第十一章 关联容器</h2>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">按关键字有序保存元素主线</span><br><span class="line"><span class="built_in">map</span>						<span class="comment">// 键值对</span></span><br><span class="line"><span class="built_in">set</span>						<span class="comment">// 关键字</span></span><br><span class="line"><span class="built_in">multimap</span>				<span class="comment">// 关键字可重复出现</span></span><br><span class="line"><span class="built_in">multiset</span>				<span class="comment">// 关键字可重复出现</span></span><br><span class="line">无序集合</span><br><span class="line"><span class="built_in">unordered_map</span>			<span class="comment">// 用哈希函数组织的map</span></span><br><span class="line"><span class="built_in">unordered_set</span></span><br><span class="line"><span class="built_in">unordered_multimap</span></span><br><span class="line"><span class="built_in">unordered_multiset</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="111-使用关联容器"><a class="markdownIt-Anchor" href="#111-使用关联容器"></a> 11.1 使用关联容器</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; <span class="keyword">word</span>)</span><br><span class="line">    <span class="comment">// 只统计不再exclude中的单词</span></span><br><span class="line">    <span class="keyword">if</span>(exclude.<span class="built_in">find</span>(<span class="keyword">word</span>) == exclude.<span class="built_in">end</span>())</span><br><span class="line">        ++word_count[<span class="keyword">word</span>];</span><br></pre></td></tr></table></figure>
<h3 id="112-关联容器概述"><a class="markdownIt-Anchor" href="#112-关联容器概述"></a> 11.2 关联容器概述</h3>
<ul>
<li>关联容器的迭代器都是双向的</li>
</ul>
<h4 id="1121-定义关联容器"><a class="markdownIt-Anchor" href="#1121-定义关联容器"></a> 11.2.1 定义关联容器</h4>
<h4 id="1122-关键字类型的要求"><a class="markdownIt-Anchor" href="#1122-关键字类型的要求"></a> 11.2.2 关键字类型的要求</h4>
<ul>
<li>必须有&lt;运算符才能使用关联容器</li>
<li>自定义&lt;必须满足严格弱序</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用自定义操作</span></span><br><span class="line">multiset&lt;Sales_data, decltype(compareIsbn)*&gt; bookstore(compareIsbn);</span><br><span class="line"><span class="comment">// 用compareIsbn来初始化bookstore对象，表示当我们向bookstore添加元素时，通过调用compareIsbn来为这些元素排序。</span></span><br></pre></td></tr></table></figure>
<h4 id="1123-pair类型"><a class="markdownIt-Anchor" href="#1123-pair类型"></a> 11.2.3 pair类型</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;T1, T2&gt; p;</span><br><span class="line">pair&lt;T1, T2&gt; p(v1, v2);</span><br><span class="line">make_pair(v1, v2);			<span class="comment">// pair的类型从v1和v2类型推断出来</span></span><br><span class="line">p1 relop p2					<span class="comment">// 关系运算符</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pair&lt;string, int&gt; process(vector&lt;string&gt;&amp; v)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> make_pair(v.back(), v.back().<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="113-关联容器操作"><a class="markdownIt-Anchor" href="#113-关联容器操作"></a> 11.3 关联容器操作</h3>
<ul>
<li>关联容器额外的类型别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">key_type			<span class="comment">// 关键字类型</span></span><br><span class="line">mapped_type			<span class="comment">// 关键字关联的类型</span></span><br><span class="line">value_type			<span class="comment">// 对于set，与key_type相同，对于map，</span></span><br><span class="line">    				<span class="comment">// 为pair&lt;const key_type,mapped_type&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="1131-关联容器迭代器"><a class="markdownIt-Anchor" href="#1131-关联容器迭代器"></a> 11.3.1 关联容器迭代器</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获得指向word_count中一个元素的迭代器</span></span><br><span class="line"><span class="keyword">auto</span> map_it = word_count.<span class="built_in">begin</span>();</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;first;			<span class="comment">// 关键字</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; map_it-&gt;second;			<span class="comment">// 值</span></span><br><span class="line">map_it-&gt;first = <span class="string">"new key"</span>;		<span class="comment">// 错误：关键字是const的</span></span><br><span class="line">__map_it-&gt;second;				<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h4 id="1132-添加元素"><a class="markdownIt-Anchor" href="#1132-添加元素"></a> 11.3.2 添加元素</h4>
<ul>
<li>插入一个已存在的元素对set、map没有影响</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">set</span>.insert(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">set</span>.insert(&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>&#125;);</span><br><span class="line">c.emplace(args)</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>insert和emplace返回一个pair</strong>，first成员是一个迭代器，指向具有给定关键字的元素；second成员是一个bool值，指出元素是否成功插入。</p>
</li>
<li>
<p>向multiset或multimap添加元素</p>
<p><strong>insert返回一个指向新元素的迭代器</strong></p>
</li>
</ul>
<h4 id="1133-删除元素"><a class="markdownIt-Anchor" href="#1133-删除元素"></a> 11.3.3 删除元素</h4>
<ul>
<li>erase接受一个key_type参数，删除所有匹配给定关键字的元素，<strong>返回实际删除的元素的数量</strong>。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.erase(k)</span><br><span class="line">c.erase(p)				<span class="comment">// 删除迭代器p指定的元素</span></span><br><span class="line">c.erase(b, e)			<span class="comment">// 删除范围中元素</span></span><br></pre></td></tr></table></figure>
<h4 id="1134-map的下标操作"><a class="markdownIt-Anchor" href="#1134-map的下标操作"></a> 11.3.4 map的下标操作</h4>
<ul>
<li><strong>如果关键字不在map中，会创建一个元素插入到map中</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c[k]					<span class="comment">// k不在c中，添加k</span></span><br><span class="line">c.at(k)					<span class="comment">// k不在c中，抛出out_of_range异常</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当对一个map进行下标操作时，会获得一个mapped_type对象</li>
</ul>
<h4 id="1135-访问元素"><a class="markdownIt-Anchor" href="#1135-访问元素"></a> 11.3.5 访问元素</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lower_bound和upper_bound不适用于无需容器</span><br><span class="line">c.<span class="built_in">find</span>(k)				</span><br><span class="line">c.count(k)				<span class="comment">// 返回值永远是0或1</span></span><br><span class="line">c.lower_bound(k)		<span class="comment">// 第一个关键字不小于k的元素</span></span><br><span class="line">c.upper_bound(k)		<span class="comment">// 第一个关键字大于k的元素</span></span><br><span class="line">c.equal_range(k)		<span class="comment">// 返回pair，表示关键字等于k的元素范围</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果一个multi中有多个元素具有给定关键字，这些元素在容器中会相邻存储</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">search_item</span><span class="params">(<span class="string">"A"</span>)</span></span>;</span><br><span class="line"><span class="keyword">auto</span> entries = authors.count(search_iterm);</span><br><span class="line"><span class="keyword">auto</span> iter = authors.<span class="built_in">find</span>(search_item);</span><br><span class="line"><span class="keyword">while</span>(ehtries) &#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; iter-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    ++iter;</span><br><span class="line">    --entries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>lower_bound和upper_bound会得到一个迭代器范围</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> beg = authors.lower_bound(search_item), </span><br><span class="line">   		  <span class="built_in">end</span> = authors.upper_bound(search_item);</span><br><span class="line">   	beg != <span class="built_in">end</span>; ++beg)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; beg-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>equal_range返回一个迭代器pair，表示匹配元素范围</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> pos = authors.equal_range(search_item);</span><br><span class="line">   	pos.first != pos.second; pos.first++)</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; pos.first-&gt;second &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1136-一个单词转换的map"><a class="markdownIt-Anchor" href="#1136-一个单词转换的map"></a> 11.3.6 一个单词转换的map</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">word_transform</span><span class="params">(ifstream&amp; <span class="built_in">map</span>, ifstream&amp; input)</span></span>;</span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;buildMap(ifstream&amp; <span class="built_in">map</span>);</span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">transform</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> s, <span class="keyword">const</span> <span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt;&amp; m)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="114-无序容器"><a class="markdownIt-Anchor" href="#114-无序容器"></a> 11.4 无序容器</h3>
<ul>
<li>
<p>无序容器在存储在组织为一组桶，**使用一个哈希函数将元素映射到桶。**无序容器的性能依赖于哈希函数的质量和桶的数量和大小。</p>
</li>
<li>
<p>桶接口</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.bucket_count()			<span class="comment">// 正在使用的桶的数目</span></span><br><span class="line">c.max_bucket_count()		<span class="comment">// 容器能容纳的最多的桶的数量</span></span><br><span class="line">c.bucket_size(n)			<span class="comment">// 第n个桶中有多少个元素</span></span><br><span class="line">c.bucket(k)					<span class="comment">// 关键字为k的元素在哪个桶中</span></span><br></pre></td></tr></table></figure>
<ul>
<li>桶迭代</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">local_iterator				<span class="comment">// 可以用来访问桶中元素的迭代器类型</span></span><br><span class="line">const_local_iterator</span><br></pre></td></tr></table></figure>
<ul>
<li>哈希策略</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.load_factor()				<span class="comment">// 每个桶的平均元素数量，返回float</span></span><br><span class="line">c.max_load_factor()			<span class="comment">// 试图维护的平均桶大小，返回float</span></span><br><span class="line">c.rehash(n)					<span class="comment">// 重组存储，使得bucket_count&gt;=n</span></span><br><span class="line">    				<span class="comment">// 且bucket_count&gt;size/max_load_factor</span></span><br><span class="line">c.reserve(n)				<span class="comment">// 重组存储，使得c可以保存n个元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>无序容器对关键字类型的要求</p>
<p>默认情况下， <strong>无序容器使用关键字类型的==运算符来比较元素</strong>，它们还使用一个hash&lt;key_type&gt;类型的对象来生成每个元素的哈希值。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">size_t</span> <span class="title">hasher</span><span class="params">(<span class="keyword">const</span> Sales_data &amp;sd)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(sd.isbn());&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">qaOp</span><span class="params">(<span class="keyword">const</span> Sales_data&amp; lhs, <span class="keyword">const</span> Sales_data&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> lhs.isbn() == rhs.isbn(); &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> SD_multiset = <span class="built_in">unordered_multiset</span>&lt;Sales_data, <span class="keyword">decltype</span>(hasher)*, <span class="keyword">decltype</span>(eqOp)*&gt;;</span><br><span class="line"><span class="comment">// 参数是桶大小，哈希函数指针和相等性判断运算符指针</span></span><br><span class="line"><span class="function">SD_multiset <span class="title">bookstore</span><span class="params">(<span class="number">42</span>, hasher, eqOp)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果类定义了==运算符，则可以只重载哈希函数：</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">unordered_set&lt;f, decltype(fHash)*&gt; fSet(10, fHash);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十六章 模板与泛型编程</title>
    <url>/2020/09/04/C++/Chapter%2016%20%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十六章-模板与泛型编程"><a class="markdownIt-Anchor" href="#第十六章-模板与泛型编程"></a> 第十六章 模板与泛型编程</h2>
<h3 id="161-定义模板"><a class="markdownIt-Anchor" href="#161-定义模板"></a> 16.1 定义模板</h3>
<h4 id="1611-函数模板"><a class="markdownIt-Anchor" href="#1611-函数模板"></a> 16.1.1 函数模板</h4>
<ul>
<li>
<p>template</p>
<p>​	模板参数表示在类或函数定义中用到的类型或值</p>
</li>
</ul>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(v1 &lt; v2) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(v2 &lt; v1) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>实例化函数模板</p>
<ul>
<li>
<p>编译器用实参类型来确定模板参数类型</p>
</li>
<li>
<p>编译器生成的版本被称为模板的实例</p>
</li>
</ul>
</li>
<li>
<p>模板类型参数</p>
<p>​	<strong>类型参数前必须使用关键字class或typename</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T,<span class="class"><span class="keyword">class</span> <span class="title">U</span>&gt; <span class="title">calc</span>(<span class="title">const</span> <span class="title">T</span>&amp;, <span class="title">const</span> <span class="title">U</span>&amp;);</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>非类型模板参数</p>
<p>非类型模板参数的模板实参必须是常量表达式</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>(&amp;p1)[N], <span class="keyword">const</span> <span class="keyword">char</span>(&amp;p2)[M])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>inline和constexpr的函数模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">inline</span> T <span class="title">min</span><span class="params">(<span class="keyword">const</span> T&amp;, constT&amp;)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>编写类型无关的代码</p>
<p>​		模板程序应该尽量减少对实参类型的要求</p>
<ul>
<li>
<p>函数参数是const的引用</p>
</li>
<li>
<p>只用小于号（甚至是用less）</p>
</li>
</ul>
</li>
<li>
<p>模板编译</p>
<p>​		为了生成一个实例化版本，编译器需要掌握函数模板或类模板成员函数的定义，<strong>模板的头文件通常既包括声明也包括定义</strong></p>
</li>
<li>
<p>大多数编译错误在实例化期间报告</p>
</li>
</ul>
<h4 id="1612-类模板"><a class="markdownIt-Anchor" href="#1612-类模板"></a> 16.1.2 类模板</h4>
<ul>
<li>定义类模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">typedef</span> T value_type;</span><br><span class="line">    <span class="keyword">typedef</span> <span class="keyword">typename</span> <span class="built_in">vector</span>&lt;T&gt;::size_type size_type;</span><br><span class="line">    Blob();</span><br><span class="line">    Blob(<span class="built_in">initializer_list</span>&lt;T&gt; il);</span><br><span class="line">    <span class="function">size_type <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;<span class="built_in">size</span>(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> data-&gt;empty(); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(T&amp;&amp; t)</span> </span>&#123; data-&gt;push_back(<span class="built_in">move</span>(t));&#125;</span><br><span class="line">    <span class="keyword">void</span> pop_back;</span><br><span class="line">    </span><br><span class="line">    <span class="function">T&amp; <span class="title">back</span><span class="params">()</span></span>;</span><br><span class="line">    T&amp; <span class="keyword">operator</span>[](size_type i);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    shread_ptr&lt;<span class="built_in">vector</span>&lt;T&gt;&gt; data;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check</span><span class="params">(size_type i, <span class="keyword">const</span> <span class="built_in">string</span>&amp; msg)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类模板的成员函数</p>
<p>​	<strong>定义在类模板之外的成员函数必须以关键字template开始</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; ret-type Blob&lt;T&gt;::member-name(parm-<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<ul>
<li>Blob</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::check(size_type i, <span class="keyword">const</span> <span class="built_in">string</span>&amp; msg) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(i &gt;= data-&gt;<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">throw</span> out_of_range(msg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::back()</span><br><span class="line">&#123;</span><br><span class="line">	check(<span class="number">0</span>, <span class="string">"back on empty Blob"</span>);</span><br><span class="line">    <span class="keyword">return</span> data-&gt;back();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T&amp; Blob&lt;T&gt;::<span class="keyword">operator</span>[](size_type i)</span><br><span class="line">&#123;</span><br><span class="line">    check(i, <span class="string">"subscript out of range"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*data)[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Blob&lt;T&gt;::pop_back()</span><br><span class="line">&#123;</span><br><span class="line">    check(<span class="number">0</span>, <span class="string">"pop_back on empty Blob"</span>);</span><br><span class="line">    data-&gt;pop_back();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Blob构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob() : data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;()) &#123; &#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(<span class="built_in">initializer_list</span>&lt;T&gt; il) : </span><br><span class="line">				data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(il))&#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类模板成员函数的实例化</p>
<p>​		默认情况下，一个类模板的成员函数只有当程序用到它时才进行实例化</p>
</li>
<li>
<p>在一个类模板的<strong>作用域内</strong>，我们可以直接使用模板名而不必指定模板实参</p>
</li>
<li>
<p>一对一友好关系</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span>;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">	<span class="keyword">bool</span> perator==(<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Blob</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BlobPtr</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==&lt;T&gt;</span><br><span class="line">        (<span class="keyword">const</span> Blob&lt;T&gt;&amp;, <span class="keyword">const</span> Blob&lt;T&gt;&amp;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>通用和特定的模板友好关系</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 前置声明</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Pal</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> &#123;</span>	<span class="comment">// C是普通的非模板类</span></span><br><span class="line">    <span class="comment">// Pal2的所有实例都是C的友元</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal2</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">C2</span> &#123;</span>	<span class="comment">// C2 本身是一个模板</span></span><br><span class="line">    <span class="comment">// C2的每个实例将相同实例化的Pal声明为友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pa1</span>&lt;T&gt;;</span></span><br><span class="line">    <span class="comment">// Pal3是一个非模板类，它是C2所有实例的友元</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Pal3</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>令模板自己的类型参数成为友元</p>
<p>​	Sales_data是Bar&lt;Sales_data&gt;的友元</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> type&gt; <span class="class"><span class="keyword">class</span> <span class="title">Bar</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Type;	<span class="comment">// 将访问权限授予用来实例化Bar的类型</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>模板类型别名</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> twin = pair&lt;T, T&gt;;</span><br><span class="line">twin&lt;<span class="built_in">string</span>&gt; authors; <span class="comment">// authors是一个pair&lt;T, T&gt;;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">using</span> partNo = pair&lt;T, <span class="keyword">unsigned</span>&gt;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类模板的static成员</p>
<p>​		对任意给定类型X，都有一个Foo&lt;X&gt;::ctr和一个Foo&lt;X&gt;::count成员，所有Foo&lt;X&gt;类型的对象共享相同的ctr和count</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">size_t</span> <span class="title">count</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> ctr; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    staitc <span class="keyword">size_t</span> ctr = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="1613-模板参数"><a class="markdownIt-Anchor" href="#1613-模板参数"></a> 16.1.3 模板参数</h4>
<ul>
<li>
<p>模板声明必须包含模板参数</p>
</li>
<li>
<p>使用类的类型成员</p>
<p>​		编译器需要知道我们正在定义一个名为p的变量还是将一个名为size_type的static数据成员与名为p的变量相乘</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">T::size_type * p;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>当我们希望通知编译器一个名字表示类型时，必须使用关键字typename</strong>而非class</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">typename</span> T::value_type <span class="title">top</span><span class="params">(<span class="keyword">const</span> T&amp; c)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认模板实参</p>
<ul>
<li>对于一个模板参数，只有当它右侧的所有参数都有默认实参时，它才可以有默认实参</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> F = less&lt;T&gt;&gt;</span><br><span class="line"><span class="keyword">int</span> compare(<span class="keyword">const</span> T&amp; v1, <span class="keyword">const</span> T&amp; v2, F f = F()) &#123;</span><br><span class="line">    <span class="keyword">if</span>(f(v1, v2)) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span>(f(v2, v1)) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>模板默认实参与类模板
<ul>
<li>无论何时使用一个类模板，都必须在模板名后接上尖括号</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span> = <span class="title">int</span>&gt; <span class="title">class</span> <span class="title">Numbers</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Numbers(T v= <span class="number">0</span>) : val(v) &#123; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    T val;</span><br><span class="line">&#125;;</span><br><span class="line">Numbers&lt;&gt; average_precision;</span><br></pre></td></tr></table></figure>
<h4 id="1614-成员模板"><a class="markdownIt-Anchor" href="#1614-成员模板"></a> 16.1.4 成员模板</h4>
<ul>
<li>成员模板不能是虚函数</li>
<li>普通（非模板）类的成员模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 对给定指针执行delete</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DebugDelete</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DebugDelete(ostream&amp; s = <span class="built_in">cerr</span>) : os(s) &#123; &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">operaotr</span><span class="params">()</span><span class="params">(T *p)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; os &lt;&lt; <span class="string">"deleting unique_ptr"</span> &lt;&lt; <span class="built_in">endl</span>; <span class="keyword">delete</span> p; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; os;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> *p = <span class="keyword">new</span> <span class="keyword">double</span>;</span><br><span class="line">DebugDelete d;</span><br><span class="line">d(p);</span><br><span class="line"><span class="keyword">int</span> * ip = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">DeBugDelete()(ip);</span><br></pre></td></tr></table></figure>
<p>​			由于调用一个DebugDelete对象会delete其给定的指针，我们也可以将DebugDelete用作删除器</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 实例化DebugDelete::operator()&lt;int&gt;(int*)</span></span><br><span class="line">unique_ptr&lt;int, DebugDelete&gt; p(new int, DebugDelete());</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>类模板的成员模板</p>
<p>​		当我们在类模板外定义一个成员模板时，必须同时为类模板和成员模板提供模板参数列表</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">Blob&lt;T&gt;::Blob(It b, It e) :</span><br><span class="line">	data(make_shared&lt;<span class="built_in">vector</span>&lt;T&gt;&gt;(b, e)) &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1615-控制实例化"><a class="markdownIt-Anchor" href="#1615-控制实例化"></a> 16.1.5 控制实例化</h4>
<ul>
<li>显式实例化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">template</span> declaration;			<span class="comment">// 实例化声明</span></span><br><span class="line"><span class="keyword">template</span> declaration;					<span class="comment">// 实例化定义</span></span><br></pre></td></tr></table></figure>
<p>​			由于编译器在使用一个模板时自动对其实例化，因此extern声明必须出现在任何使用此实例化版本的代码之前</p>
<ul>
<li>实例化定义会实例化所有成员</li>
</ul>
<h4 id="1616-效率与灵活性"><a class="markdownIt-Anchor" href="#1616-效率与灵活性"></a> 16.1.6 效率与灵活性</h4>
<p>​			通过在编译时绑定删除器，unique_ptr避免了间接调用删除器的运行时开销。通过在运行时绑定删除器，shared_ptr使用户重载删除器更为方便</p>
<h3 id="162-模板实参推断"><a class="markdownIt-Anchor" href="#162-模板实参推断"></a> 16.2 模板实参推断</h3>
<h4 id="1621-类型转换与模板类型参数"><a class="markdownIt-Anchor" href="#1621-类型转换与模板类型参数"></a> 16.2.1 类型转换与模板类型参数</h4>
<ul>
<li>能在调用中应用于函数模板的两项：
<ul>
<li>const转换：将一个非const对象的引用传递给一个const引用形参</li>
<li>数组或函数指针转换：如果函数形参不是引用类型，则可以对实参应用正常的指针转换</li>
</ul>
</li>
</ul>
<h4 id="1622-函数模板显式实参"><a class="markdownIt-Anchor" href="#1622-函数模板显式实参"></a> 16.2.2 函数模板显式实参</h4>
<ul>
<li>指定显式模板实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2, <span class="keyword">typename</span> T3&gt;</span><br><span class="line"><span class="function">T1 <span class="title">sum</span><span class="params">(T2, T3)</span></span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> val = sum&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(<span class="keyword">int</span> i,<span class="keyword">long</span> lng);</span><br></pre></td></tr></table></figure>
<ul>
<li>正常类型转换应用于显式指定的实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">long</span> lng;</span><br><span class="line">compare&lt;<span class="keyword">long</span>&gt;(lng, <span class="number">1024</span>);</span><br></pre></td></tr></table></figure>
<h4 id="1623-尾置返回类型与类型转换"><a class="markdownIt-Anchor" href="#1623-尾置返回类型与类型转换"></a> 16.2.3 尾置返回类型与类型转换</h4>
<p>​			由于尾置返回出现在参数列表之后，它可以使用函数的参数</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn(It beg, It end) -&gt; decltype(*beg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>进行类型转换的标准库模板类</p>
<p>​		有时我们无法直接获得所需要的类型，可以使用type_traits中的类型转换模板</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 返回一个元素值的版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> It&gt;</span><br><span class="line">auto fcn2(It beg, It end) -&gt; </span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;<span class="keyword">decltype</span>(*beg)&gt;::type</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理序列</span></span><br><span class="line">    <span class="keyword">return</span> *beg;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1624-函数指针和实参推断"><a class="markdownIt-Anchor" href="#1624-函数指针和实参推断"></a> 16.2.4 函数指针和实参推断</h4>
<p>​			当我们用一个函数模板初始化一个函数指针或为一个函数指针赋值时，编译器使用指针的类型来推断模板实参</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> T&amp;, <span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">int</span> (*pf1)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;) = compare;</span><br></pre></td></tr></table></figure>
<ul>
<li>重载时需要使用显式模板实参消除歧义</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">((<span class="keyword">int</span>*)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;))</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">((<span class="keyword">int</span>*)(<span class="keyword">const</span> <span class="keyword">int</span>&amp;, <span class="keyword">const</span> <span class="keyword">int</span>&amp;))</span></span>;</span><br><span class="line">func(compare&lt;<span class="keyword">int</span>&gt;);</span><br></pre></td></tr></table></figure>
<h4 id="1625-模板实参推断和引用"><a class="markdownIt-Anchor" href="#1625-模板实参推断和引用"></a> 16.2.5 模板实参推断和引用</h4>
<ul>
<li>从左值引用函数参数推断类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="comment">// 在每个调用中，f2的函数参数都被推断为const int&amp;</span></span><br><span class="line">f2(<span class="keyword">int</span> i);			<span class="comment">// T都是int</span></span><br><span class="line">f2(<span class="keyword">const</span> <span class="keyword">int</span> ci);</span><br><span class="line">f2(<span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>从右值引用函数参数推断类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f3</span><span class="params">(T&amp;&amp;)</span></span></span><br><span class="line"><span class="function"><span class="title">f3</span><span class="params">(<span class="number">42</span>)</span></span>;				<span class="comment">// T是int</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p><strong>引用折叠和右值引用参数</strong></p>
<ul>
<li>对于一个给定类型X:</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">X&amp; &amp;、X&amp; &amp;&amp;和X&amp;&amp; &amp;都折叠成类型X&amp;</span><br><span class="line">类型X&amp;&amp; &amp;&amp;折叠成X&amp;&amp;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们将一个左值传递给f3(右值引用)函数参数时，编译器推断T为一个左值引用类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">f3(<span class="keyword">int</span> i);			<span class="comment">// T是int&amp; </span></span><br><span class="line">f3(<span class="keyword">const</span> <span class="keyword">int</span> ci);	<span class="comment">// T是const int&amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>结论：对于T&amp;&amp;类型的函数参数，我们可以传递给它右值，也可以传递给它左值</strong></li>
</ul>
</li>
<li>
<p>编写接受右值引用参数的模板函数</p>
<p>​	我们可以对使用右值引用的函数模板进行重载</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(T&amp;&amp;)</span></span>;	<span class="comment">// 绑定到非const右值</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;	<span class="comment">// 左值和const右</span></span><br></pre></td></tr></table></figure>
<h4 id="1626-理解stdmove"><a class="markdownIt-Anchor" href="#1626-理解stdmove"></a> 16.2.6 理解std::move</h4>
<ul>
<li>
<p>std::move的定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp; <span class="title">move</span><span class="params">(T&amp;&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span></span><br><span class="line">        &lt;<span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp;&gt;(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>传递右值&quot;hello&quot;：</p>
<ul>
<li>推断出T的类型为string</li>
<li>remove_reference用string进行实例化</li>
<li>type是string</li>
<li>move的返回类型是string&amp;&amp;</li>
<li>move的函数参数t的类型是string&amp;&amp;</li>
<li>函数：string&amp;&amp; move(string&amp;&amp; t){ return t; }</li>
</ul>
</li>
<li>
<p>传递左值</p>
<ul>
<li>T的类型为string&amp;</li>
<li>remove_reference用string&amp;进行实例化</li>
<li>type是string</li>
<li>move的返回类型是string</li>
<li>move的函数参数t实例化为string&amp; &amp;&amp;，折叠为string&amp;</li>
<li>static_cast&lt;string&amp;&amp;&gt;(t)将t转换为string&amp;&amp;</li>
</ul>
<h4 id="1627-转发"><a class="markdownIt-Anchor" href="#1627-转发"></a> 16.2.7 转发</h4>
</li>
</ul>
</li>
<li>
<p>定义能保持类型信息的函数参数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">voif <span class="title">f</span><span class="params">(<span class="keyword">int</span> v1, <span class="keyword">int</span>&amp; v2)</span> </span>&#123; <span class="built_in">cout</span> &lt;&lt; v1 &lt;&lt; ++v2 &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line"><span class="comment">// 可以接受一个左值引用和函数，不能接受右值引用参数的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> F, <span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">flip2</span><span class="params">(F f, T1&amp;&amp; t1, T2&amp;&amp; t2)</span></span></span><br><span class="line"><span class="function"></span>&#123;	f(t2, t1;)	&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在调用中使用std::forward保持类型信息</p>
<ul>
<li>forward必须通过显式模板实参来调用</li>
<li>forward返回该显式实参类型的右值引用</li>
</ul>
</li>
<li>
<p><strong>当用于一个指向模板参数类型的右值引用函数参数(T&amp;&amp;)时，forward会保持实参类型的所有细节</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt; intermediary(Type&amp;&amp; arg)</span><br><span class="line">&#123;</span><br><span class="line">    finalFcn(<span class="built_in">std</span>::forward&lt;Type&gt;(arg));</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>实参是右值：
<ul>
<li>Type是普通类型</li>
<li>forward&lt;Type&gt;返回Type&amp;&amp;</li>
</ul>
</li>
<li>实参是左值:
<ul>
<li>Type本身是一个左值引用类型</li>
<li>对forward&lt;type&gt;返回类型进行引用折叠，返回一个左值引用类型</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="163-重载与模板"><a class="markdownIt-Anchor" href="#163-重载与模板"></a> 16.3 重载与模板</h3>
<ul>
<li>编写重载模板</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(<span class="keyword">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; t;</span><br><span class="line">    <span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="built_in">string</span> <span class="title">debug_rep</span><span class="params">(T* p)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">ostringstream</span> ret;</span><br><span class="line">    ret &lt;&lt; <span class="string">"pointer: "</span> &lt;&lt; p;</span><br><span class="line">    <span class="keyword">if</span>(p)</span><br><span class="line">        ret &lt;&lt; <span class="string">" "</span> &lt;&lt; debug_rep(*p);</span><br><span class="line">    <span class="keyword">else</span> </span><br><span class="line">        ret &lt;&lt; <span class="string">" null pointer"</span>;</span><br><span class="line">    <span class="keyword">return</span> ret.str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当有多个重载模板对一个调用提供同样好的匹配时，应选择最特例化的版本</li>
</ul>
<h3 id="164-可变参数模板"><a class="markdownIt-Anchor" href="#164-可变参数模板"></a> 16.4 可变参数模板</h3>
<pre><code>  可变参数模板就是一个接收可变数目参数的模板函数或模板类,可变数目的参数被称为参数包，存在两种参数包：模板参数包、函数参数包
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Args是一个模板参数包；reset是一个函数参数包</span></span><br><span class="line"><span class="comment">// Args表示零个或多个模板类型参数</span></span><br><span class="line"><span class="comment">// rest表示零个或多个函数参数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">const</span> T&amp; t, <span class="keyword">const</span> Args&amp; ... rest)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>编译器会推断包中参数的数目</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; <span class="keyword">double</span> d = <span class="number">3.14</span>; <span class="built_in">string</span> s= <span class="string">"hello world!"</span>;</span><br><span class="line">foo(i, s, <span class="number">42</span>, d);		<span class="comment">// 包中有3个参数</span></span><br><span class="line">foo(d, s);				<span class="comment">// 包中有1个参数</span></span><br><span class="line">foo(<span class="string">"hi"</span>);				<span class="comment">// 空包</span></span><br></pre></td></tr></table></figure>
<ul>
<li>sizeof…运算符（注意有…）</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">(Args ... args)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(Args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 类型参数的数目</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>...(args) &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 函数参数的数目</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1641-编写可变参数函数模板"><a class="markdownIt-Anchor" href="#1641-编写可变参数函数模板"></a> 16.4.1 编写可变参数函数模板</h4>
<p>​	    <strong>可变参数函数通常是递归的。第一步调用处理包中的第一个实参，然后用剩余实参调用自身</strong></p>
  <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用来终止递归并打印最后一个元素的函数</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t)</span></span></span><br><span class="line"><span class="function"></span>&#123; <span class="keyword">return</span> os &lt;&lt; t; &#125;</span><br><span class="line"><span class="comment">// 包中除了最后一个元素之外的其他元素都会调用这个版本print</span></span><br><span class="line">tempalte &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> ... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> T&amp; t,<span class="keyword">const</span> Args&amp; ... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> 	os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1642-包扩展"><a class="markdownIt-Anchor" href="#1642-包扩展"></a> 16.4.2 包扩展</h4>
<p>​		扩展一个包就是将它分解为构成的元素，我们通过在模式右边放一个省略号来触发扩展操作</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span>... Args&gt;</span><br><span class="line">ostream&amp; <span class="built_in">print</span></span><br><span class="line">(ostream&amp; os,<span class="keyword">const</span> T&amp; t,<span class="keyword">const</span> Args&amp;... rest)<span class="comment">// 扩展Args</span></span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; t &lt;&lt; <span class="string">", "</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, rest...);				<span class="comment">// 扩展rest</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>理解包扩展</p>
<p>​	扩展中的模式会独立地应用于包中的每个元素</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span>... Args&gt;</span><br><span class="line"><span class="function">ostream&amp; <span class="title">errorMsg</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Args&amp;... rest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">print</span>(os, debug_rep(rest)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1643-转发参数包"><a class="markdownIt-Anchor" href="#1643-转发参数包"></a> 16.4.3 转发参数包</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt; </span></span><br><span class="line"><span class="class">        <span class="title">void</span> <span class="title">emplace_back</span>(<span class="title">Args</span>&amp;&amp;...);</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span>... <span class="title">Args</span>&gt; </span></span><br><span class="line"><span class="class"><span class="title">inline</span> <span class="title">void</span> <span class="title">StrVec</span>:</span>:emplace_back(Args&amp;&amp;... args)</span><br><span class="line">&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, <span class="built_in">std</span>::forward&lt;Args&gt;(args)...);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		既扩展了模板参数包Args，也扩展了函数参数包args</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 生成元素：std::forward&lt;Ti&gt;&lt;ti&gt;</span></span><br><span class="line">svec.emplace_back(<span class="number">10</span>, <span class="string">'c'</span>);</span><br><span class="line"><span class="comment">// 扩展:</span></span><br><span class="line"><span class="built_in">std</span>::forward&lt;<span class="keyword">int</span>&gt;(<span class="number">10</span>), <span class="built_in">std</span>::forward&lt;<span class="keyword">char</span>&gt;(c)</span><br></pre></td></tr></table></figure>
<h3 id="165-模板特例化"><a class="markdownIt-Anchor" href="#165-模板特例化"></a> 16.5 模板特例化</h3>
<p>​		一个特例化版本就是模板的一个独立的定义，在其中一个或多个模板参数被指定为特定的类型</p>
<ul>
<li>
<p>定义函数模板特例化</p>
<p>​	空尖括号对指出我们将为原模版的所有模板参数提供实参</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span>&amp; p1,<span class="keyword">const</span> <span class="keyword">char</span>*<span class="keyword">const</span>&amp; p2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>函数重载与模板特例化</p>
<p>​		模板及其特例化版本应该声明在同一头文件中。所有同名模板的声明应该放在前面，然后是这些模板的特例化版本</p>
</li>
<li>
<p>类模板特例化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 打开std命名空间，以便特例化std::hash</span></span><br><span class="line"><span class="keyword">namespace</span> <span class="built_in">std</span>&#123;</span><br><span class="line"><span class="keyword">template</span> &lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hash</span>&lt;Sales_data&gt;</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">typedef</span> <span class="keyword">size_t</span> result_type;</span><br><span class="line">    <span class="keyword">typedef</span> Sales_data argument_type;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">size_t</span></span><br><span class="line">hash&lt;Sales_data&gt;::<span class="keyword">operator</span>()(<span class="keyword">const</span> Sales_data&amp; s) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> hash&lt;<span class="built_in">string</span>&gt;()(s.bookNo) ^ </span><br><span class="line">        	hash&lt;<span class="keyword">unsigned</span>&gt;()(s.units_sold) ^</span><br><span class="line">        hash&lt;<span class="keyword">double</span>&gt;()(s.revenue);</span><br><span class="line">&#125;</span><br><span class="line">&#125;	<span class="comment">// 关闭空间，注意：没有分号</span></span><br></pre></td></tr></table></figure>
<ul>
<li>类模板部分特例化</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">remove_reference</span> </span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&gt; </span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> &gt; <span class="title">struct</span> <span class="title">remove_reference</span>&lt;T&amp;&amp;&gt;</span></span><br><span class="line"><span class="class">&#123;</span> <span class="keyword">typedef</span> T type; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;			<span class="comment">// a, b, c均为int</span></span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="number">42</span>)&gt;::type a;</span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(i)&gt;::type b;</span><br><span class="line">remove_reference&lt;<span class="keyword">decltype</span>(<span class="built_in">std</span>::<span class="built_in">move</span>(i))&gt;::type c;</span><br></pre></td></tr></table></figure>
<ul>
<li>特例化成员而不是类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="keyword">void</span> Foo&lt;<span class="keyword">int</span>&gt;::Bar() &#123; &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 变量和基本类型</title>
    <url>/2020/09/04/C++/Chapter%202%20%E5%8F%98%E9%87%8F%E5%92%8C%E5%9F%BA%E6%9C%AC%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第二章-变量和基本类型"><a class="markdownIt-Anchor" href="#第二章-变量和基本类型"></a> 第二章 变量和基本类型</h2>
<h3 id="21-基本内置类型"><a class="markdownIt-Anchor" href="#21-基本内置类型"></a> 2.1 基本内置类型</h3>
<h4 id="211-算术类型"><a class="markdownIt-Anchor" href="#211-算术类型"></a> 2.1.1 算术类型</h4>
<ul>
<li>char在一些机器上是有符号的，而在另一些机器上无符号，应明确指定它的类型是signed char 或者 unsigned char。</li>
<li>浮点运算选double</li>
</ul>
<a id="more"></a>
<h4 id="212-类型转换"><a class="markdownIt-Anchor" href="#212-类型转换"></a> 2.1.2 类型转换</h4>
<ul>
<li>含有无符号类型的表达式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> 带符号数会转换为无符号数</span><br><span class="line">    <span class="keyword">unsigned</span> u = <span class="number">10</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">-42</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u + i &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>; <span class="comment">// int32位，输出4294967264</span></span><br><span class="line"><span class="number">2.</span> 无符号减无符号确保结果不为负</span><br><span class="line">    <span class="keyword">unsigned</span> u1 = <span class="number">42</span>, u2 = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; u2 - u1 &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;	<span class="comment">// 结果是取模后的值</span></span><br></pre></td></tr></table></figure>
<h4 id="213-字面值常量"><a class="markdownIt-Anchor" href="#213-字面值常量"></a> 2.1.3 字面值常量</h4>
<ul>
<li>
<p>024	/* 八进制 */</p>
</li>
<li>
<p>0x14 /* 十六进制 */</p>
</li>
<li>
<p>八进制只有前3个数字与\构成转义序列</p>
</li>
<li>
<p>\x要用到后面跟着的所有数字</p>
</li>
</ul>
<h3 id="22-变量"><a class="markdownIt-Anchor" href="#22-变量"></a> 2.2 变量</h3>
<h4 id="221-变量定义"><a class="markdownIt-Anchor" href="#221-变量定义"></a> 2.2.1 变量定义</h4>
<ul>
<li>
<p>对象是指一块能存储数据并拥有某种类型的内存空间。</p>
</li>
<li>
<p>**初始化不是赋值，**初始化的含义是创建变量时赋予其一个初始值，而赋值的含义是把对象的当前值擦除，而已一个新值来替代</p>
</li>
<li>
<p>列表初始化</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> units_sold = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> unit_sold = &#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> units_sold&#123;<span class="number">0</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">units_sold</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h4 id="222-变量生命与定义"><a class="markdownIt-Anchor" href="#222-变量生命与定义"></a> 2.2.2 变量生命与定义</h4>
<ul>
<li>变量只能被定义一次，但可以被多次声明</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i;	<span class="comment">// 声明而非定义</span></span><br><span class="line"><span class="keyword">int</span> j;			<span class="comment">// 声明 + 定义</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> i=<span class="number">1</span>	<span class="comment">// 定义</span></span><br></pre></td></tr></table></figure>
<h4 id="223-标识符"><a class="markdownIt-Anchor" href="#223-标识符"></a> 2.2.3 标识符</h4>
<ol>
<li>命名规范</li>
</ol>
<ul>
<li>不能连续出现两个下划线</li>
<li>不能以下划线紧连大写字母</li>
<li>变量名一般用小写字母</li>
<li>用户自定义的类名一般以大写字母开头</li>
</ul>
<h4 id="224-作用域"><a class="markdownIt-Anchor" href="#224-作用域"></a> 2.2.4 作用域</h4>
<h3 id="23-复合类型"><a class="markdownIt-Anchor" href="#23-复合类型"></a> 2.3 复合类型</h3>
<h4 id="231-引用"><a class="markdownIt-Anchor" href="#231-引用"></a> 2.3.1 引用</h4>
<ul>
<li>引用即别名，必须被初始化</li>
<li>只能绑定在对象上</li>
<li>不能二次引用</li>
</ul>
<h4 id="232-指针"><a class="markdownIt-Anchor" href="#232-指针"></a> 2.3.2 指针</h4>
<ul>
<li>
<p>指针是一个对象</p>
</li>
<li>
<p>赋值永远改变的是等号左侧的对象</p>
</li>
</ul>
<h4 id="233-复合类型的声明"><a class="markdownIt-Anchor" href="#233-复合类型的声明"></a> 2.3.3 复合类型的声明</h4>
<ol>
<li>
<p>对指针的引用</p>
<p>从右向左阅读，离变量名最近的符号是&amp;，所以是引用</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *&amp;r = p;	<span class="comment">// r 是一个对指针p的引用</span></span><br></pre></td></tr></table></figure>
<h3 id="24-const"><a class="markdownIt-Anchor" href="#24-const"></a> 2.4 const</h3>
<ol>
<li>全局const</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">file.c</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> c = fun();</span><br><span class="line">file.h</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> <span class="keyword">int</span> c;</span><br></pre></td></tr></table></figure>
<h4 id="241-const-的引用"><a class="markdownIt-Anchor" href="#241-const-的引用"></a> 2.4.1 const 的引用</h4>
<p>​	也称常量引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> ci = <span class="number">1024</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;c = ci;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>初始化常量引用</p>
<p>允许用任意表达式作为初始值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r1 = i;		<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r2 = <span class="number">42</span>;		<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> &amp;r3 = r1 * <span class="number">2</span>;	<span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">int</span> &amp;r4 = r1 * <span class="number">2</span>; 		<span class="comment">// 错误, r4是非常量引用</span></span><br></pre></td></tr></table></figure>
<h4 id="242-指针和const"><a class="markdownIt-Anchor" href="#242-指针和const"></a> 2.4.2 指针和const</h4>
<ol>
<li>
<p>指向常量的指针</p>
<p>不能通过指针改变对象的值</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> dval = <span class="number">3.14</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">double</span> *cptr = &amp;dval;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>常量指针</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> *<span class="keyword">const</span> curNum = &amp;num;	<span class="comment">// curNum将一直指向num</span></span><br></pre></td></tr></table></figure>
<h4 id="243-顶层const"><a class="markdownIt-Anchor" href="#243-顶层const"></a> 2.4.3 顶层const</h4>
<p>​		顶层表示指针本身是个常量，底层表示指针所指的对象是一个常量。</p>
<h4 id="244-constexpr"><a class="markdownIt-Anchor" href="#244-constexpr"></a> 2.4.4 constexpr</h4>
<ol>
<li>常量表达式是指值不会改变并且在编译过程就能得到计算结果的表达式。</li>
</ol>
<ul>
<li>声明为constexpr的变量一定是一个常量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> mf = <span class="number">20</span>;			<span class="comment">// 20是常量表达式</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>指针和constexpr</p>
<p>​	constexpr仅对指针有效，与指针所指的对象无关</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *p = <span class="literal">nullptr</span>;		<span class="comment">// p是一个指向整型常量的指针</span></span><br><span class="line"><span class="keyword">constexpr</span> <span class="keyword">int</span> *q = <span class="literal">nullptr</span>;	<span class="comment">// q是一个指向整数的常量指针</span></span><br></pre></td></tr></table></figure>
<h3 id="25-处理类型"><a class="markdownIt-Anchor" href="#25-处理类型"></a> 2.5 处理类型</h3>
<h4 id="251-类型别名"><a class="markdownIt-Anchor" href="#251-类型别名"></a> 2.5.1 类型别名</h4>
<ol>
<li>typedef</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">double</span> wages;		<span class="comment">// wages是double的同义词</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>using</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> wages = <span class="keyword">double</span>;</span><br></pre></td></tr></table></figure>
<p>​	误区</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> *pstring;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* cstr = <span class="number">0</span> 和 <span class="keyword">const</span> pstring cstr = <span class="number">0</span> 不一样</span><br></pre></td></tr></table></figure>
<p>​	前者是指向const char的指针，后者pstring是一个指向char的指针，const pstring是一个指向char的常量指针。</p>
<h4 id="252-auto类型说明符"><a class="markdownIt-Anchor" href="#252-auto类型说明符"></a> 2.5.2 auto类型说明符</h4>
<ul>
<li>
<p>auto通过初始值来推算变量的类型。</p>
</li>
<li>
<p>一条声明语句只能有一个基本数据类型。</p>
</li>
<li>
<p>auto会忽略掉顶层const, 保留底层const</p>
</li>
<li>
<p>保留顶层const需明确指出: const auto f = ci</p>
</li>
</ul>
<h4 id="253-decltype类型说明符"><a class="markdownIt-Anchor" href="#253-decltype类型说明符"></a> 2.5.3 decltype类型说明符</h4>
<ul>
<li>选择并返回操作数的数据类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(f()) sum = x;		<span class="comment">// sum的类型就是函数f的返回类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>如果decltype使用的表达式是一个变量，则返回该变量的类型</li>
<li>如果decltype使用的表达式不是一个变量，则返回表达式结果对应类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">42</span>, *p = &amp;i, &amp;r = i;</span><br><span class="line"><span class="keyword">decltype</span>(r) a;				<span class="comment">// a是int&amp;</span></span><br><span class="line"><span class="keyword">decltype</span>(r + <span class="number">0</span>) b;			<span class="comment">// b是int	</span></span><br><span class="line"><span class="keyword">decltype</span>(*p) c = i;			<span class="comment">// c是int&amp;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>decltype不加括号，结果是该变量的类型，<strong>加上括号，得到引用类型</strong></li>
</ul>
<h3 id="26-自定义数据结构"><a class="markdownIt-Anchor" href="#26-自定义数据结构"></a> 2.6 自定义数据结构</h3>
<h4 id="261-struct"><a class="markdownIt-Anchor" href="#261-struct"></a> 2.6.1 Struct</h4>
<h4 id="263-编写自己的头文件"><a class="markdownIt-Anchor" href="#263-编写自己的头文件"></a> 2.6.3 编写自己的头文件</h4>
<ol>
<li>头文件保护符</li>
</ol>
<ul>
<li>#ifdef当且仅当变量已定义时为真</li>
<li>#ifndef当且仅当变量未定义时为真</li>
<li>#endif为结束</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SALES_DATA_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> bookNo;</span><br><span class="line">    <span class="keyword">unsigned</span> units_sold = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> revenue = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 字符串、向量和数组</title>
    <url>/2020/09/04/C++/Chapter%203%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E3%80%81%E5%90%91%E9%87%8F%E5%92%8C%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-字符串-向量和数组"><a class="markdownIt-Anchor" href="#第三章-字符串-向量和数组"></a> 第三章 字符串、向量和数组</h2>
<h3 id="31-命名空间的using声明"><a class="markdownIt-Anchor" href="#31-命名空间的using声明"></a> 3.1 命名空间的using声明</h3>
<h3 id="32-string"><a class="markdownIt-Anchor" href="#32-string"></a> 3.2 string</h3>
<h4 id="321-四种初始化方式"><a class="markdownIt-Anchor" href="#321-四种初始化方式"></a> 3.2.1 四种初始化方式</h4>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s1;				<span class="comment">// s1是空串</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s2</span><span class="params">(s1)</span></span>;			<span class="comment">// s2是s1的副本</span></span><br><span class="line"><span class="built_in">string</span> s2 = s1;			<span class="comment">// 等价于s2(s1)</span></span><br><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s3</span><span class="params">(n, <span class="string">'c'</span>)</span></span>;		<span class="comment">// 把s3初始化为由连续n个字符c组成的串</span></span><br></pre></td></tr></table></figure>
<h4 id="322-string对象上的操作"><a class="markdownIt-Anchor" href="#322-string对象上的操作"></a> 3.2.2 string对象上的操作</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">os&lt;&lt;s;				<span class="comment">// 将s写到os中，返回os</span></span><br><span class="line">is&gt;&gt;s;				<span class="comment">// 从is中读取字符串给s，返回is</span></span><br><span class="line">getline(is, s);		<span class="comment">// 从is中读取一行给s，返回is</span></span><br><span class="line">s.empty();			<span class="comment">// s为空返回true</span></span><br><span class="line">s.<span class="built_in">size</span>();			<span class="comment">// 返回s中字符的个数</span></span><br><span class="line">s[n];				<span class="comment">// 返回s中第n个字符的引用</span></span><br><span class="line">s1 + s2;			<span class="comment">// 返回s1和s2连接后的结果</span></span><br><span class="line">s1 = s2;			<span class="comment">// 用s2的副本代替s1中原来的字符</span></span><br><span class="line">s1 == s2;			<span class="comment">// 如果s1和s2中所含的字符完全一样，则相等</span></span><br><span class="line">s1 != s2;			</span><br><span class="line">&lt;. &lt;=, &gt;, &gt;=;</span><br></pre></td></tr></table></figure>
<h4 id="323-getline"><a class="markdownIt-Anchor" href="#323-getline"></a> 3.2.3 getline</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">getline(<span class="built_in">cin</span>, <span class="built_in">line</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">line</span> &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="324-字面值和string对象相加"><a class="markdownIt-Anchor" href="#324-字面值和string对象相加"></a> 3.2.4 字面值和string对象相加</h4>
<ul>
<li>
<p>string与字符串字面值相加必须保证至少有一个运算对象是string</p>
</li>
<li>
<p>字符串字面值与string是不同类型</p>
</li>
</ul>
<h4 id="325-string对象中的字符"><a class="markdownIt-Anchor" href="#325-string对象中的字符"></a> 3.2.5 string对象中的字符</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">isalnum</span>(c);		<span class="comment">// 字母和数字</span></span><br><span class="line"><span class="built_in">isalpha</span>(c);		<span class="comment">// 字母</span></span><br><span class="line"><span class="built_in">iscntrl</span>(c);		<span class="comment">// 控制字符</span></span><br><span class="line"><span class="built_in">isdigit</span>(c);		<span class="comment">// 数字</span></span><br><span class="line"><span class="built_in">isgraph</span>(c);		<span class="comment">// 不是空格但可打印</span></span><br><span class="line"><span class="built_in">islower</span>(c);		<span class="comment">// 小写字母</span></span><br><span class="line"><span class="built_in">isprint</span>(c);		<span class="comment">// 可打印字符</span></span><br><span class="line"><span class="built_in">ispunct</span>(c);		<span class="comment">// 标调符号</span></span><br><span class="line"><span class="built_in">isspace</span>(c);		<span class="comment">// 空白(空格、横向制表符、回车、换行等)</span></span><br><span class="line"><span class="built_in">isupper</span>(c);		<span class="comment">// 大写字母</span></span><br><span class="line"><span class="built_in">isxdigit</span>(c);	<span class="comment">// 十六进制数字</span></span><br><span class="line"><span class="built_in">tolower</span>(c);		<span class="comment">// 输出小写字母</span></span><br><span class="line"><span class="built_in">toupper</span>(c);		<span class="comment">// 输出大写字母</span></span><br></pre></td></tr></table></figure>
<h4 id="326-范围for语句"><a class="markdownIt-Anchor" href="#326-范围for语句"></a> 3.2.6 范围for语句</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(declaration: expression)</span><br><span class="line">    statement</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>遍历</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">str</span><span class="params">(<span class="string">"some string"</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> c: str)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; c &lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line"><span class="number">2.</span>赋值</span><br><span class="line">    <span class="comment">// 必须把循环变量定义成引用类型</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;c: str)</span><br><span class="line">        c = <span class="built_in">toupper</span>(c);</span><br></pre></td></tr></table></figure>
<h3 id="33-vector"><a class="markdownIt-Anchor" href="#33-vector"></a> 3.3 vector</h3>
<h4 id="331-vector初始化"><a class="markdownIt-Anchor" href="#331-vector初始化"></a> 3.3.1 vector初始化</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1;						<span class="comment">// 空vector				</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v2</span><span class="params">(v1)</span></span>;	</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = v1;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v3</span><span class="params">(n, val)</span></span>;				<span class="comment">// n个val</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">v4</span><span class="params">(n)</span></span>;					<span class="comment">// n个初始化元素</span></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v4&#123;n&#125;;					<span class="comment">// 1个n</span></span><br></pre></td></tr></table></figure>
<ul>
<li>()用来描述容量,{}用来赋值</li>
</ul>
<h4 id="332-添加元素"><a class="markdownIt-Anchor" href="#332-添加元素"></a> 3.3.2 添加元素</h4>
<ul>
<li>push_back</li>
</ul>
<h3 id="34-迭代器"><a class="markdownIt-Anchor" href="#34-迭代器"></a> 3.4 迭代器</h3>
<h4 id="341-begin和end"><a class="markdownIt-Anchor" href="#341-begin和end"></a> 3.4.1 begin和end</h4>
<ul>
<li>cbegin和cend返回const_iterator</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> it = v.cbegin();		<span class="comment">// it的类型是vector&lt;int&gt;::const_iterator</span></span><br></pre></td></tr></table></figure>
<h4 id="342-迭代器运算"><a class="markdownIt-Anchor" href="#342-迭代器运算"></a> 3.4.2 迭代器运算</h4>
<ul>
<li>the <strong>+</strong> operator between two iterators is illegal.</li>
</ul>
<h3 id="35-数组"><a class="markdownIt-Anchor" href="#35-数组"></a> 3.5 数组</h3>
<h4 id="351-数组初始化"><a class="markdownIt-Anchor" href="#351-数组初始化"></a> 3.5.1 数组初始化</h4>
<ul>
<li>
<p>维度必须是一个常量表达式</p>
</li>
<li>
<p>不能用auto</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptrs[<span class="number">10</span>];				<span class="comment">// ptrs是含有10个整形指针的数组</span></span><br><span class="line"><span class="keyword">int</span> (*Parray)[<span class="number">10</span>] = &amp;arr;	<span class="comment">// Parray指向一个含有10个整数的数组</span></span><br><span class="line"><span class="keyword">int</span> (&amp;arrRef)[<span class="number">10</span>] = arr;	<span class="comment">// arrRef引用一个含有10个整数的数组</span></span><br></pre></td></tr></table></figure>
<h4 id="352-访问数组元素"><a class="markdownIt-Anchor" href="#352-访问数组元素"></a> 3.5.2 访问数组元素</h4>
<h4 id="353-指针和数组"><a class="markdownIt-Anchor" href="#353-指针和数组"></a> 3.5.3 指针和数组</h4>
<ol>
<li>begin和end</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> *beg = <span class="built_in">begin</span>(ia);</span><br><span class="line"><span class="keyword">int</span> *<span class="built_in">end</span> = <span class="built_in">end</span>(ia);</span><br></pre></td></tr></table></figure>
<h4 id="354-c风格字符串"><a class="markdownIt-Anchor" href="#354-c风格字符串"></a> 3.5.4 C风格字符串</h4>
<ul>
<li>头文件cstring</li>
</ul>
<h4 id="355-与旧代码的接口"><a class="markdownIt-Anchor" href="#355-与旧代码的接口"></a> 3.5.5 与旧代码的接口</h4>
<ol>
<li>c_str</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *str = s.c_str();		<span class="comment">// 返回一个C风格的字符串</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>使用数组初始化vector对象</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="built_in">begin</span>(arr), <span class="built_in">end</span>(arr))</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="36-多维数组"><a class="markdownIt-Anchor" href="#36-多维数组"></a> 3.6 多维数组</h3>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">constexpr</span> row = <span class="number">3</span>, col = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">int</span> ia[row][col] = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">const</span> <span class="keyword">auto</span> &amp;row: ia)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> col: row)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; col &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> ia[<span class="number">3</span>][<span class="number">4</span>];</span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">4</span>] = ia;	<span class="comment">// *p是一个含有4个整数的数组</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> p = <span class="built_in">begin</span>(ia); p != <span class="built_in">end</span>(ia); ++p) &#123;</span><br><span class="line">    <span class="comment">// q指向内层数组的首元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> q = <span class="built_in">begin</span>(*p); q != <span class="built_in">end</span>(*p); ++q)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *q &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 表达式</title>
    <url>/2020/09/04/C++/Chapter%204%20%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第四章-表达式"><a class="markdownIt-Anchor" href="#第四章-表达式"></a> 第四章 表达式</h2>
<h3 id="41-基础"><a class="markdownIt-Anchor" href="#41-基础"></a> 4.1 基础</h3>
<h4 id="411-左值和右值"><a class="markdownIt-Anchor" href="#411-左值和右值"></a> 4.1.1 左值和右值</h4>
<ul>
<li>当一个对象被用作右值的时候，用的是对象的值；当对象被用作左值的时候，用的是对象的身份。</li>
</ul>
<a id="more"></a>
<ul>
<li>
<p>decltype</p>
<p>​	如果表达式的求值结果是左值，得到一个引用类型</p>
</li>
</ul>
<h4 id="412-优先级与结合律"><a class="markdownIt-Anchor" href="#412-优先级与结合律"></a> 4.1.2 优先级与结合律</h4>
<h4 id="413-求值顺序"><a class="markdownIt-Anchor" href="#413-求值顺序"></a> 4.1.3 求值顺序</h4>
<h3 id="42-算术运算符"><a class="markdownIt-Anchor" href="#42-算术运算符"></a> 4.2 算术运算符</h3>
<h3 id="43-逻辑和关系运算符"><a class="markdownIt-Anchor" href="#43-逻辑和关系运算符"></a> 4.3 逻辑和关系运算符</h3>
<h3 id="44-赋值运算符"><a class="markdownIt-Anchor" href="#44-赋值运算符"></a> 4.4 赋值运算符</h3>
<h3 id="45-递增和递减运算符"><a class="markdownIt-Anchor" href="#45-递增和递减运算符"></a> 4.5 递增和递减运算符</h3>
<h3 id="46-成员访问运算符"><a class="markdownIt-Anchor" href="#46-成员访问运算符"></a> 4.6 成员访问运算符</h3>
<ul>
<li>—&gt;作用于一个指针类型的运算对象，结果是左值</li>
<li>点运算符作用于左值结果是左值，作用于右值结果是右值</li>
</ul>
<h3 id="47-条件运算符"><a class="markdownIt-Anchor" href="#47-条件运算符"></a> 4.7 条件运算符</h3>
<ul>
<li>右结合律</li>
</ul>
<h3 id="48-位结合律"><a class="markdownIt-Anchor" href="#48-位结合律"></a> 4.8 位结合律</h3>
<h3 id="49-sizeof运算符"><a class="markdownIt-Anchor" href="#49-sizeof运算符"></a> 4.9 sizeof运算符</h3>
<ul>
<li>
<p>右结合律</p>
</li>
<li>
<p>返回size_t类型的常量表达式</p>
</li>
</ul>
<h3 id="410-逗号运算符"><a class="markdownIt-Anchor" href="#410-逗号运算符"></a> 4.10 逗号运算符</h3>
<h3 id="411-类型转换"><a class="markdownIt-Anchor" href="#411-类型转换"></a> 4.11 类型转换</h3>
<h4 id="4113-显示转换"><a class="markdownIt-Anchor" href="#4113-显示转换"></a> 4.11.3 显示转换</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">cast-name&lt;type&gt;(expression);</span><br></pre></td></tr></table></figure>
<ul>
<li>cast-name是static_cast、dynamic_cast、const_cast和reinterpret_cast中的一种</li>
</ul>
<ol>
<li>static_cast</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> *p = &amp;d;</span><br><span class="line"><span class="keyword">double</span> *dp = <span class="keyword">static_cast</span>&lt;<span class="keyword">double</span>*&gt;(p);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>const_cast</p>
<p>const_cast只改变运算对象的底层const</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> constant = <span class="number">21</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>* const_p = &amp;constant;</span><br><span class="line"><span class="keyword">int</span>* modifier = <span class="keyword">const_cast</span>&lt;<span class="keyword">int</span>*&gt;(const_p);</span><br><span class="line">*modifier = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>reinterpret_cast</li>
</ol>
<h3 id="412-运算符优先级表"><a class="markdownIt-Anchor" href="#412-运算符优先级表"></a> 4.12 运算符优先级表</h3>
<p><img src="https://i.loli.net/2020/09/04/64jmMvIzWZpxSne.png" alt="image-20200120213610912.png" /></p>
<p><img src="https://i.loli.net/2020/09/04/G2tYarPp4sJ7nM3.png" alt="image-20200120213630510.png" /></p>
<p><img src="https://i.loli.net/2020/09/04/6Gsgm9riHkDlIzB.png" alt="image-20200120213642127.png" /></p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十三章 拷贝控制</title>
    <url>/2020/09/04/C++/Chapter%2013%20%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十三章-拷贝控制"><a class="markdownIt-Anchor" href="#第十三章-拷贝控制"></a> 第十三章 拷贝控制</h2>
<ul>
<li>拷贝构造函数</li>
<li>拷贝赋值运算符</li>
<li>移动构造函数</li>
<li>移动构造运算符</li>
<li>析构函数</li>
</ul>
<a id="more"></a>
<h3 id="131-拷贝-赋值与销毁"><a class="markdownIt-Anchor" href="#131-拷贝-赋值与销毁"></a> 13.1 拷贝、赋值与销毁</h3>
<h4 id="1311-拷贝构造函数"><a class="markdownIt-Anchor" href="#1311-拷贝构造函数"></a> 13.1.1 拷贝构造函数</h4>
<p>​		如果一个构造函数的第一个参数是自身类类型的引用，且任何额外参数都有默认值，则此构造函数是拷贝构造函数。</p>
<ul>
<li>
<p>拷贝初始化</p>
<p>​	当使用直接初始化时，我们实际上是要求编译器使用普通的函数匹配来选择与我们提供的参数最匹配的构造函数。当使用拷贝初始化时，我们要求编译器将右侧运算对象拷贝到正在创建的对象中，如果需要的话进行类型转换。</p>
<ul>
<li>当我们调用insert或push成员时，容器会对其元素进行拷贝初始化。用emplace成员创建的元素都进行直接初始化。</li>
</ul>
</li>
<li>
<p><strong>拷贝构造函数自己的参数必须是引用类型</strong>，不然形参需要拷贝实参，实参又要调用拷贝构造函数</p>
</li>
</ul>
<h4 id="1312-拷贝赋值运算符"><a class="markdownIt-Anchor" href="#1312-拷贝赋值运算符"></a> 13.1.2 拷贝赋值运算符</h4>
<ul>
<li>
<p>重载赋值运算符</p>
<p>​	赋值运算符通常应该返回一个指向其左侧运算对象的引用</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data&amp; Sales_data::<span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    bookNo = rhs.bookNo;</span><br><span class="line">    units_sold = rhs.units_sold;</span><br><span class="line">    revenue = rhs.revenue;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1313-析构函数"><a class="markdownIt-Anchor" href="#1313-析构函数"></a> 13.1.3 析构函数</h4>
<p>​		在一个析构函数中，首先执行函数体，然后销毁成员。成员按初始化顺序的逆序销毁。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">~Sales_data();</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>变量在离开其作用域时被销毁</p>
</li>
<li>
<p>当一个对象被销毁时，其成员被销毁</p>
</li>
<li>
<p>容器被销毁时，其元素被销毁</p>
</li>
<li>
<p>对于动态分配的对象，delete时被销毁</p>
</li>
<li>
<p>对于临时对象，当创建它的完整表达式结束时被销毁</p>
</li>
<li>
<p>成员是在析构函数体之后隐含的析构阶段中被销毁的</p>
</li>
</ul>
<h4 id="1314-三五法则"><a class="markdownIt-Anchor" href="#1314-三五法则"></a> 13.1.4 三/五法则</h4>
<ul>
<li>如果一个类需要一个析构函数，它也需要一个拷贝构造函数和一个拷贝赋值运算符</li>
</ul>
<h4 id="1315-使用default"><a class="markdownIt-Anchor" href="#1315-使用default"></a> 13.1.5 使用=default</h4>
<p>​		我们可以通过将拷贝控制成员定义为=default来显示地要求编译器生成合成的版本</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Sales_data() = <span class="keyword">default</span>;</span><br><span class="line"> 	Sales_data(<span class="keyword">const</span> Sales_data&amp;) = <span class="keyword">default</span>;</span><br><span class="line">    Sales_data&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Sales_data&amp;);</span><br><span class="line">    ~Sales_data() = <span class="keyword">default</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1316-阻止拷贝"><a class="markdownIt-Anchor" href="#1316-阻止拷贝"></a> 13.1.6 阻止拷贝</h4>
<ul>
<li>
<p>定义删除的函数</p>
<p>​	在函数的参数列表后面加上=delete来指除我们虽然声明了它们，但不能以任何方式使用它们。</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NoCopy</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	NoCopy() = <span class="keyword">default</span>;				<span class="comment">// 使用合成的默认构造函数</span></span><br><span class="line">    NoCopy(<span class="keyword">const</span> NoCopy&amp;) = <span class="keyword">delete</span>;				<span class="comment">// 阻止拷贝</span></span><br><span class="line">    NoCopy &amp;<span class="keyword">operator</span>=(<span class="keyword">const</span> NoCopy) = <span class="keyword">delete</span>;	<span class="comment">// 阻止赋值</span></span><br><span class="line">    ~NoCopy() = <span class="keyword">default</span>;			<span class="comment">// 使用合成的析构函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果一个类有数据成员不能默认构造、拷贝、复制或销毁，则对应的成员函数将被定义为删除的。</p>
</li>
<li>
<p>在新标准发布之前，类是通过将其拷贝构造函数和拷贝赋值运算符声明为private来阻止拷贝的</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Employee</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Employee()&#123;&#125;;</span><br><span class="line">    Employee(<span class="keyword">const</span> <span class="built_in">string</span>&amp; name) : _name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        _ID = i++;</span><br><span class="line">    &#125;;</span><br><span class="line">    Employee(<span class="keyword">const</span> Employee&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">    Employee&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Employee&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> _name;</span><br><span class="line">    <span class="keyword">int</span> _ID;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="132-拷贝控制和资源管理"><a class="markdownIt-Anchor" href="#132-拷贝控制和资源管理"></a> 13.2 拷贝控制和资源管理</h3>
<ul>
<li>首先确定类型对象的拷贝语义：定义拷贝操作，使类的行为看起来像一个值或者像一个指针</li>
</ul>
<h4 id="1321-行为像值的类"><a class="markdownIt-Anchor" href="#1321-行为像值的类"></a> 13.2.1 行为像值的类</h4>
<ul>
<li>每个对象都应该拥有一份自己的拷贝。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 通过先拷贝右侧运行对象，可以处理自赋值情况</span></span><br><span class="line"><span class="function">HasPtr&amp; <span class="title">HasPtr::operator</span><span class="params">(<span class="keyword">const</span> HasPtr&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newp = <span class="keyword">new</span> <span class="built_in">string</span>(*rhs.ps);	</span><br><span class="line">    <span class="keyword">delete</span> ps;</span><br><span class="line">    ps = newp;</span><br><span class="line">    i = rhs.i;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>当编写赋值运算符时，需要记住两点:
<ul>
<li><strong>如果将一个对象赋予它自身，赋值运算符必须能正常工作</strong></li>
<li>大多数赋值运算符组合了析构函数和拷贝构造函数的工作</li>
</ul>
</li>
</ul>
<h4 id="1322-定义行为像指针的类"><a class="markdownIt-Anchor" href="#1322-定义行为像指针的类"></a> 13.2.2 定义行为像指针的类</h4>
<ul>
<li>
<p>引用计数</p>
<ul>
<li>每个构造函数要创建一个引用计数，将计数器初始化为1</li>
<li>拷贝构造函数递增共享的计数器</li>
<li>析构函数递减计数器</li>
<li>拷贝赋值运算符递增右侧对象的计数器，递减左侧运算对象的计数器</li>
</ul>
</li>
<li>
<p>定义一个使用引用计数的类</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    HsaPtr(<span class="keyword">const</span> <span class="built_in">string</span>&amp;s = <span class="built_in">string</span>()): ps(<span class="keyword">new</span> <span class="built_in">string</span>(s)), i(<span class="number">0</span>), use(<span class="keyword">new</span> <span class="keyword">size_t</span>(<span class="number">1</span>))&#123;&#125;</span><br><span class="line">    HasPtr(<span class="keyword">const</span> HasPtr &amp;p):</span><br><span class="line">    	ps(p.ps), i(p.i), use(p.use)&#123;++*use;&#125;</span><br><span class="line">    HasPtr&amp; <span class="keyword">operator</span> = (<span class="keyword">const</span> HasPtr&amp;);</span><br><span class="line">    ~HasPtr();</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> *ps;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">size_t</span> *use;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="133-交换操作"><a class="markdownIt-Anchor" href="#133-交换操作"></a> 13.3 交换操作</h3>
<ul>
<li>每个swap调用应该都是未加限定的，即每个调用都应该是swap。如果存在类型特定的swap版本，其匹配程度会优于std中定义的版本。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HasPtr</span> &#123;</span></span><br><span class="line"> 	<span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp;, HasPtr&amp;)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(HasPtr&amp; lhs, HasPtr&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    swap(lhs.ps, rhs.ps);		<span class="comment">// 交换指针，而不是string数据</span></span><br><span class="line">    swap(lhs.i, rhs.i);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="134-拷贝控制示例"><a class="markdownIt-Anchor" href="#134-拷贝控制示例"></a> 13.4 拷贝控制示例</h3>
<p><img src="https://i.loli.net/2020/09/04/n7aKDQuiALtvlHj.png" alt="image-20200829214205850.png" /></p>
<ul>
<li>Message类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Message</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Message&amp;, Message&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(Floder&amp;, Folder&amp;)</span></span>;</span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Floder</span>;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// floders被隐式初始化为空集合</span></span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="title">Message</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; str = <span class="string">" "</span>)</span></span></span><br><span class="line"><span class="function">        <span class="title">contents</span><span class="params">(str)</span> </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// 拷贝控制成员，用来管理指向本Message的指针</span></span><br><span class="line">    Message(<span class="keyword">const</span> Message&amp;);			<span class="comment">// 拷贝构造函数</span></span><br><span class="line">	Message <span class="keyword">operator</span>=(<span class="keyword">const</span> Message&amp;);	<span class="comment">// 拷贝赋值运算符</span></span><br><span class="line">    ~Message();</span><br><span class="line">    <span class="comment">// 从给定Folder集合中添加/删除本Message</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">save</span><span class="params">(&amp;Folder)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove</span><span class="params">(&amp;Folder)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> contents;				<span class="comment">// 实际消息文本</span></span><br><span class="line">    <span class="built_in">set</span>&lt;Folder*&gt; folders;			<span class="comment">// 包含本Message的Folder</span></span><br><span class="line">    <span class="comment">// 拷贝构造函数、拷贝赋值运算符和析构函数所使用的工具函数</span></span><br><span class="line">    <span class="comment">// 将本Message添加到指向参数的Folder中</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp;)</span></span>;</span><br><span class="line">    <span class="comment">// 从folders中的每个Folder中删除本Message</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">remove_from_Folders</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::save</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.insert(&amp;f);	<span class="comment">// 将给定Folder添加到我们的Folder列表中</span></span><br><span class="line">    f.addMsg(<span class="keyword">this</span>);		<span class="comment">// 将本Message添加到f的Message集合中</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove</span><span class="params">(Folder&amp; f)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    folders.erase(&amp;f);	<span class="comment">// 将给定Folder从我们的Floder列表中删除</span></span><br><span class="line">    f.remMsg(<span class="keyword">this</span>);		<span class="comment">// 将本Message从f的Message集合中删除</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::add_to_Folders</span><span class="params">(<span class="keyword">const</span> Message&amp; m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : m.floders)		<span class="comment">// 对每个包含m的Folder</span></span><br><span class="line">        f-&gt;addMsg(<span class="keyword">this</span>);		<span class="comment">// 向该Folder添加一个指向本									   Message的指针</span></span><br><span class="line">&#125;</span><br><span class="line">Message::Message(<span class="keyword">const</span> Message&amp; m) :</span><br><span class="line">	contents(m.contents), folders(m.folders)</span><br><span class="line">&#123;</span><br><span class="line">	add_to_Folders(m);		<span class="comment">// 将本消息添加到指向m的Folder中   </span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Message::remove_from_Folders</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span>(<span class="keyword">auto</span> f : folders)		<span class="comment">// 对folders中每个指针</span></span><br><span class="line">        f-&gt;remMsg(<span class="keyword">this</span>);		<span class="comment">// 从该Folder中删除本Message</span></span><br><span class="line">&#125;</span><br><span class="line">Message::~Message()</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();</span><br><span class="line">&#125;</span><br><span class="line">Message&amp; Message::(<span class="keyword">const</span> Message&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    remove_from_Folders();		<span class="comment">// 更新已有Folder</span></span><br><span class="line">    contents = rhs.contents;	<span class="comment">// 从rhs拷贝消息内容</span></span><br><span class="line">    folders = rhs.folders;		<span class="comment">// 从rhs拷贝Folder指针</span></span><br><span class="line">    add_to_Folders(rhs);		<span class="comment">// 将本Message添加到Folder中</span></span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>Message的swap函数</p>
<p>我们通过两边扫描folders中每个成员来正确处理Folder指针。全部删除——交换——重新添加</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(Message&amp; lhs, Message&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">using</span> <span class="built_in">std</span>::swap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;remMsg(&amp;rhs);</span><br><span class="line">    swap(lhs.contents, rhs.contents);</span><br><span class="line">    swap(lhs.folders, rhs.folders);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : lhs.folders)</span><br><span class="line">        f-&gt;addMsg(&amp;lhs);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> f : rhs.folders)</span><br><span class="line">        f-&gt;addMsg(&amp;rhs);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="135-动态内管理类"><a class="markdownIt-Anchor" href="#135-动态内管理类"></a> 13.5 动态内管理类</h3>
<ul>
<li>类vector类内存分配策略的简化实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    StrVec() : </span><br><span class="line">    	elements(<span class="literal">nullptr</span>), first_free(<span class="literal">nullptr</span>), cap(<span class="literal">nullptr</span>)&#123; &#125;</span><br><span class="line">    StrVec(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    StrVec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp;);</span><br><span class="line">    ~StrVec();</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free - elements; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">size_t</span> <span class="title">capacity</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> cap - elements; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> elements; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">std</span>::<span class="built_in">string</span> *<span class="title">end</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> first_free; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::allocator&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;&gt; alloc;	<span class="comment">// 分配元素</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">chk_n_alloc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">if</span>(<span class="built_in">size</span>() == capacity()) reallocate(); &#125;</span><br><span class="line">    <span class="comment">// 工具函数，被拷贝构造函数、赋值运算符和析构函数所使用</span></span><br><span class="line">    <span class="built_in">std</span>::pair&lt;<span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="built_in">std</span>::<span class="built_in">string</span>*&gt; alloc_n_copy</span><br><span class="line">        (<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>*, <span class="keyword">const</span> <span class="built_in">std</span>:: <span class="built_in">string</span>*);</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">free</span><span class="params">()</span></span>;				<span class="comment">// 销毁元素并释放内存</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">reallocate</span><span class="params">()</span></span>;			<span class="comment">// 获得更多内存并拷贝已有元素</span></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">string</span>* elements;		<span class="comment">// 指向数组首元素的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* first_free;	<span class="comment">// 指向数组第一个空闲元素的指针</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span>* cap;			<span class="comment">// 指向数组尾后位置的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用construct</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::push_back</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    chk_n_alloc();</span><br><span class="line">    alloc.construct(first_free++, s);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">pair&lt;string*, string*&gt; StrVec::alloc_n_copy(const string* b, const string* e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc.allocate(e - b);</span><br><span class="line">    <span class="keyword">return</span> &#123;data, uninitialized_copy(b, e, data) &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::free</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(elements) &#123;</span><br><span class="line">        for_each(elements, first_free,[](<span class="built_in">string</span>&amp; rhs)</span><br><span class="line">                 &#123; alloc.destroy(&amp;rhs); &#125; );</span><br><span class="line">        alloc.deallocate(elements, cap-elements);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec::StrVec(<span class="keyword">const</span> StrVec&amp; s)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 调用alloc_n_copy分配空间以容纳与s中一样多的元素</span></span><br><span class="line">	<span class="keyword">auto</span> newdata = alloc_n_copy(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    elements = newdata.first;</span><br><span class="line">    first_free = cap = newdata.second;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec::~StrVec()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrVec&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> StrVec&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(rhs.<span class="built_in">begin</span>(), rhs.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>reallocate</p>
<ul>
<li>
<p>为一个新的、更大的string数组分配内存</p>
</li>
<li>
<p>在内存空间的前一部分构造对象，保存现有元素</p>
</li>
<li>
<p>销毁原内存空间的元素，并释放这块内存</p>
<p>在reallocate中，我们需要拷贝再销毁string数据，如果我们能</p>
</li>
</ul>
<p>避免分配和释放string的额外开销，会提升StrVec的性能。</p>
</li>
<li>
<p>移动构造函数和std::move</p>
<p>​	当我们使用move时，直接调用std::move而不是move</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分配两倍新内存，StrVec为空则分配容纳一个元素的空间</span></span><br><span class="line">    <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 分配新内存</span></span><br><span class="line">	<span class="keyword">auto</span> newdata = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">// 将数据从旧内存移到新内存</span></span><br><span class="line">    <span class="keyword">auto</span> dest = newdata;		<span class="comment">// 指向新数组中下一空闲位置</span></span><br><span class="line">    <span class="keyword">auto</span> elem = elements;		<span class="comment">// 指向旧数组中下一个元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i != <span class="built_in">size</span>(); ++i)</span><br><span class="line">        alloc.construct(dest++, <span class="built_in">std</span>::<span class="built_in">move</span>(*elem++));</span><br><span class="line">    <span class="built_in">free</span>();						<span class="comment">// 移动完释放旧内存空间</span></span><br><span class="line">    <span class="comment">// 更新我们的数据结构，执行新元素</span></span><br><span class="line">	elements = newdata;</span><br><span class="line">    first_free = dest;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="136-对象移动"><a class="markdownIt-Anchor" href="#136-对象移动"></a> 13.6 对象移动</h3>
<ul>
<li>IO类或unique_ptr这样的类不能被拷贝但可以移动</li>
</ul>
<h4 id="1361-右值引用"><a class="markdownIt-Anchor" href="#1361-右值引用"></a> 13.6.1 右值引用</h4>
<ul>
<li>
<p>右值引用只能绑定到临时对象</p>
</li>
<li>
<p>不能将一个右值引用直接绑定到一个左值上</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp; r = i;						<span class="comment">// 左值引用</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span>&amp; r2 = i * <span class="number">42</span>;			</span><br><span class="line"><span class="keyword">int</span>&amp;&amp; rr2 = i * <span class="number">42</span>;				<span class="comment">// 将rr2绑定到乘法结果上</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>不能将一个右值引用绑定到一个右值引用类型的变量上</p>
</li>
<li>
<p>标准库move函数</p>
<p>我们可以显示地将一个左值转换为对应的右值的引用类型</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span>&amp;&amp; rr3 = <span class="built_in">std</span>::<span class="built_in">move</span>(rr1);</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以销毁一个移后源对象，也可以赋予它新值，但不能使用一个移后源对象的值</li>
</ul>
<h4 id="1362-移动构造函数和移动赋值运算符"><a class="markdownIt-Anchor" href="#1362-移动构造函数和移动赋值运算符"></a> 13.6.2 移动构造函数和移动赋值运算符</h4>
<ul>
<li>任何额外的参数都必须由默认实参</li>
<li>noexcept承诺函数不抛出异常</li>
<li>必须在类头文件的声明和定义中都指定noexcept</li>
<li>移动构造函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec::StrVec(StrVec&amp;&amp; s) <span class="keyword">noexcept</span>	<span class="comment">// 移动操作不应抛出任何异常</span></span><br><span class="line">	<span class="comment">//成员初始化器接管s中的资源</span></span><br><span class="line">    : elements(s.elements), first_free(s.first_free), cap(s.cap)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 令s进入这样的状态——对其运行析构函数是安全的</span></span><br><span class="line">	s.elements = s.first_free = cap = <span class="literal">nullptr</span>;        </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>移动赋值运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(StrVec&amp;&amp; rhs) <span class="keyword">noexcept</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 直接检测自赋值</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">free</span>();</span><br><span class="line">        elements = rhs.elements;</span><br><span class="line">        first_free = rhs.first_free;</span><br><span class="line">        cap = rhs.cap;</span><br><span class="line">        rhs.elements = rhs.first_free = rhs.cap = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>合成的移动操作</p>
<ul>
<li>
<p>只有当一个类没有任何自己版本的拷贝控制成员，且类的每个非static数据成员都可以移动时，编译器才会为它合成移动构造函数或移动赋值运算符</p>
</li>
<li>
<p>有类成员定义了自己的拷贝构造函数且未定义移动构造函数，则被定义为删除的</p>
</li>
<li>
<p>定义了一个移动构造函数或移动赋值运算符的类必须也定义自己的拷贝操作。否则，这些成员默认地被定义为删除的</p>
</li>
</ul>
</li>
<li>
<p>移动右值，拷贝左值</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec v1, v2;</span><br><span class="line">v1 = v2;					<span class="comment">// v2是左值，使用拷贝赋值</span></span><br><span class="line"><span class="function">StrVec <span class="title">getVec</span><span class="params">(istream&amp;)</span></span>;	<span class="comment">// getVec返回一个右值</span></span><br><span class="line">v2 = getVec(<span class="built_in">cin</span>);			<span class="comment">// getVec(cin)是一个右值，移动赋值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>如果没有移动构造函数，右值也被拷贝</p>
</li>
<li>
<p>移动迭代器</p>
<ul>
<li>移动迭代器的解引用运算符生成一个右值引用</li>
<li><strong>可以将移动迭代器传递给uninitialized_copy</strong></li>
<li>make_move_iterator接受一个迭代器参数，返回一个移动迭代器</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StrVec::reallocate</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> newcapacity = <span class="built_in">size</span>() ? <span class="number">2</span> * <span class="built_in">size</span>() : <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">auto</span> first = alloc.allocate(newcapacity);</span><br><span class="line">    <span class="comment">// 移动元素</span></span><br><span class="line">    <span class="keyword">auto</span> last = uninitialized_copy(make_move_iterator(<span class="built_in">begin</span>()), 		make_move_iterator(<span class="built_in">end</span>()), first);</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = first;</span><br><span class="line">    first_free = last;</span><br><span class="line">    cap = elements + newcapacity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1363-右值引用和成员函数"><a class="markdownIt-Anchor" href="#1363-右值引用和成员函数"></a> 13.6.3 右值引用和成员函数</h4>
<ul>
<li>允许移动的成员函数通常由两个版本，一个版本接收一个指向const的左值引用，第二个版本接受一个指向非const得右值引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">const</span> X&amp;)</span></span>;		<span class="comment">// 拷贝：绑定到任意类型得X</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(X&amp;&amp;)</span></span>;			<span class="comment">// 移动：只能绑定到X可修改的右值</span></span><br></pre></td></tr></table></figure>
<ul>
<li>当我们调用函数时，实参类型决定了新元素是拷贝还是移动到容器中</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">string</span> s = <span class="string">" "</span>;</span><br><span class="line">vec.push_back(s);			<span class="comment">// 调用push_back(const string&amp;)</span></span><br><span class="line">vec.push_back(<span class="string">"done"</span>);		<span class="comment">// 调用push_back(string&amp;&amp;)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>引用限定符</p>
<p>​		为了防止向右值赋值(s1 + s2 = &quot;wow&quot;是可以发生的)，我们指出this的左值/右值属性的方式与定义const成员函数相同，即在参数列表后放置一个引用限定符</p>
<ul>
<li><strong>引用限定符可以是&amp;或&amp;&amp;，分别指出this可以指向一个左值或右值</strong></li>
<li>引用限定符只能用于非static成员函数,<strong>且必须同时出现在函数的声明和定义中</strong></li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Foo&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> Foo&amp;) &amp;;	<span class="comment">// 只能向可修改的左值赋值</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>一个函数可以同时用const和引用限定，引用限定符必须跟随在const后</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">Foo <span class="title">someMem</span><span class="params">()</span> <span class="keyword">const</span> &amp;</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>当我们定义两个或两个以上具有相同名字和相同参数列表的成员函数，就必须对所有函数都加上引用限定符，或者所有都不加</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 函数</title>
    <url>/2020/09/04/C++/Chapter%206%20%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-函数"><a class="markdownIt-Anchor" href="#第六章-函数"></a> 第六章 函数</h2>
<h3 id="61-函数基础"><a class="markdownIt-Anchor" href="#61-函数基础"></a> 6.1 函数基础</h3>
<h4 id="611-局部对象"><a class="markdownIt-Anchor" href="#611-局部对象"></a> 6.1.1 局部对象</h4>
<ul>
<li>名字的作用域是程序文本的一部分，名字在其中可见。</li>
<li>对象的生命周期是程序执行过程中该对象存在的一段时间。</li>
</ul>
<a id="more"></a>
<ol>
<li>
<p>自动对象</p>
<p>变量定义本身含有初始值，就用初始值进行初始化</p>
</li>
<li>
<p>局部静态对象</p>
<p>局部作用域全局生命周期</p>
</li>
</ol>
<h3 id="62-参数传递"><a class="markdownIt-Anchor" href="#62-参数传递"></a> 6.2 参数传递</h3>
<ul>
<li>
<p>尽量声明常量引用</p>
</li>
<li>
<p>当使用argv中的实参时，可选的实参从argv[1]开始;argv[0]保存程序的名字</p>
</li>
</ul>
<h4 id="626-含有可变形参的函数"><a class="markdownIt-Anchor" href="#626-含有可变形参的函数"></a> 6.2.6 含有可变形参的函数</h4>
<ol>
<li>initializer_list形参</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">error_msg(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; ls);</span><br><span class="line">error_msg(&#123;<span class="string">"functionX"</span>, <span class="string">"okay"</span>&#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>initializer_list对象中的元素永远是常量值</p>
</li>
<li>
<p>序列放在花括号内</p>
</li>
</ul>
<ol start="2">
<li>省略符形参</li>
</ol>
<h3 id="63-返回类型和return语句"><a class="markdownIt-Anchor" href="#63-返回类型和return语句"></a> 6.3 返回类型和return语句</h3>
<ul>
<li>函数可以返回花括号包围的值的列表</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">process</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s;</span><br><span class="line">    <span class="keyword">return</span> &#123;<span class="string">"functionX"</span>, s&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="633-返回数组指针"><a class="markdownIt-Anchor" href="#633-返回数组指针"></a> 6.3.3 返回数组指针</h4>
<ol>
<li>类型别名</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> arrT[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">using</span> arrT = <span class="keyword">int</span>[<span class="number">10</span>];</span><br><span class="line"><span class="function">arrT* <span class="title">func</span><span class="params">(<span class="keyword">int</span> i)</span></span>;		<span class="comment">// func返回一个指向含有10个整数的数组的指针</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>形参列表在数组维度之前</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func(<span class="keyword">int</span> i))[<span class="number">10</span>];</span><br></pre></td></tr></table></figure>
<p>​	可以按照以下的顺序来逐层理解该声明的含义：</p>
<ul>
<li>func(int i)表示调用func函数时需要一个int类型的实参。</li>
<li>(*func(int i))意味着对我们可以对函数调用的结果执行解引用操作。</li>
<li>(*func(int i))[10]表示解引用func的调用将得到一个大小是10的数组。</li>
<li>int (*func(int i))[10]表示数组中的元素是int类型。</li>
</ul>
<ol start="3">
<li>尾置返回类型</li>
</ol>
<p>在本应该出现返回类型的地方放置一个auto</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">auto func(int i)-&gt;int(*)[10];</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>decltype</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">decltype</span>(odd) *arrPtr(<span class="keyword">int</span> i);</span><br></pre></td></tr></table></figure>
<h3 id="64-函数重载"><a class="markdownIt-Anchor" href="#64-函数重载"></a> 6.4 函数重载</h3>
<ul>
<li>
<p>不允许两个函数形参列表相同返回类型不同</p>
</li>
<li>
<p>顶层const不能重载，底层const可以</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(Account*)</span></span>;		<span class="comment">// 作用于指向Account的指针</span></span><br><span class="line"><span class="function">Record <span class="title">lookup</span><span class="params">(<span class="keyword">const</span> Account*)</span></span>;	<span class="comment">// 作用于指向常量的指针</span></span><br></pre></td></tr></table></figure>
<h3 id="65-特殊用途语言特性"><a class="markdownIt-Anchor" href="#65-特殊用途语言特性"></a> 6.5 特殊用途语言特性</h3>
<h4 id="651-默认实参"><a class="markdownIt-Anchor" href="#651-默认实参"></a> 6.5.1 默认实参</h4>
<ul>
<li>一旦某个形参被赋予了默认值，它后面的所有形参都必须有默认值</li>
</ul>
<h4 id="652-内联函数"><a class="markdownIt-Anchor" href="#652-内联函数"></a> 6.5.2 内联函数</h4>
<ul>
<li>调用时展开</li>
</ul>
<h4 id="653-constexpr函数"><a class="markdownIt-Anchor" href="#653-constexpr函数"></a> 6.5.3 constexpr函数</h4>
<ul>
<li>函数的返回类型及所有形参的类型都得是字面值类型</li>
<li>必须有且只有一条return语句</li>
</ul>
<p><strong>内联函数和constexpr函数定义在头文件中</strong></p>
<h4 id="654-调试帮助"><a class="markdownIt-Anchor" href="#654-调试帮助"></a> 6.5.4 调试帮助</h4>
<ol>
<li>assert</li>
</ol>
<ul>
<li>包含于cassert头文件中，用于检查“不能发生”的条件，为假终止程序的执行</li>
</ul>
<ol start="2">
<li>NDEBUG</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NDEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> NEDBUG</span></span><br><span class="line"><span class="built_in">cerr</span> &lt;&lt; _ _func_ _  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>内置变量</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">_ _func_ _	<span class="comment">// 当前函数名字</span></span><br><span class="line">_ _FILE_ _	<span class="comment">// 文件名 </span></span><br><span class="line">_ _LINE_ _	<span class="comment">// 当前行号</span></span><br><span class="line">_ _TIME_ _	<span class="comment">// 编译时间</span></span><br><span class="line">_ _DATE_ _	<span class="comment">// 编译日期</span></span><br></pre></td></tr></table></figure>
<h3 id="66-函数匹配"><a class="markdownIt-Anchor" href="#66-函数匹配"></a> 6.6 函数匹配</h3>
<ul>
<li>调用重载函数应避免强制类型转换</li>
</ul>
<h3 id="67-函数指针"><a class="markdownIt-Anchor" href="#67-函数指针"></a> 6.7 函数指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> (*pf)(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br></pre></td></tr></table></figure>
<ul>
<li>函数名作为一个值时，该函数自动地转换成指针</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">pf = length;	<span class="comment">// pf指向函数length</span></span><br><span class="line">pf = &amp;length;	<span class="comment">// 等价: 取地址符是可选的</span></span><br></pre></td></tr></table></figure>
<p>​		即使用时无须解引用</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> b1 = pf(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b2 = (*pf)(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);</span><br><span class="line"><span class="keyword">bool</span> b3 = length(<span class="string">"hello"</span>, <span class="string">"goodbye"</span>);	<span class="comment">// 全部等价</span></span><br></pre></td></tr></table></figure>
<ul>
<li>使用重载函数时</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*pf)(<span class="keyword">int</span>) = ff;</span><br></pre></td></tr></table></figure>
<h4 id="671-函数指针形参"><a class="markdownIt-Anchor" href="#671-函数指针形参"></a> 6.7.1 函数指针形参</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Func 和 Func2是指向函数的指针</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">bool</span> <span class="params">(*FuncP)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">decltype</span><span class="params">(length)</span> *FuncP2</span>;</span><br></pre></td></tr></table></figure>
<h4 id="672-返回指向函数的指针"><a class="markdownIt-Anchor" href="#672-返回指向函数的指针"></a> 6.7.2 返回指向函数的指针</h4>
<ul>
<li>编译器不会将函数返回类型转化为指针类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">using</span> PF = <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>);	<span class="comment">// PF是指针类型</span></span><br><span class="line"><span class="function">PF <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> (*f1(<span class="keyword">int</span>))(<span class="keyword">int</span>, <span class="keyword">int</span>);		<span class="comment">// 等价类型</span></span><br></pre></td></tr></table></figure>
<p>​		f1是个函数，返回一个指针；指针指向函数，返回类型是int。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十四章 重载运算与类型转换</title>
    <url>/2020/09/04/C++/Chapter%2014%20%E9%87%8D%E8%BD%BD%E8%BF%90%E7%AE%97%E4%B8%8E%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十四章-重载运算与类型转换"><a class="markdownIt-Anchor" href="#第十四章-重载运算与类型转换"></a> 第十四章 重载运算与类型转换</h2>
<h3 id="141-基本概念"><a class="markdownIt-Anchor" href="#141-基本概念"></a> 14.1 基本概念</h3>
<ul>
<li>如果一个运算符函数是成员函数，则它的第一个运算对象绑定到隐式的this指针上</li>
</ul>
<a id="more"></a>
<ul>
<li>对于一个运算符函数，它或者是类的成员，或者至少含有一个类类型的参数，这一约定意味着当运算符作用域内置类型的运算对象，我们无法改变该运算符的含义</li>
<li>不能被重载的运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">::	.*	.	? :</span><br></pre></td></tr></table></figure>
<ul>
<li>直接调用一个重载的运算符函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个非成员运算符函数的等价调用</span></span><br><span class="line">data1 + data2;					<span class="comment">// 普通的表达式</span></span><br><span class="line"><span class="keyword">operator</span>+(data1, data2);		<span class="comment">// 等价的函数调用</span></span><br><span class="line"><span class="comment">// 成员运算符函数的等价调用</span></span><br><span class="line">data1 += data2;</span><br><span class="line">data1.<span class="keyword">operator</span>+=(data2);</span><br></pre></td></tr></table></figure>
<ul>
<li>通常情况下，不应该重载逗号、取地址、逻辑与和逻辑或运算符</li>
<li><strong>成员函数/非成员函数准则</strong>
<ul>
<li>赋值（=）、下标（[]）、调用（()）、和成员访问箭头（-&gt;）必须是成员</li>
<li>复合赋值运算符一般来说应该是成员</li>
<li>改变对象状态的运算符或者与给定类型密切相关的运算符，如递增、递减和解引用运算符，通常应该是成员</li>
<li>具有对称性的运算符可能转换任意一端的运算对象，例如算数、相等性、关系和位运算符等，通常应该是普通的非成员函数</li>
</ul>
</li>
</ul>
<h3 id="142-输入和输出运算符"><a class="markdownIt-Anchor" href="#142-输入和输出运算符"></a> 14.2 输入和输出运算符</h3>
<h4 id="1421-重载输出运算符"><a class="markdownIt-Anchor" href="#1421-重载输出运算符"></a> 14.2.1 重载输出运算符&lt;&lt;</h4>
<ul>
<li>
<p>输出运算符不应该打印换行符</p>
</li>
<li>
<p>输入输出运算符必须是非成员函数</p>
</li>
</ul>
<h4 id="1422-重载输入运算符"><a class="markdownIt-Anchor" href="#1422-重载输入运算符"></a> 14.2.2 重载输入运算符&gt;&gt;</h4>
<ul>
<li>
<p>输入运算符必须处理输入可能失败的情况，而输出运算符不需要</p>
</li>
<li>
<p>当流含有错误类型的数据时读取操作可能失败</p>
</li>
<li>
<p>当读取操作到达文件末尾或遇到输入流的其他错误时也会失败</p>
</li>
</ul>
<h3 id="143-算术和关系运算符"><a class="markdownIt-Anchor" href="#143-算术和关系运算符"></a> 14.3 算术和关系运算符</h3>
<ul>
<li>最有效的方式是使用复合赋值来定义算术运算符</li>
</ul>
<h4 id="1431-相等运算符"><a class="markdownIt-Anchor" href="#1431-相等运算符"></a> 14.3.1 相等运算符</h4>
<ul>
<li>相等运算符和不相等运算符中的一个应该把工作委托给另外一个</li>
</ul>
<h4 id="1432-关系运算符"><a class="markdownIt-Anchor" href="#1432-关系运算符"></a> 14.3.2 关系运算符</h4>
<ul>
<li>如果存在唯一一种逻辑可靠的&lt;定义，则应该考虑为这个类定义&lt;运算符。如果类同时还包含==，则当且仅当&lt;的定义和==产生的结果一致时才定义&lt;运算符。</li>
</ul>
<h3 id="144-赋值运算符"><a class="markdownIt-Anchor" href="#144-赋值运算符"></a> 14.4 赋值运算符</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrVec&amp; StrVec::<span class="keyword">operator</span>=(<span class="built_in">initializer_list</span>&lt;<span class="built_in">string</span>&gt; il)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">auto</span> data = alloc_n_copy(il.<span class="built_in">begin</span>(), il.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">free</span>();</span><br><span class="line">    elements = data.first;</span><br><span class="line">    first_free = cap = data.second;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="145-下标运算符"><a class="markdownIt-Anchor" href="#145-下标运算符"></a> 14.5 下标运算符</h3>
<ul>
<li>如果一个类包含下标运算符，则它通常会定义两个版本：一个返回普通引用，另一个是类的常量成员并且返回常量引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrVec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="built_in">std</span>::<span class="keyword">size_t</span> n)</span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="keyword">operator</span>[](<span class="keyword">size_t</span> n) <span class="keyword">const</span> </span><br><span class="line">    &#123; <span class="keyword">return</span> elements[n]; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> *elements;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="146-递增和递减运算符"><a class="markdownIt-Anchor" href="#146-递增和递减运算符"></a> 14.6 递增和递减运算符</h3>
<ul>
<li>定义递增和递减运算符的类应该同时定义前置版本和后置版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>++()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果curr已经指向了容器的尾后位置，则无法递增它</span></span><br><span class="line">    check(curr, <span class="string">"increment past end of StrBlobPtr"</span>);</span><br><span class="line">    ++curr;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr&amp; StrBlobPtr::<span class="keyword">operator</span>--()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 如果curr是0，则继续递减它将产生一个无效下标</span></span><br><span class="line">    --curr;</span><br><span class="line">    check(curr, <span class="string">"decrement past begin of StrBlobPtr"</span>);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>后置版本接受一个额外的（不被使用）int类型的形参</li>
<li>后置运算符返回对象的原值而非引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>++(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无需检查有效性，调用前置递增运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    ++*<span class="keyword">this</span>;				<span class="comment">// 前置++需要检查递增的有效性</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">StrBlobPtr StrBlobPtr::<span class="keyword">operator</span>--(<span class="keyword">int</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 此处无需检查有效性，调用前置递减运算时才需要检查</span></span><br><span class="line">    StrBlobPtr ret = *<span class="keyword">this</span>;</span><br><span class="line">    --*<span class="keyword">this</span>;				<span class="comment">// 前置--需要检查递增的有效性</span></span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>显式地调用后置运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">StrBlobPtr <span class="title">p</span><span class="params">(a1)</span></span>;</span><br><span class="line">p.<span class="keyword">operator</span>++(<span class="number">0</span>);			<span class="comment">// 调用后置版本的operator++</span></span><br><span class="line">p.<span class="keyword">operator</span>++();				<span class="comment">// 调用前置版本的operator++</span></span><br></pre></td></tr></table></figure>
<h3 id="147-成员访问运算符"><a class="markdownIt-Anchor" href="#147-成员访问运算符"></a> 14.7 成员访问运算符</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StrBlobPtr</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">string</span>&amp; <span class="keyword">operator</span>*() <span class="keyword">const</span> </span><br><span class="line">    &#123; <span class="keyword">auto</span> p = check(curr, <span class="string">"dereference past end"</span>);</span><br><span class="line">    <span class="keyword">return</span> (*p)[curr];			<span class="comment">// (*p)是对象所指的vector</span></span><br><span class="line">   	&#125;</span><br><span class="line">    <span class="built_in">string</span>* <span class="keyword">operator</span>-&gt;() <span class="keyword">const</span></span><br><span class="line">    &#123; <span class="keyword">return</span>&amp; <span class="keyword">this</span>-&gt;<span class="keyword">operator</span>*(); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于point-&gt;member
<ol>
<li>如果point是指针，则我们应用内置的箭头运算符，表达式等价于(*point).member</li>
<li>如果point是定义了operator-&gt;的类的一个对象，则我们使用point.operator-&gt;()的结果来获取member。如果该结果是一个指针，则执行第一步，如果该结果本身含有重载的operator-&gt;()，则重复调用当前步骤</li>
</ol>
</li>
</ul>
<h3 id="148-函数调用运算符"><a class="markdownIt-Anchor" href="#148-函数调用运算符"></a> 14.8 函数调用运算符</h3>
<ul>
<li>函数调用运算符必须是成员函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">absInt</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(<span class="keyword">int</span> val)</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> val &lt; <span class="number">0</span> ? -val : val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">absInt absObj;				<span class="comment">// 含有函数调用运算符的对象</span></span><br><span class="line"><span class="keyword">int</span> ui = absObj(<span class="number">42</span>);		<span class="comment">// 将i传递给absObj.operator()</span></span><br></pre></td></tr></table></figure>
<ul>
<li>含有状态的函数对象类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintString</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PrintString(ostream&amp; o = <span class="built_in">cout</span>, <span class="keyword">char</span> c = <span class="string">' '</span>) :</span><br><span class="line">        os(o), sep(c) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; os &lt;&lt; s &lt;&lt; sep; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ostream&amp; os;</span><br><span class="line">    <span class="keyword">char</span> sep;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>函数对象常常作为泛型算法的实参</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">for_each(vs,<span class="built_in">begin</span>(), vs.<span class="built_in">end</span>(), PrintString(<span class="built_in">cerr</span>, <span class="string">'\n'</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="keyword">int</span> elem)</span> </span>&#123; <span class="keyword">return</span> value == elem; &#125;</span><br><span class="line">replace_if(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), Compare(<span class="number">3</span>), <span class="number">5</span>);</span><br></pre></td></tr></table></figure>
<h4 id="1481-lambda是函数对象"><a class="markdownIt-Anchor" href="#1481-lambda是函数对象"></a> 14.8.1 lambda是函数对象</h4>
<ul>
<li>
<p><strong>当一个lambda表达式通过引用捕获变量时</strong>，将由程序负责确保lambda执行时引用所引的对象确实存在，<strong>编译器可以直接使用该引用而无须在lambda产生的类中将其存储为数据成员</strong></p>
</li>
<li>
<p><strong>通过值捕获的变量被拷贝到lambda中，产生的类必须为每个值捕获的变量建立对应的数据成员，同时创建构造函数，使用捕获的变量的值来初始化数据成员</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), </span><br><span class="line">                 [sz](<span class="keyword">const</span> <span class="built_in">string</span>&amp; a)</span><br><span class="line">                  &#123; <span class="keyword">return</span> a.<span class="built_in">size</span>() &gt;= sz; &#125;);</span><br></pre></td></tr></table></figure>
<ul>
<li>该lambda产生的类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SizeComp(<span class="keyword">size_t</span> n) : sz(n) &#123; &#125;	<span class="comment">// 该形参对应捕获的变量</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() &gt;= sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz;				<span class="comment">// 该数据成员对应通过值捕获的变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">auto</span> wc = find_if(words.<span class="built_in">begin</span>(), words.<span class="built_in">end</span>(), SizeComp(sz));</span><br></pre></td></tr></table></figure>
<ul>
<li>**lambda表达式产生的类不含默认构造函数、赋值运算符及析构函数；**它是否含有默认的拷贝/移动构造函数则通常要视捕获的数据成员类型而定</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SizeComp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SizeComp(<span class="keyword">const</span> <span class="keyword">size_t</span> n) : sz(n) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> s.<span class="built_in">size</span>() == sz; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> sz;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1482-标准库定义的函数对象"><a class="markdownIt-Anchor" href="#1482-标准库定义的函数对象"></a> 14.8.2 标准库定义的函数对象</h4>
<p><img src="https://i.loli.net/2020/09/04/woXf46DAp1BRmk3.png" alt="image-20200831143609829.png" /></p>
<ul>
<li>在算法中使用标准库函数对象</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sort(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(), greater&lt;<span class="built_in">string</span>&gt;());</span><br><span class="line">count_if(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), bind(greater&lt;<span class="keyword">int</span>&gt;(), _1, <span class="number">1024</span>));</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>我们不能直接比较两个无关指针，但是可以使用标准库函数对象来实现该目的</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>*&gt; nameTable;</span><br><span class="line"><span class="comment">// 错误：nameTble中的指针彼此之间没有关系，&lt;将产生未定义的行为</span></span><br><span class="line">sort(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), []	</span><br><span class="line">     (<span class="built_in">string</span>* a, <span class="built_in">string</span>* b) &#123; <span class="keyword">return</span> a &lt; b; &#125;);</span><br><span class="line"><span class="comment">//正确：标准库规定指针的less是定义良好的</span></span><br><span class="line">sort(nameTable.<span class="built_in">begin</span>(), nameTable.<span class="built_in">end</span>(), less&lt;<span class="built_in">string</span>*&gt;());</span><br></pre></td></tr></table></figure>
<h4 id="1483-可调用对象与function"><a class="markdownIt-Anchor" href="#1483-可调用对象与function"></a> 14.8.3 可调用对象与function</h4>
<ul>
<li>不同类型可能具有相同的调用形式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="keyword">auto</span> mod = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i % j; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">divide</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> denominator, <span class="keyword">int</span> divisor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> divisor / denominator;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们可以构建从运算符到函数指针的映射关系</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, <span class="keyword">int</span>(*)(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; binops;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;);	 	<span class="comment">// 正确：add是一个函数指针</span></span><br><span class="line">binops.insert(&#123;<span class="string">"%"</span>, mod&#125;);		<span class="comment">// 错误：mod不是一个函数指针</span></span><br></pre></td></tr></table></figure>
<ul>
<li>标准库function类型</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;T&gt; f;		<span class="comment">// f是一个用来存储可调用对象的空function</span></span><br><span class="line"><span class="function">function&lt;T&gt; <span class="title">f</span><span class="params">(obj)</span></span>;	<span class="comment">// 在f中存储可调用对象obj的副本</span></span><br><span class="line">f					<span class="comment">// f作为条件，当f含有可调用对象时为真</span></span><br><span class="line">    </span><br><span class="line">定义为function&lt;T&gt;的成员的类型</span><br><span class="line">result_type			<span class="comment">// 该funtion类型的可调用对象返回的类型</span></span><br><span class="line">argument_type		<span class="comment">// 如果T只有一个实参，则argument_type是该类</span></span><br><span class="line">first_argument_type <span class="comment">// 型的同义词；如果T有两个实参，则first、</span></span><br><span class="line">second_argument_type<span class="comment">// second分别代表两个实参的类型</span></span><br></pre></td></tr></table></figure>
<ul>
<li>用function构建函数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f1 = add;		<span class="comment">// 函数指针</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f2 = divide();	<span class="comment">// 函数对象类的对象</span></span><br><span class="line">function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt; f3 = [](<span class="keyword">int</span> i, <span class="keyword">int</span> j)	<span class="comment">// lambda</span></span><br><span class="line">							&#123; <span class="keyword">return</span> i * j; &#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>用function重新构建map</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>, function&lt;<span class="keyword">int</span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;&gt; binops;</span><br><span class="line">binops = &#123;</span><br><span class="line">    &#123;<span class="string">"+"</span>, add&#125;,							<span class="comment">// 函数指针</span></span><br><span class="line">    &#123;<span class="string">"-"</span>, <span class="built_in">std</span>::munus&lt;<span class="keyword">int</span>&gt;()&#125;,			<span class="comment">// 标准库函数对象 </span></span><br><span class="line">    &#123;<span class="string">"/"</span>, divide()&#125;,					<span class="comment">// 用户定义的函数对象</span></span><br><span class="line">    &#123;<span class="string">"*"</span>, [](<span class="keyword">int</span> i, <span class="keyword">int</span> j) &#123; <span class="keyword">return</span> i * j; &#125;&#125;,	</span><br><span class="line">    &#123;<span class="string">"%"</span>, mod&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>索引map</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">binops[<span class="string">"+"</span>](<span class="number">10</span>, <span class="number">5</span>);		<span class="comment">// 调用add(10, 5)</span></span><br><span class="line">binops[<span class="string">"-"</span>](<span class="number">10</span>, <span class="number">5</span>);		<span class="comment">// 使用minuns&lt;int&gt;对象的调用运算符</span></span><br></pre></td></tr></table></figure>
<ul>
<li>我们不能（直接）将重载函数的名字存入function类型的对象中，可以通过存储函数指针解决</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123; <span class="keyword">return</span> i + j; &#125;</span><br><span class="line"><span class="function">Sales_data <span class="title">add</span><span class="params">(<span class="keyword">const</span> Sales_data&amp;, <span class="keyword">const</span> Sales_data&amp;)</span></span>;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, add&#125;);			<span class="comment">// 错误</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> (*fp)(<span class="keyword">int</span>, <span class="keyword">int</span>) = add;</span><br><span class="line">binops.insert(&#123;<span class="string">"+"</span>, fp&#125;);			<span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<h3 id="149-重载-类型转换与运算符"><a class="markdownIt-Anchor" href="#149-重载-类型转换与运算符"></a> 14.9 重载、类型转换与运算符</h3>
<h4 id="1491-类型转换运算符"><a class="markdownIt-Anchor" href="#1491-类型转换运算符"></a> 14.9.1 类型转换运算符</h4>
<ul>
<li>
<p>operator <em>type</em>() const;</p>
<p>一个类型转换函数必须是类的成员函数；它不能声明返回类型，形参列表页必须为空。类型转换函数通常应该是const</p>
</li>
<li>
<p>定义函数类型转换运算符的类</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	SmallInt(<span class="keyword">int</span> i = <span class="number">0</span>) : val(i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &lt; <span class="number">0</span> || i &gt; <span class="number">255</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="built_in">std</span>::out_of_range(<span class="string">"bad SmallInt value"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​		构造函数将算术类型的值转换成SmallInt对象，而类型转换运算符将SmallInt对象转换成int</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmallInt si;</span><br><span class="line">si = <span class="number">4</span>;			<span class="comment">// 首先将4隐式地转换成SmallInt,在调用operator=</span></span><br><span class="line">si + <span class="number">3</span>;			<span class="comment">// 首先将si隐式地转换成int，然后执行整数的加法</span></span><br></pre></td></tr></table></figure>
<ul>
<li>显式的类型转换运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SmallInt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> val; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​		必须通过显式的强制类型转换才能执行</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">SmallInt si = <span class="number">3</span>;</span><br><span class="line"><span class="keyword">static_cast</span>&lt;<span class="keyword">int</span>&gt;(si) + <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当表达式出现在下列位置时，显式的类型转换将被隐式地执行：</p>
<ul>
<li>if、while及do语句的条件部分</li>
<li>for语句头的条件表达式</li>
<li>！、||、&amp;&amp;的运算对象</li>
<li>条件运算符（? :）的条件表达式</li>
</ul>
</li>
<li>
<p>转换为bool</p>
<ul>
<li>无论我们什么时候在条件中使用流对象，都会使用为IO类型定义的operator bool</li>
<li>向bool的类型转换通常用在条件部分，因此operator bool一般定义成explicit的</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="built_in">cin</span> &gt;&gt; value)</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">string</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line"><span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> revenue; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1492-避免有二义性的类型转换"><a class="markdownIt-Anchor" href="#1492-避免有二义性的类型转换"></a> 14.9.2 避免有二义性的类型转换</h4>
<ul>
<li>第一种情况：A定义了接受B类对象的转换构造函数，B定义了转换目标是A的类型转换运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">   	A() = <span class="keyword">default</span>;</span><br><span class="line">    A(<span class="keyword">const</span> B&amp;);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">A</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>需要显式调用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">A <span class="title">f</span><span class="params">(<span class="keyword">const</span> A&amp;)</span></span>;</span><br><span class="line">B b;</span><br><span class="line">A a1 = f(b.<span class="keyword">operator</span> A());</span><br><span class="line">A a2 = f(A(b));</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>第二种情况：转换源类型本身可以通过其他类型转换联系在一起</p>
<p>​	<strong>最好不要创建两个转换源都是算术类型的类型转换</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">A</span> &#123;</span></span><br><span class="line">    A(<span class="keyword">int</span> = <span class="number">0</span>);</span><br><span class="line">    A(<span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">operator</span> <span class="title">double</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>除了显式地向bool类型的转换之外，我们应该尽量避免定义类型转换函数</p>
</li>
<li>
<p>在调用重载函数时，如果需要额外的标准类型转换，则该转换的级别只有当所有可行函数都请求同一个用户定义的类型转换时才有用。如果所需的用户定义的类型转换不止一个，则该调用具有二义性</p>
</li>
<li>
<p><strong>order:</strong></p>
<ol>
<li>exact match</li>
<li>const conversion</li>
<li>promotion</li>
<li>arithmetic or pointer conversion</li>
<li>class-type conversion</li>
</ol>
</li>
</ul>
<h4 id="1493-函数匹配与重载运算符"><a class="markdownIt-Anchor" href="#1493-函数匹配与重载运算符"></a> 14.9.3 函数匹配与重载运算符</h4>
<ul>
<li>如果我们对同一个类既提供了转换目标是算术类型的类型转换，也提供了重载的运算符，则将会遇到重载运算符与内置运算符的二义性问题</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 语句</title>
    <url>/2020/09/04/C++/Chapter%205%20%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第五章-语句"><a class="markdownIt-Anchor" href="#第五章-语句"></a> 第五章 语句</h2>
<h3 id="51-简单语句"><a class="markdownIt-Anchor" href="#51-简单语句"></a> 5.1 简单语句</h3>
<h3 id="52-语句作用域"><a class="markdownIt-Anchor" href="#52-语句作用域"></a> 5.2 语句作用域</h3>
<h3 id="53-条件语句"><a class="markdownIt-Anchor" href="#53-条件语句"></a> 5.3 条件语句</h3>
<a id="more"></a>
<ul>
<li>case标签必须是整型常量表达式</li>
</ul>
<h3 id="54-迭代语句"><a class="markdownIt-Anchor" href="#54-迭代语句"></a> 5.4 迭代语句</h3>
<ul>
<li>do while的变量定义要放在外面</li>
</ul>
<h3 id="55-跳转语句"><a class="markdownIt-Anchor" href="#55-跳转语句"></a> 5.5 跳转语句</h3>
<ul>
<li>标签标识符可以和程序中的其他实体的标识符使用同一个名字</li>
</ul>
<h3 id="56-try语句块和异常处理"><a class="markdownIt-Anchor" href="#56-try语句块和异常处理"></a> 5.6 try语句块和异常处理</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    program-statements</span><br><span class="line">&#125; <span class="keyword">catch</span>(exception-declaration) &#123;</span><br><span class="line">    handler-statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>try块内声明的变量在catch子句内无法访问</li>
</ul>
<h4 id="563-标准异常"><a class="markdownIt-Anchor" href="#563-标准异常"></a> 5.6.3 标准异常</h4>
<ul>
<li>
<p>exception头文件只报告异常的发生，不提供额外信息。</p>
</li>
<li>
<p>stdexcept头文件定义了几种常用的异常类</p>
</li>
<li>
<p>new头文件定义了bad_alloc异常类型</p>
</li>
<li>
<p>type_info头文件定义了bad_cast异常类型</p>
</li>
<li>
<p>只能以默认初始化的方式初始化exception、bad_alloc和bad_cast对象，不允许为这些对象提供初始值。</p>
</li>
<li>
<p>what成员函数返回异常初始值</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 IO库</title>
    <url>/2020/09/04/C++/Chapter%208%20IO%E5%BA%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="第八章-io库"><a class="markdownIt-Anchor" href="#第八章-io库"></a> 第八章 IO库</h3>
<h3 id="81-io类"><a class="markdownIt-Anchor" href="#81-io类"></a> 8.1 IO类</h3>
<ul>
<li>iostream定义了用于读写流的基本类型</li>
<li>fstream定义了读写命名文件的类型</li>
<li>sstream定义了读写内存string对象的类型</li>
</ul>
<a id="more"></a>
<h3 id="811-io对象无拷贝或赋值"><a class="markdownIt-Anchor" href="#811-io对象无拷贝或赋值"></a> 8.1.1 IO对象无拷贝或赋值</h3>
<ul>
<li>由于不能拷贝IO对象，进行IO操作的函数通常以引用方式传递和返回流，读写一个IO对象会改变其状态，因此传递和返回的引用不能是const的</li>
</ul>
<h4 id="813-管理输出缓冲"><a class="markdownIt-Anchor" href="#813-管理输出缓冲"></a> 8.1.3 管理输出缓冲</h4>
<ol>
<li>刷新输出缓冲区</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">endl</span>;	<span class="comment">// 换行并刷新</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; <span class="built_in">flush</span>;	<span class="comment">// 刷新</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"hi!"</span> &lt;&lt; ends;	<span class="comment">// 空字符+刷新</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>unitbuf操纵符</p>
<p>在接下来的每次写操作之后都进行一次flush操作。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; unitbuf;	</span><br><span class="line"><span class="comment">// 任何输出都立即刷新，无缓冲</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; nounitbuf;	<span class="comment">// 回到正常的缓冲方式</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>关联输入和输出流</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">cin</span>.tie();		<span class="comment">// 返回指向输出流的指针</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">cin</span>.tie(&amp;<span class="built_in">cout</span>);	<span class="comment">// 将cin和cout关联在一起</span></span><br></pre></td></tr></table></figure>
<ul>
<li>每个流同时最多关联到一个流，但多个流可以同时关联到同一个ostream</li>
</ul>
<h3 id="82-文件输入输出"><a class="markdownIt-Anchor" href="#82-文件输入输出"></a> 8.2 文件输入输出</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">fstream fstrm;			<span class="comment">// 创建一个未绑定的文件流</span></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s)</span></span>;		<span class="comment">// 创建一个fstream，并打开s文件</span></span><br><span class="line"><span class="function">fstream <span class="title">fstrm</span><span class="params">(s, mode)</span></span>;	<span class="comment">// 以mode模式打开s</span></span><br><span class="line">fstream.<span class="built_in">open</span>(s);		<span class="comment">// 打开s，并于fstrm绑定</span></span><br><span class="line">fstrm.<span class="built_in">close</span>();			<span class="comment">// 关闭文件</span></span><br><span class="line">fstrm.is_open();		<span class="comment">// 是否成功打开</span></span><br></pre></td></tr></table></figure>
<h4 id="821-使用文件流对象"><a class="markdownIt-Anchor" href="#821-使用文件流对象"></a> 8.2.1 使用文件流对象</h4>
<ul>
<li>可以用fstream代替iostream&amp;</li>
</ul>
<h4 id="822-文件模式"><a class="markdownIt-Anchor" href="#822-文件模式"></a> 8.2.2 文件模式</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">in		<span class="comment">// 以读方式打开</span></span><br><span class="line">out 	<span class="comment">// 以写方式打开</span></span><br><span class="line">app		<span class="comment">// 每次写操作前均定位到文件末尾</span></span><br><span class="line">ate		<span class="comment">// 打开文件后立即定位到文件末尾</span></span><br><span class="line">trunc	<span class="comment">// 截断文件</span></span><br><span class="line">binary	<span class="comment">// 以二进制方式进行IO</span></span><br></pre></td></tr></table></figure>
<ul>
<li>保留被ofstream打开的文件中已有数据的唯一方法是显式指定app或in模式</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ofstream <span class="title">app2</span><span class="params">(<span class="string">"file2"</span>, ofstream::out | ofstream::app)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="83-string流"><a class="markdownIt-Anchor" href="#83-string流"></a> 8.3 string流</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">sstream strm;</span><br><span class="line">strm.str();		<span class="comment">// 返回strm所保存的string的拷贝</span></span><br><span class="line">strm.str(s);	<span class="comment">// 将string s拷贝到strm中</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 顺序容器</title>
    <url>/2020/09/04/C++/Chpater%209%20%E9%A1%BA%E5%BA%8F%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第九章-顺序容器"><a class="markdownIt-Anchor" href="#第九章-顺序容器"></a> 第九章 顺序容器</h2>
<h3 id="91-顺序容器概述"><a class="markdownIt-Anchor" href="#91-顺序容器概述"></a> 9.1 顺序容器概述</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>			<span class="comment">// 可变大小数组，在尾部之外的位置修改元素可能很慢</span></span><br><span class="line"><span class="built_in">deque</span>			<span class="comment">// 双端队列，在头尾修改速度很快</span></span><br><span class="line"><span class="built_in">list</span>			<span class="comment">// 双向链表，只支持双向顺序访问，在任何位置修改都很快</span></span><br><span class="line">forward_list	<span class="comment">// 单向链表，支持单项顺序访问，在任何位置修改都很快</span></span><br><span class="line"><span class="built_in">array</span>			<span class="comment">// 固定大小数组</span></span><br><span class="line"><span class="built_in">string</span>			<span class="comment">// 与vector相似的容器，专门用于保存字符</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>
<h3 id="92-容器库概览"><a class="markdownIt-Anchor" href="#92-容器库概览"></a> 9.2 容器库概览</h3>
<h4 id="921-迭代器"><a class="markdownIt-Anchor" href="#921-迭代器"></a> 9.2.1 迭代器</h4>
<ul>
<li>迭代器范围为左闭合区间</li>
</ul>
<h4 id="922-容器定义与初始化"><a class="markdownIt-Anchor" href="#922-容器定义与初始化"></a> 9.2.2 容器定义与初始化</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">C c;</span><br><span class="line"><span class="function">C <span class="title">c1</span><span class="params">(c2)</span></span>;</span><br><span class="line">C c&#123;a, b, c&#125;;</span><br><span class="line"><span class="function">C <span class="title">c</span><span class="params">(<span class="built_in">begin</span>, <span class="built_in">end</span>)</span></span>;</span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n)</span></span>;		<span class="comment">// n个元素</span></span><br><span class="line"><span class="function">C <span class="title">seq</span><span class="params">(n, t)</span></span>;	<span class="comment">// n个初始值为t的元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>当传递迭代器参数来拷贝一个范围时，不要求容器类型是相同的，元素类型需可互相转化。</p>
</li>
<li>
<p>标准库array的大小是类型的一部分</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">array</span>&lt;<span class="keyword">int</span>, 10&gt;;</span><br></pre></td></tr></table></figure>
<h4 id="925-赋值和swap"><a class="markdownIt-Anchor" href="#925-赋值和swap"></a> 9.2.5 赋值和swap</h4>
<ol>
<li>assign操作</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">seq.assign(<span class="built_in">begin</span>, <span class="built_in">end</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>swap操作</p>
<p>swap交换两个相同类型容器的内容。</p>
</li>
</ol>
<h4 id="926-容器大小操作"><a class="markdownIt-Anchor" href="#926-容器大小操作"></a> 9.2.6 容器大小操作</h4>
<ul>
<li>size、empty、max_size</li>
</ul>
<h4 id="927-关系运算符"><a class="markdownIt-Anchor" href="#927-关系运算符"></a> 9.2.7 关系运算符</h4>
<ul>
<li>
<p>只有当元素类型定义了相应的比较运算符时，才能使用关系运算符来比较两个容</p>
<p>器</p>
</li>
</ul>
<h3 id="93-顺序容器操作"><a class="markdownIt-Anchor" href="#93-顺序容器操作"></a> 9.3 顺序容器操作</h3>
<h4 id="931-向顺序容器添加元素"><a class="markdownIt-Anchor" href="#931-向顺序容器添加元素"></a> 9.3.1 向顺序容器添加元素</h4>
<ol>
<li>
<p>push_back、push_front、insert</p>
</li>
<li>
<p>emplace操作</p>
<p>在调用emplace时，会在容器管理的内存空间中直接创建对象。而调用push则会创建一个局部临时对象，并将其压入容器中。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.emplace_back(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>);</span><br><span class="line">c.push_back(Sales_data(<span class="string">"978-0590353403"</span>, <span class="number">25</span>, <span class="number">15.99</span>));</span><br></pre></td></tr></table></figure>
<h4 id="932-访问元素"><a class="markdownIt-Anchor" href="#932-访问元素"></a> 9.3.2 访问元素</h4>
<ul>
<li>
<p>front和back返回首尾元素的引用</p>
</li>
<li>
<p>at返回下标为n的元素引用</p>
</li>
</ul>
<h4 id="933-删除元素"><a class="markdownIt-Anchor" href="#933-删除元素"></a> 9.3.3 删除元素</h4>
<ul>
<li>
<p>pop_back、pop_front、erase</p>
</li>
<li>
<p>erase返回指向删除的元素之后位置的迭代器</p>
</li>
</ul>
<h4 id="934-特殊的forward_list操作"><a class="markdownIt-Anchor" href="#934-特殊的forward_list操作"></a> 9.3.4 特殊的forward_list操作</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">before_begin()		<span class="comment">// 返回首元素之前不存在的元素的迭代器</span></span><br><span class="line">insert_after(p)		<span class="comment">// p后插入</span></span><br><span class="line">emplace_after(p,a)	<span class="comment">// p后插入</span></span><br><span class="line">lst.erase_after(p)	<span class="comment">// p后删除</span></span><br></pre></td></tr></table></figure>
<h4 id="935-改变容器大小"><a class="markdownIt-Anchor" href="#935-改变容器大小"></a> 9.3.5 改变容器大小</h4>
<ul>
<li>resize</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.resize(n)			<span class="comment">// 调整c的大小为n个元素，少增多删</span></span><br><span class="line">c.resize(n, t)		<span class="comment">// 带初始值</span></span><br></pre></td></tr></table></figure>
<h4 id="936-容器操作可能使迭代器失效"><a class="markdownIt-Anchor" href="#936-容器操作可能使迭代器失效"></a> 9.3.6 容器操作可能使迭代器失效</h4>
<ul>
<li>循环中更新迭代器</li>
</ul>
<h3 id="94-vector对象是如何增长的"><a class="markdownIt-Anchor" href="#94-vector对象是如何增长的"></a> 9.4 vector对象是如何增长的</h3>
<ul>
<li>适用于vector和string</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">c.shrink_to_fit()		<span class="comment">// 请将capacity()减少为与size()相同大小</span></span><br><span class="line">c.capacity()			<span class="comment">// 不重新分配内存空间，c可保存的元素</span></span><br><span class="line">c.reserve(n)			<span class="comment">// 分配至少能容纳n个元素的内存空间</span></span><br><span class="line">c.resize(n)				<span class="comment">// resize既分配空间又分配对象</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/09/04/ye2oiVtGglhkb8B.png" alt="image-20200814135745978.png" /></p>
<h3 id="95-额外的string操作"><a class="markdownIt-Anchor" href="#95-额外的string操作"></a> 9.5 额外的string操作</h3>
<h4 id="951-构造string的其他方法"><a class="markdownIt-Anchor" href="#951-构造string的其他方法"></a> 9.5.1 构造string的其他方法</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(cp, n)</span>		<span class="comment">// s是cp指向的数组中前n个字符的拷贝</span></span></span><br><span class="line">s.substr(pos, n)	// 返回一个从pos开始n个字符的拷贝</span><br></pre></td></tr></table></figure>
<h4 id="952-改变string的其他方法"><a class="markdownIt-Anchor" href="#952-改变string的其他方法"></a> 9.5.2 改变string的其他方法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在s[0]之前插入s2中s2[0]开始的s2.size()个字符</span></span><br><span class="line">s.insert(<span class="number">0</span>, s2, <span class="number">0</span>, s2,<span class="built_in">size</span>());	</span><br><span class="line">s.append(<span class="string">"4th"</span>);			<span class="comment">// 末尾追加</span></span><br><span class="line">s.replace(<span class="number">11</span>, <span class="number">3</span>, <span class="string">"5th"</span>);	<span class="comment">// 先删除3个字符再插入</span></span><br></pre></td></tr></table></figure>
<h4 id="953-string搜索操作"><a class="markdownIt-Anchor" href="#953-string搜索操作"></a> 9.5.3 string搜索操作</h4>
<ul>
<li>均返回size_type</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.<span class="built_in">find</span>()				<span class="comment">// 第一次出现位置</span></span><br><span class="line">s.find_first_of()		<span class="comment">// 任何一个args中字符第一次出现位置</span></span><br><span class="line">s.find_first_not_of()	<span class="comment">// 第一个不在args中的字符</span></span><br></pre></td></tr></table></figure>
<h4 id="954-compare函数"><a class="markdownIt-Anchor" href="#954-compare函数"></a> 9.5.4 compare函数</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.compare(pos1, n1, s2, pos2, n2)</span><br><span class="line">s.compare(pos1, n1, cp, n2)</span><br></pre></td></tr></table></figure>
<h4 id="955-数值转换"><a class="markdownIt-Anchor" href="#955-数值转换"></a> 9.5.5 数值转换</h4>
<ul>
<li>要转换为数值的string中第一个非空白符必须是数值中可能出现的字符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">d = stod(s2.substr(s2.find_first_of(<span class="string">"+-.0123456789"</span>)));</span><br><span class="line">to_string(val)		<span class="comment">// val可以是任何算术类型</span></span><br><span class="line">stoi(s, p, b)		<span class="comment">// b为转换基数，默认10，p默认0</span></span><br></pre></td></tr></table></figure>
<h3 id="96-容器适配器"><a class="markdownIt-Anchor" href="#96-容器适配器"></a> 9.6 容器适配器</h3>
<ul>
<li>stack默认基于deque实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">s.pop()				<span class="comment">// 删除栈顶元素，不返回值</span></span><br><span class="line">s.push()			<span class="comment">// 压入栈顶</span></span><br><span class="line">s.top()				<span class="comment">// 返回栈顶元素</span></span><br></pre></td></tr></table></figure>
<ul>
<li>queue默认基于deque实现，priority_queue默认基于vector实现</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">q.pop()				<span class="comment">// 不删除</span></span><br><span class="line">q.back()			<span class="comment">// 不删除</span></span><br><span class="line">q.top()				<span class="comment">// 只适用于priority_queue</span></span><br><span class="line">q.push()			<span class="comment">// 末尾</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第十五章 面向对象程序设计</title>
    <url>/2020/09/04/C++/Chpater%2015%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十五章-面向对象程序设计"><a class="markdownIt-Anchor" href="#第十五章-面向对象程序设计"></a> 第十五章 面向对象程序设计</h2>
<h3 id="151-oop概述"><a class="markdownIt-Anchor" href="#151-oop概述"></a> 15.1 OOP:概述</h3>
<ul>
<li>
<p>继承</p>
<p>​	通过继承联系在一起的类构成一种层次关系。通常在层次关机的根部有一个<strong>基类</strong>，其他类直接或间接地从基类继承而来，成为<strong>派生类</strong></p>
</li>
</ul>
<a id="more"></a>
<ul>
<li>
<p>虚函数</p>
<p>​	对于某些函数，基类希望它的派生类各自定义适合自身的版本，此时基类就将这些函数声明称虚函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类通过使用<strong>类派生列表</strong>明确指出它是从哪些基类继承而来的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:	</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		因为Bulk_quote在派生列表中使用了public关键字，因此我们完全可以把Bulk_quote的对象当成Quote的对象来使用</p>
<ul>
<li>
<p>动态绑定</p>
<p>通过使用动态绑定，我们能用同一段代码分别处理Quote和Bulk_quote对象</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">print_total</span><span class="params">(ostream&amp; os, <span class="keyword">const</span> Quote&amp; item, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> ret = item.net_price(n);</span><br><span class="line">    os &lt;&lt; <span class="string">"ISBN: "</span> &lt;&lt; item.isbn()</span><br><span class="line">        &lt;&lt; <span class="string">" # sold: "</span> &lt;&lt; n &lt;&lt; <span class="string">" total due: "</span> &lt;&lt; ret &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>在C++中，当我们使用基类的引用（或指针）调用一个虚函数时将发生动态绑定</strong></li>
</ul>
<h3 id="152-定义基类和派生类"><a class="markdownIt-Anchor" href="#152-定义基类和派生类"></a> 15.2 定义基类和派生类</h3>
<h4 id="1521-定义基类"><a class="markdownIt-Anchor" href="#1521-定义基类"></a> 15.2.1 定义基类</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Quote() = <span class="keyword">default</span>;</span><br><span class="line">    Quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp;book, <span class="keyword">double</span> sales_price) :</span><br><span class="line">    	bookNo(book), price(sales_price) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">isbn</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> bookNo; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 派生类负责改写并使用不同的折扣计算算法</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span> n)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> n * price; &#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;		<span class="comment">// 对析构函数进行动态绑定</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">string</span> bookNo;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">double</span> price = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>成员函数与继承</p>
<ul>
<li>当我们使用指针或引用调用虚函数时，该调用将被动态绑定</li>
<li>关键字virtual只能出现在类内部的声明语句之前而不能用于类外部的函数定义</li>
</ul>
</li>
<li>
<p>protected</p>
<ul>
<li>基类有权访问该成员，同时禁止其他用户访问</li>
</ul>
</li>
</ul>
<h4 id="1522-定义派生类"><a class="markdownIt-Anchor" href="#1522-定义派生类"></a> 15.2.2 定义派生类</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">size_t</span> min_qty = <span class="number">0</span>;			<span class="comment">// 适用折扣政策的最低购买量</span></span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;		<span class="comment">// 以小数表示的折扣额</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>派生类中的虚函数</p>
<p>​	派生类可以显式地著名它使用某个成员函数覆盖了它继承的虚函数，在const、引用限定符后添加一个关键字override</p>
</li>
<li>
<p>派生类到基类的类型转换</p>
<p>​	因为在派生类对象中含有与其基类对应的组成部分，所以我们能把派生类的对象当成基类对象来使用，<strong>也能将基类的指针或引用绑定到派生类对象中的基类部分上</strong></p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Quote item;</span><br><span class="line">Bulk_quote bulk;</span><br><span class="line">Quote *p = &amp;item;		</span><br><span class="line">p = &amp;bulk;				<span class="comment">// p指向bulk的Quote部分</span></span><br><span class="line">Quote &amp;r = bulk;		<span class="comment">// r绑定到bulk的Quote部分</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>派生类构造函数</p>
<p>​	<strong>派生类不能直接初始化从基类继承而来的成员，派生类必须使用基类的构造函数来初始化它的基类部分</strong></p>
<p>​	首先初始化基类部分，然后按照声明的顺序依次初始化派生类的成员</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp; book, <span class="keyword">double</span> p, <span class="keyword">size_t</span> qty, <span class="keyword">double</span> disc) :</span><br><span class="line">	Quote(book, p), min_qty(qty), discount(disc) &#123; &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>派生类使用基类的成员</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Bulk_quote::newt_price</span><span class="params">(<span class="keyword">size_t</span> cnt)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(cnt &gt;= min_qty)</span><br><span class="line">        <span class="keyword">return</span> cnt * ( <span class="number">1</span> - discount ) * price;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> cnt * price;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>继承与静态成员</p>
<p>​	如果基类定义了一个静态成员，则在整个继承体系中只存在该成员的唯一定义</p>
</li>
<li>
<p>被用作基类的类</p>
<p>​	如果我们想将某个类用作基类，则该类必须已经定义而非仅仅声明</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span>;</span>							<span class="comment">// 声明但未定义</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote&#123; ... &#125;;	<span class="comment">// 错误：Quote未定义</span></span><br></pre></td></tr></table></figure>
<ul>
<li>防止继承的发生——final</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NoDerived</span> <span class="title">final</span> &#123;</span> <span class="comment">/*  */</span> &#125;;	<span class="comment">// NoDerived不能作为基类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Last</span> <span class="title">final</span> :</span> Base&#123; &#125;;			<span class="comment">// Last不能作为基类</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp;, <span class="keyword">double</span>, <span class="keyword">size_t</span>, <span class="keyword">double</span>);</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">size_t</span> min_qty = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1523-类型转换与继承"><a class="markdownIt-Anchor" href="#1523-类型转换与继承"></a> 15.2.3 类型转换与继承</h4>
<ul>
<li>
<p>智能指针类也支持派生类向基类的类型转换</p>
</li>
<li>
<p>静态类型与动态类型</p>
<p>​	表达式的静态类型在编译时总是已知的，它是变量声明时的类型或表达式生成的类型；动态类型则是变量或表达式表示的内存中的对象的类型。动态类型直到运行时才可知</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">double</span> ret = item.net_price(n);</span><br></pre></td></tr></table></figure>
<p>​		item的静态类型是Quote&amp;，它的动态类型则依赖于item绑定的实参</p>
<ul>
<li>
<p>如果表达式既不是引用也不是指针，则它的动态类型永远与静态类型一致</p>
</li>
<li>
<p>不存在从基类向派生类的隐式类型转换</p>
</li>
<li>
<p>当用派生类对象为一个基类对象赋值时，只有该派生类对象中的基类部分会被拷贝、移动或赋值，它的派生类部分将被忽略掉</p>
</li>
</ul>
<h3 id="153-虚函数"><a class="markdownIt-Anchor" href="#153-虚函数"></a> 15.3 虚函数</h3>
<ul>
<li>
<p>对虚函数的调用可能在运行时才被解析</p>
</li>
<li>
<p>动态绑定只有当我们通过指针或引用调用虚函数时才会发生</p>
</li>
<li>
<p>一个派生类的函数如果覆盖了某个继承而来的虚函数，则它的形参类型必须与它覆盖的基类函数完全一致</p>
</li>
<li>
<p>派生类虚函数的返回类型也必须与基类一致，当返回类型是类本身的指针或引用时例外</p>
</li>
<li>
<p><strong>final</strong>和<strong>override</strong>说明符</p>
<ul>
<li><strong>如果我们使用override标记了某个函数，但该函数并没有覆盖已存在的虚函数，此时编译器将报错</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D</span> :</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f2</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">override</span></span>; <span class="comment">// 错误：B没有形如f2(int)的函数</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>我们能把某个函数指定为final，之后任何尝试覆盖该函数的操作都将引发错误</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D2</span> :</span> B &#123;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span> <span class="keyword">final</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">D3</span> :</span> D2 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">f1</span><span class="params">(<span class="keyword">int</span>)</span> <span class="keyword">const</span></span>;		<span class="comment">// 错误：D2已经将f2声明称final</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>final和override说明符出现在形参列表以及尾置返回类型之后</li>
</ul>
</li>
<li>
<p>虚函数与默认实参</p>
<p>​		如果某次函数调用使用了默认实参，则该实参值由本次调用的静态类型决定</p>
<ul>
<li>如果虚函数使用默认实参，则基类和派生类中定义的默认实参最好一致</li>
</ul>
</li>
<li>
<p>回避虚函数的机制</p>
<p>​	可以使用作用域运算符强迫其执行虚函数的某个特定版本</p>
<ul>
<li>如果一个派生类虚函数需要调用它的基类版本，但是没有使用作用域运算符，则在运行时该调用将被解析为对派生类版本自身的调用，从而导致无限递归</li>
</ul>
</li>
</ul>
<h3 id="154-抽象基类"><a class="markdownIt-Anchor" href="#154-抽象基类"></a> 15.4 抽象基类</h3>
<ul>
<li>
<p>纯虚函数</p>
<p>​		我们通过在函数体的位置书学=0将一个虚函数说明为纯虚函数，=0只能出现在类内部的虚函数声明语句处</p>
<ul>
<li>不能在类的内部为一个=0的函数提供函数体</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Disc_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">pritected:</span><br><span class="line">    <span class="keyword">size_t</span> quantity = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">double</span> discount = <span class="number">0.0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>含有纯虚函数的类是抽象基类，<strong>我们不能（直接）创建一个抽象基类的对象</strong></p>
</li>
<li>
<p>派生类构造函数只初始化它的直接基类</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> : Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	Bulk_quote() = <span class="keyword">default</span>;</span><br><span class="line">    Bulk_quote(<span class="keyword">const</span> <span class="built_in">string</span>&amp; book, <span class="keyword">double</span> price, size_ qty, <span class="keyword">double</span> disc) :</span><br><span class="line">    Disc_quote(book, price, qty, disc) &#123; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span> <span class="keyword">override</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="155-访问控制与继承"><a class="markdownIt-Anchor" href="#155-访问控制与继承"></a> 15.5 访问控制与继承</h3>
<ul>
<li>
<p>protected</p>
<p>派生类的成员和友元只能访问派生类对象中的基类部分的受保护成员，对于普通的基类对象中的成员不具有特殊的访问权限</p>
</li>
<li>
<p>公有、私有和受保护继承</p>
<ul>
<li>派生访问说明符的目的是控制派生类用户对于基类成员的访问权限</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pub_mem</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> prot_mem;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">char</span> priv_mem;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Pub_Derv</span> :</span> <span class="keyword">public</span> Base &#123; &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Priv_Derv</span> :</span> <span class="keyword">private</span> Base &#123; &#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Pub_Derv d1;</span><br><span class="line">Priv_Derv d2;</span><br><span class="line">d1.pub_mem();</span><br><span class="line">d2.pub_mem();		<span class="comment">// 错误：pub_mem在派生类中是private的</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>派生访问说明符还可以控制继承自派生类的新类的访问权限</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Public</span> :</span> <span class="keyword">public</span> Pub_Derv &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;					<span class="comment">// 正确:Base::prot_mem仍是protected的</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Derived_from_Private</span> :</span> <span class="keyword">public</span> Priv_Derv &#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">use_base</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> prot_mem; &#125;</span><br><span class="line">&#125;;					<span class="comment">// 错误：Base::prot_mem是private的</span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>基类应该将其接口成员声明为共有的，同时将属于其实现的部分分成两组：一组可供派生类访问，声明为受保护的；另一组只能由基类及基类的友元访问，声明为私有的</strong></li>
</ul>
</li>
<li>
<p>派生类向基类转换的可访问性</p>
<ul>
<li>只有当D公有地继承B时，<strong>用户代码</strong>才能使用派生类向基类的转换</li>
<li>不论D以什么方式继承B，D的成员函数和友元都能转换</li>
<li>如果D继承B的方式是公有的或者受保护的，则D的派生类的成员和友元可以使用D向B的类型转换</li>
</ul>
</li>
<li>
<p>友元与继承</p>
<ul>
<li>
<p><strong>友元关系不能继承</strong>，基类的友元在访问派生类成员时不具有特殊性</p>
</li>
<li>
<p>基类的访问权限由基类本身控制，即使对于派生类的基类部分也是如此</p>
</li>
</ul>
</li>
<li>
<p>改变个别成员的可访问性</p>
<ul>
<li>
<p>using</p>
<p>​	派生类只能为它能访问的名字提供using声明</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> n; &#125;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">size_t</span> n;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Derived</span> :</span> <span class="keyword">private</span> Base &#123;		<span class="comment">// 注意：private继承</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::<span class="built_in">size</span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> Base::n;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>默认的继承保护级别</p>
<p>​	默认情况下，使用class关键字定义的派生类是私有继承的；使用struct关键字定义的派生类是公有继承的</p>
</li>
</ul>
<h3 id="156-继承中的类作用域"><a class="markdownIt-Anchor" href="#156-继承中的类作用域"></a> 15.6 继承中的类作用域</h3>
<ul>
<li>一个对象、引用或指针的<strong>静态类型</strong>决定了该对象哪些成员是可见的</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">clalss Disc_quote : <span class="keyword">public</span> Quote &#123;</span><br><span class="line">public: pair&lt;size_t, double&gt; discount_policy() const&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Bulk_quote bulk;</span><br><span class="line">Bulk_quote *bulkP = &amp;bulk;</span><br><span class="line">Quote *itemP = &amp;bulk;</span><br><span class="line">bulkP-&gt;discount_policy();	<span class="comment">// 正确：bulkP的类型是Bulk_quote*</span></span><br><span class="line">itemP-&gt;discount_policy();	<span class="comment">// 错误：itemP的类型是Quote*</span></span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>名字冲突与继承</p>
<p>​	派生类能重用定义在其直接基类或间接基类中的名字</p>
<ul>
<li>除了覆盖继承而来的虚函数之外，派生类最好不要重用定义在基类中的名字</li>
</ul>
</li>
<li>
<p>覆盖重载的函数</p>
<p>​	为重载的成员提供一条using声明语句，可以把该函数的所有重载实例添加到派生类作用域中，对派生类没有重新定义的重载版本的访问实际上是对using声明点的访问</p>
</li>
</ul>
<h3 id="157-构造函数与拷贝控制"><a class="markdownIt-Anchor" href="#157-构造函数与拷贝控制"></a> 15.7 构造函数与拷贝控制</h3>
<h4 id="1571-虚析构函数"><a class="markdownIt-Anchor" href="#1571-虚析构函数"></a> 15.7.1 虚析构函数</h4>
<ul>
<li>我们通过在基类中将析构函数定义成虚函数确保执行正确的析构函数版本</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 如果我们删除的是一个指向派生类对象的基类指针，则需要虚析构函数</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Quote *itempP = <span class="keyword">new</span> Quote;		<span class="comment">// 静态类型与动态类型一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;					<span class="comment">// 调用Quote的析构函数</span></span><br><span class="line">itemP = <span class="keyword">new</span> Bulk_quote;			<span class="comment">// 静态类型与动态类型不一致</span></span><br><span class="line"><span class="keyword">delete</span> itemP;					<span class="comment">// 调用Bulk_quote的析构函数</span></span><br></pre></td></tr></table></figure>
<ul>
<li>虚析构函数将阻止合成移动操作
<ul>
<li>基类没有移动操作意味着它的派生类也没有</li>
</ul>
</li>
</ul>
<h4 id="1572-合成拷贝控制与继承"><a class="markdownIt-Anchor" href="#1572-合成拷贝控制与继承"></a> 15.7.2 合成拷贝控制与继承</h4>
<ul>
<li>
<p>派生类中删除的拷贝控制与基类的关系</p>
</li>
<li>
<p>如果基类中的默认构造函数、拷贝构造函数、拷贝赋值运算符或析构函数是被删除的函数或者不可访问，则派生类中对应的成员将是被删除的</p>
</li>
<li>
<p>移动操作与继承</p>
<p>​	当派生类需要执行移动操作，可以在基类中定义合成的版本</p>
<ul>
<li>一旦基类定义了移动操作，那么必须同时显式地定义拷贝操作</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Quote() = <span class="keyword">default</span>;						<span class="comment">// 默认初始化</span></span><br><span class="line">    Quote(<span class="keyword">const</span> Quote&amp;) = <span class="keyword">default</span>;			<span class="comment">// 拷贝构造函数</span></span><br><span class="line">    Quote(Qutoe&amp;&amp;) = <span class="keyword">default</span>;				<span class="comment">// 移动构造</span></span><br><span class="line">    <span class="function">Quote&amp; <span class="title">oeprator</span><span class="params">(<span class="keyword">const</span> Quote&amp;)</span> </span>= <span class="keyword">default</span>;<span class="comment">// 拷贝赋值</span></span><br><span class="line">    Quote&amp; <span class="keyword">operator</span>=(Qutoe&amp;&amp;) = <span class="keyword">default</span>;	<span class="comment">// 移动赋值</span></span><br><span class="line">    <span class="keyword">virtual</span> ~Quote() = <span class="keyword">default</span>;</span><br><span class="line">&#125;；</span><br></pre></td></tr></table></figure>
<h4 id="1573-派生类的拷贝控制成员"><a class="markdownIt-Anchor" href="#1573-派生类的拷贝控制成员"></a> 15.7.3 派生类的拷贝控制成员</h4>
<ul>
<li>
<p>当派生类定义了拷贝或移动操作时，该操作负责拷贝或移动包括基类部分成员在内的整个对象</p>
</li>
<li>
<p>定义派生类的拷贝或移动构造函数</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Base</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span> :</span> <span class="keyword">public</span> Base &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    D(<span class="keyword">const</span> D&amp; d) : Base(d) ... &#123; &#125;</span><br><span class="line">    D(D&amp;&amp; d) : Base(<span class="built_in">std</span>::<span class="built_in">move</span>(d)) ... &#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>派生类赋值运算符</p>
<p>​		显式调用基类赋值运算符</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Base::<span class="keyword">operator</span>=(<span class="keyword">const</span> Base&amp;);</span><br><span class="line">D&amp; D::<span class="keyword">operator</span>=(<span class="keyword">const</span> D&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    Base::<span class="keyword">operator</span>=(rhs);</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>在构造函数和析构函数中调用虚函数</p>
<p>​		如果构造函数或析构函数调用了某个虚函数，则我们应该执行与构造函数或析构函数所属类型相对应的虚函数版本</p>
</li>
</ul>
<h4 id="1574-继承的构造函数"><a class="markdownIt-Anchor" href="#1574-继承的构造函数"></a> 15.7.4 继承的构造函数</h4>
<ul>
<li>通过using继承构造函数
<ul>
<li>派生类自己的数据成员将被默认初始化</li>
</ul>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Disc_quote &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> Disc_quote::Disc_quote;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">net_price</span><span class="params">(<span class="keyword">size_t</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>using的构造函数不会改变访问级别</li>
</ul>
<h3 id="158-容器与继承"><a class="markdownIt-Anchor" href="#158-容器与继承"></a> 15.8 容器与继承</h3>
<ul>
<li>
<p>当派生类对象被赋值给基类对象时，其派生类部分将被“切掉”</p>
</li>
<li>
<p>在容器中放置（智能）指针而非对象</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;&gt; basket;</span><br><span class="line">basket.push_back(make_shared&lt;Bulk_quote&gt;(<span class="string">"0-201-54848-8"</span>, <span class="number">50</span>, <span class="number">10</span>, <span class="number">0.25</span>));</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; basket.back()-&gt;net_price(<span class="number">15</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure>
<h4 id="1581-编写basket类"><a class="markdownIt-Anchor" href="#1581-编写basket类"></a> 15.8.1 编写Basket类</h4>
<ul>
<li>我们无法直接使用对象进行编程，必须使用指针和引用。为了减少复杂性，我们经常定义一些辅助类来帮助处理</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// Basket使用合成的默认构造函数和拷贝控制成员</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;Quote&gt;&amp; sale)</span></span></span><br><span class="line"><span class="function">    </span>&#123; item.insert(sale); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">total_receipt</span><span class="params">(ostream&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">compare</span><span class="params">(<span class="keyword">const</span> <span class="built_in">shared_ptr</span>&lt;Quote&gt;&amp; lhs, </span></span></span><br><span class="line"><span class="function"><span class="params">                       <span class="built_in">shared_ptr</span>&lt;Quote&gt;&amp; rhs)</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> lhs-&gt;isbn() &lt; rhs-&gt;isbn(); &#125;</span><br><span class="line">    <span class="comment">// multiset保存多个报价，按照compare成员排序</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">multiset</span>&lt;<span class="built_in">shared_ptr</span>&lt;Quote&gt;, <span class="keyword">decltype</span>(compare)*&gt;</span><br><span class="line">        items&#123;compare&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">Basket::total_receipt</span><span class="params">(ostream&amp; os)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> sum = <span class="number">0.0</span>;</span><br><span class="line">    <span class="comment">// upper_bound令我们跳过与当前关键字相同的所有元素</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> iter = items.cbegin(); iter != item.cend();</span><br><span class="line">       		iter = items.upper_bound(*iter)) &#123;</span><br><span class="line">       sum += print_total(os, **iter, items.count(*iter));</span><br><span class="line">    &#125;</span><br><span class="line">    os &lt;&lt; <span class="string">"Total Sale: "</span> &lt;&lt; sum &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>模拟虚拷贝</p>
<p>​		new Quote(sale)不确定分配的类型，因此给Quote类添加一个虚函数，该函数将申请一份当前对象的拷贝</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Quote</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 该虚函数返回当前对象的一份动态分配的拷贝</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; 		</span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Quote(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp;</span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Quote(<span class="built_in">std</span>::<span class="built_in">move</span>(*<span class="keyword">this</span>)); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Bulk_quote</span> :</span> <span class="keyword">public</span> Quote &#123;</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> <span class="keyword">const</span> &amp; 		</span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(*<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="function">Bulk_quote* <span class="title">clone</span><span class="params">()</span> &amp;&amp; 		</span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> <span class="keyword">new</span> Bulk_quote(<span class="built_in">std</span>::<span class="built_in">move</span>(*<span class="keyword">this</span>)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Basket</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(<span class="keyword">const</span> Quote&amp; sale)</span></span></span><br><span class="line"><span class="function">    </span>&#123;items.insert(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(sale.clone()));&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">add_item</span><span class="params">(Quote&amp;&amp; sale)</span></span></span><br><span class="line"><span class="function">    </span>&#123; items.insert(</span><br><span class="line">    	<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Quote&gt;(<span class="built_in">std</span>::<span class="built_in">move</span>(sale).clone()));&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>sale的动态类型决定了到底运行Quote的函数还是Bulk_quote的函数</li>
</ul>
<h3 id="159-文本查询程序再探"><a class="markdownIt-Anchor" href="#159-文本查询程序再探"></a> 15.9 文本查询程序再探</h3>
<ul>
<li>
<p>单词查询</p>
<p>​		得到匹配的行</p>
</li>
<li>
<p>逻辑非查询</p>
<p>​		得到不匹配的行</p>
</li>
<li>
<p>逻辑或查询</p>
<p>​		返回匹配两个条件中的一个的行</p>
</li>
<li>
<p>逻辑与查询</p>
<p>​		返回匹配全部两个条件的行</p>
</li>
</ul>
<h4 id="1591-面向对象的解决方案"><a class="markdownIt-Anchor" href="#1591-面向对象的解决方案"></a> 15.9.1 面向对象的解决方案</h4>
<ul>
<li>
<p>我们应该将几种不同的查询建模成互相独立的类，这些类共享一个公共基类</p>
</li>
<li>
<p>抽象基类</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/04/kliUGRSczaFJXVC.png" alt="image-20200902165615876.png" /></p>
<p><img src="https://i.loli.net/2020/09/04/ND2T4RpcMykmJbr.png" alt="image-20200902170106157.png" /></p>
<h4 id="1592-query_base类和query类"><a class="markdownIt-Anchor" href="#1592-query_base类和query类"></a> 15.9.2 Query_base类和Query类</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query_base</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> line_no = TextQuery::line_no;</span><br><span class="line">    <span class="keyword">virtual</span> ~Query_base() = <span class="keyword">default</span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// eval返回与当前Query匹配的QueryResult</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// rep是表示查询的一个string</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Query</span> &#123;</span></span><br><span class="line">	<span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query&amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Query(<span class="keyword">const</span> <span class="built_in">string</span>&amp;);</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; t)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> q-&gt;eval(t); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> q-&gt;rep(); &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    Query(<span class="built_in">shared_ptr</span>&lt;Query_base&gt; query) : q(query) &#123; &#125;</span><br><span class="line">    <span class="built_in">shared_ptr</span>&lt;Query_base&gt; q;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> Query&amp; query)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; query.rep();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="title">Query::Query</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s)</span> : <span class="title">q</span><span class="params">(<span class="keyword">new</span> WordQuery(s))</span></span>&#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="1593-派生类"><a class="markdownIt-Anchor" href="#1593-派生类"></a> 15.9.3 派生类</h4>
<ul>
<li>WordQuery类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WordQuery</span> :</span> <span class="keyword">public</span> Query_base &#123;</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Query</span>;</span>			<span class="comment">// Query使用WordQuery构造函数</span></span><br><span class="line">    WordQuery(<span class="keyword">const</span> <span class="built_in">string</span>&amp; s) : query_word(s) &#123; &#125;</span><br><span class="line">	<span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; t)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123; <span class="keyword">return</span> t.query(query_word); &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> query_word; &#125;</span><br><span class="line">    <span class="built_in">string</span> query_word;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>NotQuery类及~运算符</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NotQuery</span> :</span> <span class="keyword">public</span> Query_base &#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query &amp;);</span><br><span class="line">    NotQuery(<span class="keyword">const</span> Query&amp; q) : query(q) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"~("</span> + query.rep() + <span class="string">")"</span>; &#125;</span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    Query query;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>~(<span class="keyword">const</span> Query&amp; operand)</span><br><span class="line">&#123; <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> NotQuery(operand)); &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BinaryQuery类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryQuery</span> :</span> <span class="keyword">public</span> Query_base &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    BinaryQuery(<span class="keyword">const</span> Query&amp; l, <span class="keyword">const</span> Query&amp; r, <span class="built_in">string</span> s) :</span><br><span class="line">    	lhs(l), rhs(r), opSym(s) &#123; &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">rep</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> <span class="string">"("</span> + lhs.rep() + <span class="string">" "</span> </span><br><span class="line">        				+ opSym + <span class="string">" "</span> + rhs.rep() + <span class="string">")"</span>; &#125;</span><br><span class="line">    Query lhs, rhs;</span><br><span class="line">    <span class="built_in">string</span> opSym;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AndQuery类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AndQuery</span> :</span> <span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">    <span class="keyword">friend</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line">        AndQuery(<span class="keyword">const</span> Query&amp; left, <span class="keyword">const</span> Query&amp; right) :</span><br><span class="line">    		BinaryQuery(left, right, <span class="string">"&amp;"</span>) &#123; &#125;</span><br><span class="line">    <span class="comment">// 具体的类：AndQuery继承了rep并且定义了其他纯虚函数</span></span><br><span class="line">    <span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">inline</span> Query <span class="keyword">operator</span>&amp;(<span class="keyword">const</span> Query&amp; lhs, <span class="keyword">const</span> Query&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> AndQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>OrQuery类</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">OrQuery</span> :</span> <span class="keyword">public</span> BinaryQuery &#123;</span><br><span class="line">     <span class="keyword">friend</span> Query <span class="keyword">operator</span>|(<span class="keyword">const</span> Query&amp;, <span class="keyword">const</span> Query&amp;);</span><br><span class="line">     OrQuery(<span class="keyword">const</span> Query&amp; left, <span class="keyword">const</span> Query&amp; right) :</span><br><span class="line">     		BinaryQuery(left, right, <span class="string">"|"</span>) &#123; &#125;</span><br><span class="line">     <span class="function">QueryResult <span class="title">eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp;)</span> <span class="keyword">const</span></span>;</span><br><span class="line"> &#125;;</span><br><span class="line"><span class="keyword">inline</span> Query oeprator|(<span class="keyword">const</span> Query&amp; lhs, <span class="keyword">const</span> Query&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;Query_base&gt;(<span class="keyword">new</span> OrQuery(lhs, rhs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1594-eval函数"><a class="markdownIt-Anchor" href="#1594-eval函数"></a> 15.9.4 eval函数</h4>
<ul>
<li>OrQuery::eval</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QueryResult <span class="title">OrQuery::eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; <span class="built_in">text</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> right = rhs.eval(<span class="built_in">text</span>), left = lhs.eval(<span class="built_in">text</span>);</span><br><span class="line">    <span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;(left.<span class="built_in">begin</span>(), 												left.<span class="built_in">end</span>());</span><br><span class="line">    ret_lines-&gt;insert(right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> QueryResult(rep(), ret_lines, left.get_file());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>AndQuery::eval</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QueryResult <span class="title">AndQuery::eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; <span class="built_in">text</span>)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> right = rhs.eval(<span class="built_in">text</span>), left = lhs.eval(<span class="built_in">text</span>);    </span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;();</span><br><span class="line">    set_intersection(left.<span class="built_in">begin</span>(), left.<span class="built_in">end</span>(), </span><br><span class="line">            right.<span class="built_in">begin</span>(), right.<span class="built_in">end</span>(), </span><br><span class="line">            inserter(*ret_lines, ret_lines-&gt;<span class="built_in">begin</span>()));</span><br><span class="line">    <span class="keyword">return</span> QueryResult(rep(), ret_lines, left.get_file());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>NotQuery::eval</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">QueryResult <span class="title">NotQuery::eval</span><span class="params">(<span class="keyword">const</span> TextQuery&amp; <span class="built_in">text</span>)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">auto</span> result = query.eval(<span class="built_in">text</span>);</span><br><span class="line">	<span class="keyword">auto</span> ret_lines = make_shared&lt;<span class="built_in">set</span>&lt;line_no&gt;&gt;();</span><br><span class="line">    <span class="keyword">auto</span> beg = result.<span class="built_in">begin</span>(), <span class="built_in">end</span> = result.<span class="built_in">end</span>();</span><br><span class="line">    <span class="keyword">auto</span> sz = result.get_file()-&gt;<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> n = <span class="number">0</span>; n != sz; ++n) &#123;</span><br><span class="line">        <span class="keyword">if</span>(beg == <span class="built_in">end</span> || *beg != n)</span><br><span class="line">            ret_lines-&gt;insert(n);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(beg != <span class="built_in">end</span>)</span><br><span class="line">            ++beg;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> QueryResult(rep(), ret_lines, result.get_file());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 类</title>
    <url>/2020/09/04/C++/Chapter%207%20%E7%B1%BB/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-类"><a class="markdownIt-Anchor" href="#第七章-类"></a> 第七章 类</h2>
<h3 id="71-定义抽象数据类型"><a class="markdownIt-Anchor" href="#71-定义抽象数据类型"></a> 7.1 定义抽象数据类型</h3>
<ol>
<li>
<p>this</p>
<p>this是一个指向非常量的常量指针，不能被常量对象调用</p>
</li>
<li>
<p>const成员函数</p>
<p>const this是一个指向常量的常量指针</p>
</li>
</ol>
<a id="more"></a>
<h4 id="714-构造函数"><a class="markdownIt-Anchor" href="#714-构造函数"></a> 7.1.4 构造函数</h4>
<ol>
<li>默认构造函数</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Sales_data() = <span class="keyword">default</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>构造函数初始值列表</li>
</ol>
<ul>
<li>当某个数据成员被构造函数初始值列表忽略时，它将以与合成默认构造函数相同的方式隐式初始化。</li>
</ul>
<h3 id="72-访问控制与封装"><a class="markdownIt-Anchor" href="#72-访问控制与封装"></a> 7.2 访问控制与封装</h3>
<ul>
<li>struct的默认访问权限是public、class的默认访问权限是private</li>
</ul>
<ol>
<li>封装</li>
</ol>
<ul>
<li>确保用户代码不会无意间破坏封装对象的状态</li>
<li>被封装的类的具体实现细节可以随时改变而无须调整用户级别的代码</li>
</ul>
<h4 id="721-友元"><a class="markdownIt-Anchor" href="#721-友元"></a> 7.2.1 友元</h4>
<ul>
<li>友元的声明之外还需要独立的函数声明</li>
</ul>
<h3 id="73-类的其他特性"><a class="markdownIt-Anchor" href="#73-类的其他特性"></a> 7.3 类的其他特性</h3>
<ul>
<li>一个const成员函数如果以引用的形式返回*this，那么它的返回类型将是常量引用</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>&#123;</span></span><br><span class="line">    Y *y = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>&#123;</span></span><br><span class="line">    X x;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="74-类的作用域"><a class="markdownIt-Anchor" href="#74-类的作用域"></a> 7.4 类的作用域</h3>
<h4 id="741类的作用域"><a class="markdownIt-Anchor" href="#741类的作用域"></a> 7.4.1类的作用域</h4>
<ol>
<li>在成员函数内查找该名字的声明。</li>
<li>在类内查找。</li>
<li>在成员函数定义之前的作用域内查找。</li>
</ol>
<h3 id="75-构造函数"><a class="markdownIt-Anchor" href="#75-构造函数"></a> 7.5 构造函数</h3>
<h4 id="751-构造函数初始化列表"><a class="markdownIt-Anchor" href="#751-构造函数初始化列表"></a> 7.5.1 构造函数初始化列表</h4>
<ul>
<li>当成员是const或者是引用时，必须将其初始化</li>
</ul>
<h4 id="752-委托构造函数"><a class="markdownIt-Anchor" href="#752-委托构造函数"></a> 7.5.2 委托构造函数</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sales_data</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="comment">// 非委托构造函数</span></span><br><span class="line">	Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s, <span class="keyword">unsigned</span> cnt, <span class="keyword">double</span> price)</span><br><span class="line">        :bookNo(s), units_sold(cnt), revenue(cnt * price)&#123;&#125;</span><br><span class="line">    <span class="comment">// 委托构造函数</span></span><br><span class="line">	Sales_data(): Sales_data(<span class="string">""</span>, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">std</span>::<span class="built_in">string</span> s): Sales_data(s, <span class="number">0</span>, <span class="number">0</span>) &#123;&#125;</span><br><span class="line">    Sales_data(<span class="built_in">std</span>:;istream &amp;is): Slaes_data()</span><br><span class="line">    &#123;<span class="built_in">read</span>(is, *<span class="keyword">this</span>);&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="754-隐式的类类型转换"><a class="markdownIt-Anchor" href="#754-隐式的类类型转换"></a> 7.5.4 隐式的类类型转换</h4>
<ul>
<li>explicit抑制构造函数的隐式转换</li>
<li>只能在类内声明构造函数时使用explicit</li>
<li>explicit构造函数只能用于直接初始化不能用于赋值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">explicit</span> <span class="title">Sales_data</span><span class="params">(<span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span> &amp;s)</span>: <span class="title">bookNo</span><span class="params">(s)</span> </span>&#123;&#125;</span><br><span class="line">item.combine(null_book);  <span class="comment">//错误，因为需要从string转换为Sales_data</span></span><br></pre></td></tr></table></figure>
<h4 id="755-聚合类"><a class="markdownIt-Anchor" href="#755-聚合类"></a> 7.5.5 聚合类</h4>
<ul>
<li>所有成员都是public的</li>
<li>没有定义任何构造函数</li>
<li>没有类内初始值</li>
<li>没有基类，也没有virtual函数</li>
</ul>
<h3 id="76-类的静态成员"><a class="markdownIt-Anchor" href="#76-类的静态成员"></a> 7.6 类的静态成员</h3>
<ul>
<li>
<p>static静态成员被所有类对象共享</p>
</li>
<li>
<p>静态成员函数不包含this指针，不能声明成const</p>
</li>
<li>
<p>在类外定义时不能重复static关键字</p>
</li>
<li>
<p>静态成员可以作为默认实参</p>
</li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>C++ Primer</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 异常处理</title>
    <url>/2020/01/11/C++/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-异常处理"><a class="markdownIt-Anchor" href="#第七章-异常处理"></a> 第七章 异常处理</h2>
<h3 id="71-抛出异常"><a class="markdownIt-Anchor" href="#71-抛出异常"></a> 7.1 抛出异常</h3>
<a id="more"></a>
<ol>
<li>两个成分
<ul>
<li>异常的鉴定与发出</li>
<li>异常的处理方式</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator_overflow</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iterator_overflow(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="built_in">max</span>)</span><br><span class="line">    : _index(index), _max(<span class="built_in">max</span>) &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _index;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _max;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">what_happened</span><span class="params">(ostream &amp;os = <span class="built_in">cerr</span>)</span> </span>&#123;</span><br><span class="line">        os &lt;&lt; <span class="string">"Internal error : current index "</span></span><br><span class="line">            &lt;&lt; _index &lt;&lt; <span class="string">" exceds maximun bound: "</span></span><br><span class="line">            &lt;&lt; _max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> _index;</span><br><span class="line">    <span class="keyword">int</span> _max;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="keyword">if</span>(_index &gt; Triangular::max_elems) &#123;</span><br><span class="line">    <span class="function">iterator_overflow <span class="title">ex</span><span class="params">(_index, Triangular::_max_elems)</span></span>;</span><br><span class="line">    <span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="72-捕获异常"><a class="markdownIt-Anchor" href="#72-捕获异常"></a> 7.2 捕获异常</h3>
<h4 id="721-catch"><a class="markdownIt-Anchor" href="#721-catch"></a> 7.2.1 catch</h4>
<p>​	1. catch由3个部分组成，关键字catch、小括号内的一个类型或对象、大括号内的一组语句。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">log_message</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="built_in">string</span> err_messages[];</span><br><span class="line"><span class="keyword">extern</span> ostream log_file;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">some_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> status = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">int</span> errno) &#123;</span><br><span class="line">        log_message(err_messages[errno]);</span><br><span class="line">        status = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(<span class="keyword">const</span> <span class="keyword">char</span>* str) &#123;</span><br><span class="line">        log_message(str);</span><br><span class="line">        status = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(iterator_overflow &amp;iof) &#123;</span><br><span class="line">		iof.what_happened(log_file);	</span><br><span class="line">        status = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>异常对象的类型会被拿来逐一地和每个catch子句比对。如果类型符合，那么该catch子句的内容便会被执行。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="number">42</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">"panic: no buffer!"</span>;</span><br><span class="line"><span class="keyword">throw</span> iterator_overflow(_index, Triangularr::_max_elems);</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>无法完成异常的完整处理时，或许需要重新抛出异常</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(iterator_overflow &amp;iof) &#123;</span><br><span class="line">	log_message(iof.what_happened());</span><br><span class="line">    <span class="comment">// 重新抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		**重新抛出时，只需写下关键字throw即可。**它只能出现于catch子句中。</p>
<ol start="4">
<li>
<p>catch-all</p>
<p>异常声明部分指定省略号</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 捕获任何类型的异常</span></span><br><span class="line"><span class="keyword">catch</span>(…) &#123;</span><br><span class="line">    log_message(<span class="string">"exception of unknown type"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="73-提炼异常"><a class="markdownIt-Anchor" href="#73-提炼异常"></a> 7.3 提炼异常</h3>
<h4 id="731-try"><a class="markdownIt-Anchor" href="#731-try"></a> 7.3.1 try</h4>
<p>​		catch子句放在try块的末尾，表示如果try块内由任何异常发生，便由接下来的catch子句加以处理。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">has_elem</span><span class="params">(Triangular_iterator first, </span></span></span><br><span class="line"><span class="function"><span class="params">             Triangular_iterator last, <span class="keyword">int</span> elem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> status = <span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span> (first != last) &#123;</span><br><span class="line">            <span class="keyword">if</span>(*first == elem)</span><br><span class="line">                <span class="keyword">return</span> status;</span><br><span class="line">            ++first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 只捕获其中类型为iterator_overflow的异常。</span></span><br><span class="line">    <span class="keyword">catch</span>(iterator_overflow &amp;iof) </span><br><span class="line">    &#123;</span><br><span class="line">        log_message(iof.what_happened());</span><br><span class="line">        log_message(<span class="string">"check if iterators address same container"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    status = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> status;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>first的提领操作和递增操作属于has_elem()的实现细节，而iterator_overflow是该实现内容的一个方面。把异常限定在has_elem()内部，因为has_elem()对于这一异常在程序执行过程中的重要性是最清楚的。</p>
</li>
<li>
<p>其中的表达式 *first 会调用被重载的dereference运算符</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">int</span> Triangular_iterator::<span class="keyword">operator</span>*() </span><br><span class="line">&#123;</span><br><span class="line">	check_integrity();</span><br><span class="line">    <span class="keyword">return</span> Triangular::_elems[_index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续内调check_integrity();</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">Triangular_iterator::check_integrity</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(_index &gt;= Triangular::_max_elems)</span><br><span class="line">        <span class="keyword">throw</span> iterator_overflow(_index, Triangular::_max_elems);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>throw表达式并非位于try块内，check_integrity()的剩余内容不会被执行，异常处理机制终结了check_integrity()的执行权。</p>
</li>
<li>
<p>异常处理会沿着“函数调用链”找合适的catch子句，如果在main()内还是找不到合适的处理程序，就调用标准库提供的terminate()，中断整个程序的执行。</p>
</li>
</ol>
<h3 id="74-局部资源管理"><a class="markdownIt-Anchor" href="#74-局部资源管理"></a> 7.4 局部资源管理</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> Mutex m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> *p = <span class="keyword">new</span> <span class="keyword">int</span>;</span><br><span class="line">    m.acquire();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">process</span>(p);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 释放资源</span></span><br><span class="line">	m.<span class="built_in">release</span>();</span><br><span class="line">    <span class="keyword">delete</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		如果process()内抛出异常，那么process()调用操作之后的两条用以释放资源的语句便不会被执行。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一种效率较低的解决方法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 和先前一样</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span>(...) &#123;</span><br><span class="line">        m.<span class="built_in">release</span>();</span><br><span class="line">        <span class="keyword">delete</span> p;</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="741-资源管理"><a class="markdownIt-Anchor" href="#741-资源管理"></a> 7.4.1 资源管理</h4>
<ol>
<li>
<p>resource acquisition in initialization</p>
<p>在初始化阶段即进行资源请求</p>
<p>对对象而言，初始化操作、资源的请求发生于constructor内，资源的释放在destructor内完成。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记得加头文件memory</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> <span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function">MutexLock <span class="title">m1</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">process</span>(p);</span><br><span class="line">    <span class="comment">// p和m1的destructor会在此处被悄悄调用……</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>在异常处理机制终结某个函数之前，函数中的所有局部对象的destructor都会被调用。</p>
</li>
<li>
<p>auto_ptr是标准库提供的class template，它会自动删除通过new表达式分配的对象。</p>
</li>
<li>
<p>auto_ptr将dereference运算符和arrow运算符予以重载，可以像使用一般指针一样使用auto_ptr对象。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="function"><span class="built_in">auto_ptr</span>&lt;<span class="built_in">string</span>&gt; <span class="title">aps</span><span class="params">(<span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"vermeer"</span>))</span></span>;</span><br><span class="line"><span class="built_in">string</span> *ps = <span class="keyword">new</span> <span class="built_in">string</span>(<span class="string">"vermeer"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>((aps-&gt;<span class="built_in">size</span>() == ps-&gt;<span class="built_in">size</span>()) &amp;&amp; (*aps == *ps))</span><br><span class="line">    <span class="comment">// ...</span></span><br></pre></td></tr></table></figure>
<h3 id="75-标准异常"><a class="markdownIt-Anchor" href="#75-标准异常"></a> 7.5 标准异常</h3>
<h4 id="751-bad_alloc"><a class="markdownIt-Anchor" href="#751-bad_alloc"></a> 7.5.1 bad_alloc</h4>
<p>​		如果new表达式无法从程序的空闲空间分配到足够的内存，它会抛出 bad_alloc 异常对象</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;*</span><br><span class="line">init_text_vector(ifstream &amp;infile)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; *ptext = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ptext = <span class="keyword">new</span> <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;;</span><br><span class="line">        <span class="comment">// 打开file和file vector</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// bad_alloc是个class，不是一个object。</span></span><br><span class="line">    <span class="keyword">catch</span>(bad_alloc) &#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">"ouch. heap memory exhausted\n"</span>;</span><br><span class="line">        <span class="comment">// ……清理并退出</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptext;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		也可以抑制不让bad_alloc异常被抛出：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ptext = <span class="keyword">new</span> (nothrow) <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;;</span><br></pre></td></tr></table></figure>
<p>​		如果new操作失败，会返回0。</p>
<h4 id="752-exception-class-hierarchy"><a class="markdownIt-Anchor" href="#752-exception-class-hierarchy"></a> 7.5.2 exception class hierarchy</h4>
<ol>
<li>
<p>exception声明有一个what()虚函数，会返回一个const char*，用以表示被抛出异常的文字描述。</p>
</li>
<li>
<p>bad_alloc派生自exception基类，它有自己的what()。</p>
</li>
<li>
<p>将自己编写的iterator_overflow继承于exception基类之下。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件exception</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">iterator_overflow</span> :</span> <span class="keyword">public</span> exception &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	iterator_overflow(<span class="keyword">int</span> index, <span class="keyword">int</span> <span class="built_in">max</span>)</span><br><span class="line">        : _index(index), _max(<span class="built_in">max</span>)</span><br><span class="line">    &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">index</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _index; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _max; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// overrides exception::what()</span></span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">    <span class="keyword">int</span> _max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​		catch子句会捕捉exception的所有派生类。当bad_alloc异常被抛出，它会打印出“bad allocation”信息。当iterator_overflow异常被抛出，它会打印出“Internal error: current index exceeds maximum bound: 64”信息。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">catch</span>(<span class="keyword">const</span> excption &amp;ex)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">cerr</span> &lt;&lt; ex.what() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​		iterator_overflow的what()，其中运用ostringstream对象对输出信息进行了格式化:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;sstream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line"></span><br><span class="line">const char* </span><br><span class="line">iterator_overflow::</span><br><span class="line">what() const </span><br><span class="line">&#123;</span><br><span class="line">	ostringstream ex_msg;</span><br><span class="line">	static string msg;</span><br><span class="line">	</span><br><span class="line">	&#x2F;&#x2F; 将输出信息写到内存内的ostringstream对象之中。</span><br><span class="line">	&#x2F;&#x2F; 将整数值转为字符串表示……</span><br><span class="line">	</span><br><span class="line">	ex_msg &lt;&lt; &quot;Internal error: current index &quot;</span><br><span class="line">    	   &lt;&lt; _index &lt;&lt; &quot; exceeds maximum bound: &quot;</span><br><span class="line">    	   &lt;&lt; _max;</span><br><span class="line">    	   </span><br><span class="line">   	&#x2F;&#x2F; 萃取出string对象</span><br><span class="line">   	msg &#x3D; ex_msg.str();</span><br><span class="line">   	</span><br><span class="line">   	&#x2F;&#x2F; 萃取出const char*表达式</span><br><span class="line">   	return msg.c_str();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>ostringstream class 提供“内存内的输出操作”，输出到一个string对象上。可以将多笔不同类型的数据格式化为字符串。str()会将“与ostringstream对象相呼应”的那个string对象返回。</p>
</li>
<li>
<p>转换函数c_str()会返回一个const char*。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Essential C++</tag>
      </tags>
  </entry>
  <entry>
    <title>第五章 面向对象编程风格</title>
    <url>/2020/01/03/C++/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第五章-面向对象编程风格"><a class="markdownIt-Anchor" href="#第五章-面向对象编程风格"></a> 第五章 面向对象编程风格</h2>
<h3 id="51-面向对象编程"><a class="markdownIt-Anchor" href="#51-面向对象编程"></a> 5.1 面向对象编程</h3>
<p>继承(inheritance)和多态(polymorphism)</p>
<a id="more"></a>
<h4 id="511-继承"><a class="markdownIt-Anchor" href="#511-继承"></a> 5.1.1 继承</h4>
<ol>
<li>将一群相关的类组织起来，并得以分享其间的共同数据和操作行为</li>
<li>继承机制定义了父子(parent/child)关系。父类定义了所有子类共通的共有接口(public interface)和私有实现(private implementation)。每个子类都可以增加或覆盖(override)继承而来的东西，以实现其自身独特的行为。</li>
<li>父类被称为基类(base class)，子类被称为派生类（derived class)。父类和子类之间的关系称为继承体系(inheritance hierarchy)。</li>
<li>抽象基类(abstract base class)</li>
</ol>
<p><img src="https://i.loli.net/2019/12/28/R7Eocdzm8PVCbIY.png" alt="image-20191228203438372.png" /></p>
<h4 id="512-多态"><a class="markdownIt-Anchor" href="#512-多态"></a> 5.1.2 多态</h4>
<p>在这些类上进行编程时，可以如同操控单一个体，而非相互独立的类、并赋予我们更多弹性来加入或移除任何特定类。</p>
<h4 id="513-动态绑定dynamic-binding"><a class="markdownIt-Anchor" href="#513-动态绑定dynamic-binding"></a> 5.1.3 动态绑定(dynamic binding)</h4>
<p>实际执行起来的操作要等到运行时，根据pointer或reference所指的实际对象的类型才能决定。</p>
<h3 id="52-面向对象编程思维"><a class="markdownIt-Anchor" href="#52-面向对象编程思维"></a> 5.2 面向对象编程思维</h3>
<h4 id="521-virtual"><a class="markdownIt-Anchor" href="#521-virtual"></a> 5.2.1 virtual</h4>
<p>默认情形下，member function的解析(resolution)皆在编译时静态地进行。若要令其在运动时动态进行，我们就得在他的声明前加上关键字virtual。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LibMat</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LibMat() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"LibMat::LibMat() default constructor!\n"</span>;&#125;</span><br><span class="line">    <span class="keyword">virtual</span> ~LibMat() &#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"LibMat::~LibMat() destructor!\n"</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"LibMat::print() -- I am a LibMat object!\n"</span>;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在定义一个non-member function print()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> LibMat &amp;mat)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"in global print(): about to print mat.print()\n"</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 下一行会根据mat实际指向的对象。</span></span><br><span class="line">    <span class="comment">// 解析该执行哪一个print()member function。</span></span><br><span class="line">	mat.<span class="built_in">print</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="522-派生类"><a class="markdownIt-Anchor" href="#522-派生类"></a> 5.2.2 派生类</h4>
<p>名称之后必须接一个冒号(😃，然后紧跟着关键字public和基类的名称</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span> :</span> <span class="keyword">public</span> LibMat &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Book(<span class="keyword">const</span> <span class="built_in">string</span> &amp;title, <span class="keyword">const</span> <span class="built_in">string</span> &amp;author)</span><br><span class="line">        : _title(title), _author(author) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">"BookLLBook( "</span> &lt;&lt; _title</span><br><span class="line">                 &lt;&lt; <span class="string">", "</span> &lt;&lt; )author &lt;&lt; <span class="string">") consturctor\n"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">virtual</span> ~Book() &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Book::~Book() destructor!\n"</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> voud <span class="title">print</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">"Book::print() -- I am a Book object!\n"</span></span><br><span class="line">             &lt;&lt; <span class="string">"My title is: "</span> &lt;&lt; _title &lt;&lt; <span class="string">'\n'</span></span><br><span class="line">             &lt;&lt; <span class="string">"My author is: "</span> &lt;&lt; _author &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">title</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _title;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="built_in">string</span>&amp; <span class="title">author</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _author;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="built_in">string</span> _title;</span><br><span class="line">    <span class="built_in">string</span> _author;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>Book中的print()覆盖(override)了LibMat的print()。</p>
</li>
<li>
<p>声明为protected的所有成员都可以被派生类直接访问，除此之外，都不得直接访问protected成员。</p>
</li>
<li>
<p>使用派生类时不必刻意区分&quot;继承而来的成员&quot;和&quot;自身定义的成员&quot;。两者的使用完全透明</p>
</li>
</ol>
<h3 id="53-不带继承的多态"><a class="markdownIt-Anchor" href="#53-不带继承的多态"></a> 5.3 不带继承的多态</h3>
<h3 id="54-抽象基类"><a class="markdownIt-Anchor" href="#54-抽象基类"></a> 5.4 抽象基类</h3>
<ol>
<li>定义抽象类的第一个步骤是找出所有子类共通的操作行为。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// elem(pos): 返回pos位置上的元素</span></span><br><span class="line">    <span class="comment">// gen_elems(pos): 产生直到pos位置的所有元素</span></span><br><span class="line">    <span class="comment">// what_am_i(): 返回确切的数列类型</span></span><br><span class="line">	<span class="comment">// print(os): 将所有元素写入os</span></span><br><span class="line">    <span class="comment">// check_integrity(pos): 检查pos是否为有效位置</span></span><br><span class="line">    <span class="comment">// max_elems(): 返回所支持的最大位置值</span></span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">elem</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what_am_i</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function">ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os = <span class="built_in">cout</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">check_integrity</span><span class="params">(<span class="keyword">int</span> pos)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max_elems</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>设计抽象基类的下一步，是设法找出哪些操作行为与类型相关(type-dependent)——也就是说，有哪些操作行为必须根据不同的派生类而有不同的实现方式。这些操作行为应该成为整个类继承体系中的virtual function。</p>
<ul>
<li>如gen_elems()</li>
<li>static member function无法被声明为虚函数。</li>
</ul>
</li>
<li>
<p>设计抽象基类的第三步，是试着找出每个操作行为的访问层级(access level)。</p>
<ul>
<li>
<p>即使是该基类的派生类，亦无法访问基类中的private member。</p>
</li>
<li>
<p>protected访问层级可以让派生类访问</p>
</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">virtual</span> ~num_sequence() &#123;&#125;;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">elem</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what_am_i</span><span class="params">()</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">max_elems</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _max_elems;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os = <span class="built_in">cout</span>)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> check <span class="title">integrity</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">static</span> <span class="keyword">int</span> _max_elems = <span class="number">1024</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>​		如果对于该类而言，这个虚函数并无实质意义的话，可设为纯虚函数，即赋值为0。</p>
<p>​		任何类如果声明有纯虚函数，那么由于其接口的不完整性，程序无法为它产生任何对象。这种类只能作为派生类的子对象使用，而且前提是这些派生类必须为所有虚函数提供确切的定义。</p>
<p>​		凡基类定义有虚函数，应该要将其destructor声明为virtual。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence *ps = <span class="keyword">new</span> Fibonacci(<span class="number">12</span>);</span><br><span class="line"><span class="comment">// ...使用数列</span></span><br><span class="line"><span class="keyword">delete</span> ps;</span><br></pre></td></tr></table></figure>
<p>​		ps是基类num_sequence的指针，但它实际上指向派生类Fibonacci的对象。当delete表达式被应用于该指针，destructor会先应用与指针所指的对象身上，所以通过ps调用的destructor一定是Fibonacci的destructor，不是num_sequence的destructor。</p>
<h3 id="55-定义一个派生类"><a class="markdownIt-Anchor" href="#55-定义一个派生类"></a> 5.5 定义一个派生类</h3>
<ol>
<li>派生类由两部分组成：以是基类构成的子对象，二是派生类的部分。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 头文件"num_sequence.h"含有基类的定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"num_sequence.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> :</span> <span class="keyword">public</span> num_sequence &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>派生类必须为从基类继承而来的每个纯虚函数提供对应的实现。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> :</span> <span class="keyword">public</span> num_sequence &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Fibonacci(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> leg_pos = <span class="number">1</span>)</span><br><span class="line">        : _length(len), _beg_pos(beg_pos)&#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">int</span> <span class="title">elem</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what_am_i</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> <span class="string">"Fibonacci"</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> ostream&amp; <span class="title">print</span><span class="params">(ostream &amp;os = <span class="built_in">cout</span>)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _length;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">beg_pos</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _beg_pos;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">gen_elems</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在类之外对虚函数进行定义时，不必指明关键字virtual</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Fibonacci::elem</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!check_integrity(pos))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(pos &gt; _elems.<span class="built_in">size</span>())</span><br><span class="line">        <span class="comment">// 需求明确，不必等到运行时才解析</span></span><br><span class="line">        Fibonacci::gen_elems(pos);</span><br><span class="line">    <span class="keyword">return</span> _elems[pos - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="56-运用继承体系"><a class="markdownIt-Anchor" href="#56-运用继承体系"></a> 5.6 运用继承体系</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">(ostream &amp;os, <span class="keyword">const</span> num_sequence &amp;ns, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"The element at position "</span></span><br><span class="line">        &lt;&lt; pos	&lt;&lt; <span class="string">" for the "</span></span><br><span class="line">        &lt;&lt; ns.what_am_i() &lt;&lt; <span class="string">" sequence is "</span></span><br><span class="line">        &lt;&lt; ns.elem(pos) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="57-基类该多抽象"><a class="markdownIt-Anchor" href="#57-基类该多抽象"></a> 5.7 基类该多抽象</h3>
<p>可以将所有派生类共有的实现内容剥离出来，移至基类内。</p>
<h3 id="58-初始化-析构-复制"><a class="markdownIt-Anchor" href="#58-初始化-析构-复制"></a> 5.8 初始化、析构、复制</h3>
<h4 id="581-初始化"><a class="markdownIt-Anchor" href="#581-初始化"></a> 5.8.1 初始化</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> Fibonacci:;</span><br><span class="line">Fibonacci(<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos)</span><br><span class="line">    : num_sequence(len, beg_pos, elems)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line">num_sequence::</span><br><span class="line">num_sequence(<span class="keyword">int</span> len=<span class="number">1</span>, <span class="keyword">int</span> bp=<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; *pe=<span class="number">0</span>)</span><br><span class="line">    : _length(len), _beg_pos(bp), _pelems(pe)&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>如果派生类的constructor未能明确指出调用基类的哪一个constructor，编译器便会自动调用基类的default constructor.</p>
<h4 id="582-copy"><a class="markdownIt-Anchor" href="#582-copy"></a> 5.8.2 copy</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="function">Fibonacci <span class="title">fib</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br><span class="line">    Fibonacci::Fibonacci(<span class="keyword">const</span> Fibonacci &amp;rhs)</span><br><span class="line">        :num_sequence(rhs)</span><br><span class="line">    &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.F</span>ibonacci fib2 = fib1;</span><br><span class="line">    Finobacci&amp; Fibonacci::</span><br><span class="line">    <span class="keyword">operator</span>=(<span class="keyword">const</span> Fibonacci &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">            num_sequence::<span class="keyword">operator</span> = (rhs);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="583-destructor"><a class="markdownIt-Anchor" href="#583-destructor"></a> 5.8.3 destructor</h4>
<h4 id="基类的destructor会在派生类的destructor结束之后被自动调用"><a class="markdownIt-Anchor" href="#基类的destructor会在派生类的destructor结束之后被自动调用"></a> 基类的destructor会在派生类的destructor结束之后被自动调用。</h4>
<h3 id="59-在派生类中定义虚函数"><a class="markdownIt-Anchor" href="#59-在派生类中定义虚函数"></a> 5.9 在派生类中定义虚函数</h3>
<ol>
<li>
<p>如果覆盖基类所提供的虚函数，那么派生类提供的新定义，其函数原型必须完全符合基类所声明的函数原型，包括：参数列表、返回类型、常量性。</p>
</li>
<li>
<p>exception</p>
<p>​	当基类的虚函数返回某个基类形式（通常是pointer或reference)时，派生类的同名函数便可以返回该基类所派生出来的类型。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 派生类的clone()函数可返回一个指针，</span></span><br><span class="line">    <span class="comment">// 指向num_sequence 的任何一个派生类</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> num_sequence *<span class="title">clone</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span> :</span> <span class="keyword">public</span> num_sequence &#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="comment">// 在派生类中，关键字virtual并非必要</span></span><br><span class="line">        <span class="function">Fibonacci *<span class="title">clone</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Fibonacci(*<span class="keyword">this</span>);&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="592-虚函数的静态解析"><a class="markdownIt-Anchor" href="#592-虚函数的静态解析"></a> 5.9.2 虚函数的静态解析</h4>
<ol>
<li>
<p>基类的constructor和destructor</p>
<p>当我们构造派生类对象时，基类的constructor会被先调用。此刻派生类中的data member 尚未初始化。如果调用派生类的那一份虚函数，它便有可能访问未经初始化的data member。</p>
</li>
<li>
<p>基类对象的pointer和reference</p>
<p>当我们为基类声明一个实际对象，同时也就分配出了足以容纳该实际对象的内存空间。如果稍后传入的却是个派生类对象，那就没有足够的内存放置派生类中的各个 data member。</p>
</li>
</ol>
<h3 id="510-类型鉴定机制"><a class="markdownIt-Anchor" href="#510-类型鉴定机制"></a> 5.10 类型鉴定机制</h3>
<h4 id="5101-rtti运算符"><a class="markdownIt-Anchor" href="#5101-rtti运算符"></a> 5.10.1 RTTI运算符</h4>
<p>运行时类型鉴定机制(Run-Time Type Identification)</p>
<ol>
<li>
<p>typeid运算符</p>
<p>它让我们得以查询多态化的 class pointer 或 class reference，获得其所指对象的实际类型。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;typeinfo&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">const</span> <span class="keyword">char</span>* num_sequence::</span><br><span class="line">what_am_i() <span class="keyword">const</span> </span><br><span class="line">	&#123; <span class="keyword">return</span> <span class="keyword">typeid</span>(*<span class="keyword">this</span>).name();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等价判断</span></span><br><span class="line">num_sequence *ps = &amp;fib;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeid</span>(*ps) == <span class="keyword">typeid</span>(Fibonacci))</span><br></pre></td></tr></table></figure>
<p>使用typeid运算符之前，必须先包含头文件typeinfo。typeid运算符会返回一个type_info对象，储存着与类型相关的种种信息。</p>
<ol start="2">
<li>static_cast</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">num_sequence *ps = &amp;fib;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，虽然ps指向Fibonacci对象，</span></span><br><span class="line"><span class="comment">// 但ps并非一个Fibonacci指针</span></span><br><span class="line">ps-&gt;gen_elems(<span class="number">64</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 应为</span></span><br><span class="line">ps-&gt;Fibonacci::gen_elems(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>
<p>static_cast可以进行指针类型转换</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="keyword">typeid</span>(*ps) == <span class="keyword">typeid</span>(Fibonacci))</span><br><span class="line">&#123;	</span><br><span class="line">    <span class="comment">// 无条件转化</span></span><br><span class="line">    Fibonacci *pf = <span class="keyword">static_cast</span>&lt;Fibonacci*&gt;(ps); </span><br><span class="line">    ps-&gt;gen_elems(<span class="number">64</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>dynamic_cast</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 有条件转化</span></span><br><span class="line"><span class="keyword">if</span>(Fibonacci *pf = <span class="keyword">dynamic_cast</span>&lt;Fibonacci*&gt;(ps))</span><br><span class="line">    pf-&gt;gen_elems(<span class="number">64</span>);</span><br></pre></td></tr></table></figure>
<p>会进行运行时检验，检验ps所指对象是否属于Fibonacci类，如果不是则返回0。</p>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Essential C++</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 基于对象的编程</title>
    <url>/2019/12/28/C++/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第四章-基于对象的编程"><a class="markdownIt-Anchor" href="#第四章-基于对象的编程"></a> 第四章 基于对象的编程</h2>
<h3 id="41-class"><a class="markdownIt-Anchor" href="#41-class"></a> 4.1 Class</h3>
<a id="more"></a>
<h4 id="411-定义"><a class="markdownIt-Anchor" href="#411-定义"></a> 4.1.1 定义</h4>
<ol>
<li>声明 + 主体</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">calss Stack &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...public接口</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// ...private的实现部分    </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>public member可以在程序的任何地方被访问</li>
<li>private member只能在member function 或是 friend 内被访问</li>
</ul>
<ol start="2">
<li>起始定义</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stack</span> &#123;</span></span><br><span class="line">piblic:</span><br><span class="line">    <span class="comment">// 任何操作函数如果执行成功，就返回true</span></span><br><span class="line">    <span class="comment">// pop和peek会将字符串内容置于elem内</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">push</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">pop</span><span class="params">(<span class="built_in">string</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">peek</span><span class="params">(<span class="built_in">string</span>&amp; elem)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">full</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//size()定义于class本身中，</span></span><br><span class="line">    <span class="comment">//其他member则仅仅只是声明。</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _stack.<span class="built_in">size</span>();&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; _stack;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果在class主体内定义，这个member function 会被自动地视为 inline 函数。</li>
</ul>
<h4 id="412-class-scope-resolution"><a class="markdownIt-Anchor" href="#412-class-scope-resolution"></a> 4.1.2 class scope resolution</h4>
<p>类作用域解析运算符</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> </span><br><span class="line">Stack::empty()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> _stack.empty();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//告诉编译器empty()是Stack class的一个member</span></span><br></pre></td></tr></table></figure>
<ul>
<li>全局作用域运算符也为::</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span> ch; <span class="comment">//全局变量</span></span><br><span class="line">　　<span class="keyword">void</span> sleep（）</span><br><span class="line">　　&#123;</span><br><span class="line">　　<span class="keyword">char</span> ch; <span class="comment">//局部变量</span></span><br><span class="line">　　ch(局部变量) = ch(局部变量) *ch(局部变量) ;</span><br><span class="line">　　::ch(全局变量) =::ch(全局变量) *ch(局部变量);</span><br><span class="line">　　&#125;</span><br></pre></td></tr></table></figure>
<h3 id="42-构造函数和析构函数"><a class="markdownIt-Anchor" href="#42-构造函数和析构函数"></a> 4.2 构造函数和析构函数</h3>
<h4 id="421-构造函数"><a class="markdownIt-Anchor" href="#421-构造函数"></a> 4.2.1 构造函数</h4>
<ol>
<li>constructor的函数名称必须与class名称相同，语法规定，constructor不应指定返回类型，亦不用返回任何值。它可以被重载。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 一组重载的constructor</span></span><br><span class="line">    Triangular();	<span class="comment">// default constructors</span></span><br><span class="line">    Triangular(<span class="keyword">int</span> len);</span><br><span class="line">    Triangular(<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos);</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _length;	<span class="comment">// 元素个数</span></span><br><span class="line">    <span class="keyword">int</span> _beg_pos;	<span class="comment">// 起始位置</span></span><br><span class="line">    <span class="keyword">int</span> _next;		<span class="comment">// 下一个迭代目标</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>class object定义出来后，编译器便自动根据获得的参数，挑选出应被调用的constructor。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Triangular t;</span><br><span class="line"><span class="function">Triangular <span class="title">t2</span><span class="params">(<span class="number">10</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line">Triangular t3 = <span class="number">8</span>;	<span class="comment">//调用constructor而非assignment operator</span></span><br><span class="line"></span><br><span class="line"><span class="function">Triangular <span class="title">t5</span><span class="params">()</span></span>;	<span class="comment">//错误的调用,t5被视为函数</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>default constructor</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">Triangular::Triangular()</span><br><span class="line">&#123;</span><br><span class="line">    _length = <span class="number">1</span>;</span><br><span class="line">    _beg_pos = <span class="number">1</span>;</span><br><span class="line">    _next = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>更常见</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//也是default constructor</span></span><br><span class="line">    Triangular(<span class="keyword">int</span> len = <span class="number">1</span>, <span class="keyword">int</span> bp = <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Triangular::Triangular(<span class="keyword">int</span> len, <span class="keyword">int</span> bp)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// _length和_beg_pos 都必须&gt;=1。</span></span><br><span class="line">    <span class="comment">// 最好不要相信“用户永远是对的”这句话:)</span></span><br><span class="line">    _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">    _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    _next = _beg_pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">由于提供了默认值，所以<span class="keyword">default</span> constructor同时支持原本的三个constructor</span><br><span class="line">    Triangular tri1;			<span class="comment">// (1, 1)</span></span><br><span class="line">	<span class="function">Triangular <span class="title">tri2</span><span class="params">(<span class="number">12</span>)</span></span>;		<span class="comment">// (12, 1)</span></span><br><span class="line">	<span class="function">Triangular <span class="title">tri3</span><span class="params">(<span class="number">8</span>, <span class="number">3</span>)</span></span>;		<span class="comment">// (8 ,3)</span></span><br></pre></td></tr></table></figure>
<h4 id="422-member-initialization-list"><a class="markdownIt-Anchor" href="#422-member-initialization-list"></a> 4.2.2 Member Initialization List</h4>
<p>成员初始化列表</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Triangular::Triangular(<span class="keyword">const</span> Triangular &amp;rhs)</span><br><span class="line">    : _length (rhs._length),</span><br><span class="line">	  _beg_pos (rhs._beg_pos), _next(rhs._beg_pos - <span class="number">1</span>)</span><br><span class="line">&#123; &#125;	<span class="comment">//空的</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">Triangular::Triangular(<span class="keyword">int</span> len, <span class="keyword">int</span> bp)</span><br><span class="line">	:_name(<span class="string">"Triangular"</span>)</span><br><span class="line">&#123;</span><br><span class="line">    _length = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">    _beg_pos = bp &gt; <span class="number">0</span> ? bp : <span class="number">1</span>;</span><br><span class="line">    _next = _beg_pos - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="423-析构函数"><a class="markdownIt-Anchor" href="#423-析构函数"></a> 4.2.3 析构函数</h4>
<ol>
<li>
<p>Destructor与constructor对立，主要用来释放在constructor中或对象生命周期中分配的资源。</p>
</li>
<li>
<p>Destructor的命名: <strong>class名称 + '~'前缀</strong>， 没有返回值和参数。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Matrix</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    Matrix(<span class="keyword">int</span> row, <span class="keyword">int</span> col)</span><br><span class="line">        :_row(row), _col(col)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// constructor进行资源的分配。</span></span><br><span class="line">        <span class="comment">// 注意: 此处未检查成功与否。</span></span><br><span class="line">        _pmat = <span class="keyword">new</span> <span class="keyword">double</span>[row * col];</span><br><span class="line">     &#125;</span><br><span class="line">    ~Matrix()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// destructor进行资源的释放。</span></span><br><span class="line">        <span class="keyword">delete</span> [] _pmat;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> 	_row, _col;</span><br><span class="line">    <span class="keyword">double</span>* _pmat;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">mat</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<p>编译器会在mat被定义出来后，应用constructor, 初始化_pmat语句结束之前，又会调用destructor释放_pmat</p>
<h4 id="424-memberwise-initialization"><a class="markdownIt-Anchor" href="#424-memberwise-initialization"></a> 4.2.4 Memberwise Initialization</h4>
<p>成员逐一初始化</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//此为default memberwise initialization</span></span><br><span class="line">Matrix mat2 = mat;</span><br></pre></td></tr></table></figure>
<p>会复制所有的data member, <strong>包括指针！！</strong></p>
<p>copy constructor</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix::Matrix(<span class="keyword">const</span> Matrix &amp;rhs) </span><br><span class="line">    :_row(rhs._row), _col(rhs,_col) </span><br><span class="line">&#123;	<span class="comment">// 对rhs._pmat所指的数组产生一份完全复本</span></span><br><span class="line">    <span class="keyword">int</span> elem_cnt = _row * _col;</span><br><span class="line">    _pmat = <span class="keyword">new</span> <span class="keyword">double</span>[elem_cnt];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> ix = <span class="number">0</span>; ix &lt; elem_cnt; ++ix) </span><br><span class="line">        _pmat[ix] = rhs._pmat[ix];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="43-mutable-和-const"><a class="markdownIt-Anchor" href="#43-mutable-和-const"></a> 4.3 mutable 和 const</h3>
<h4 id="431-const"><a class="markdownIt-Anchor" href="#431-const"></a> 4.3.1 const</h4>
<ol>
<li>class设计者必须在member function 身上标注 const，以此告诉编译器：这个member function 不会更改 class object 的内容：</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">length</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _length;&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>凡是在class主体以外定义者，必须同时在声明与定义中指定const。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Triangular::elem</span><span class="params">(<span class="keyword">int</span> pos)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">	</span>&#123;<span class="keyword">return</span> _elems[pos - <span class="number">1</span>];&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2019/12/28/ZyA7oWnCdLfavci.png" alt="image-20191228093958479.png" /></p>
<h4 id="432-mutable-data-member"><a class="markdownIt-Anchor" href="#432-mutable-data-member"></a> 4.3.2 mutable Data Member</h4>
<ol>
<li>在const member function中想要改变data member的值，需要把data member声明为mutable</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> &amp;val)</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">next_reset</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; _next=_beg_pos <span class="number">-1</span>;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">mutable</span> <span class="keyword">int</span> _next;</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对trian迭代</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="keyword">const</span> Triangular &amp;trian)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!trian.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> val, sum = <span class="number">0</span>;</span><br><span class="line">    trian.next_reset();</span><br><span class="line">    <span class="keyword">while</span> (trian.next(val))</span><br><span class="line">        sum += val;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样next()和next_reset()既可以修改_next的值，又可以被声明为const member function。</p>
<h3 id="44-this-指针"><a class="markdownIt-Anchor" href="#44-this-指针"></a> 4.4 this 指针</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//tr1不仅是复制的目标，也是接受结果的对象</span></span><br><span class="line">Triangular tr1(8), tr2(8, 9);</span><br><span class="line">tr1.copy(tr2);</span><br></pre></td></tr></table></figure>
<p>this指针在member function内用来指向其调用者</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Triangular&amp; <span class="title">Triangular::copy</span><span class="params">(Triangular *<span class="keyword">this</span>, <span class="keyword">const</span> Triangular &amp;rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>-&gt;_length = rhs._length;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">copy(&amp;tr1, tr2);</span><br></pre></td></tr></table></figure>
<h3 id="45-静态类成员"><a class="markdownIt-Anchor" href="#45-静态类成员"></a> 4.5 静态类成员</h3>
<ol>
<li>Static Member Data
<ul>
<li>static data member用来表示唯一的、可共享的member，它可以在同一类的所有对象中被访问。</li>
</ul>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> <span class="keyword">static</span> data member只有唯一的一份实体，必须在程序代码文件中提供清楚的定义。</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; Triangular::_elems;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Static Member Function</li>
</ol>
<p>member function只有在“不访问任何non-static member”的条件下才能被声明为static</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">is_elem</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> _max_elems = <span class="number">1024</span>;</span><br><span class="line">    <span class="keyword">int</span> _buffer[_buf_size];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在class主体外部进行member function定义时，无须加上static</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Triangular::is_elem</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//static可以在"与任何对象都无瓜葛"的情形之下被调用。</span></span><br><span class="line">Triangular::is_elem(<span class="number">8</span>);</span><br><span class="line"><span class="comment">//而不是tr1.is_elem(8);</span></span><br></pre></td></tr></table></figure>
<h3 id="46-iterator-class"><a class="markdownIt-Anchor" href="#46-iterator-class"></a> 4.6 Iterator Class</h3>
<h4 id="461-运算符函数"><a class="markdownIt-Anchor" href="#461-运算符函数"></a> 4.6.1 运算符函数</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="comment">// 为了不要在每次访问元素时都执行-1操作，</span></span><br><span class="line"><span class="comment">// 此处将_index的值设为index-1</span></span><br><span class="line">    Triangular_iterator(<span class="keyword">int</span> index) : _index(index - <span class="number">1</span>)&#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> oerator==(<span class="keyword">const</span> Triangular_iterator&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">bool</span> oerator!=(<span class="keyword">const</span> Triangular_iterator&amp;) <span class="keyword">const</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">operator</span>*() <span class="keyword">const</span>;</span><br><span class="line">    Triangular_iterator&amp; <span class="keyword">operator</span>++();	<span class="comment">// 前置(prefix)版</span></span><br><span class="line">    Triangular_iterator <span class="keyword">operator</span>++(<span class="keyword">int</span>);<span class="comment">// 后置(postfix)版</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">check_integrity</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">    <span class="keyword">int</span> _index;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"Triangular_iterator.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 以下这么做， 可以让用户不必知晓iterator class的实际名称</span></span><br><span class="line">    <span class="keyword">typedef</span> Triangular_iterator iterator;</span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">begin</span><span class="params">()</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Triangular_iterator(_beg_pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Triangular_iterator <span class="title">end</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Triangular_iterator(_beg_pos + _length);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _beg_pos;</span><br><span class="line">    <span class="keyword">int</span> _length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="462-嵌套类型nested-type"><a class="markdownIt-Anchor" href="#462-嵌套类型nested-type"></a> 4.6.2 嵌套类型(Nested Type)</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Triangular::iterator it = trian.<span class="built_in">begin</span>();</span><br></pre></td></tr></table></figure>
<p>使用class scope运算符来指引编译器，让它在面对iterator这个字眼时，查看Triangular内部提供的定义。</p>
<h3 id="47-friendship"><a class="markdownIt-Anchor" href="#47-friendship"></a> 4.7 Friendship</h3>
<ol>
<li>friend具备了与class member function相同的访问权限，可以访问class的private member。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span>&#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">int</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> Triangular_iterator &amp;rhs);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span> &#123;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">int</span> <span class="keyword">operator</span>*(<span class="keyword">const</span> Triangular_iterator &amp;rhs);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>只要在某个函数的原型前加上friend，就可以将它声明为某个class的friend。</p>
</li>
<li>
<p>也可令class A与class B建立friend关系</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Triangular</span> &#123;</span></span><br><span class="line">    <span class="comment">// 以下造成Triangular_iterator的所有member function</span></span><br><span class="line">    <span class="comment">// 都成为Triangular 的friend</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Triangular_iterator</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>可以用public member function来替代友谊的建立</li>
</ol>
<h3 id="48-copy-assignment-operator"><a class="markdownIt-Anchor" href="#48-copy-assignment-operator"></a> 4.8 copy assignment operator</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Matrix&amp; Matrix::</span><br><span class="line"><span class="keyword">operator</span>=(<span class="keyword">const</span> Matrix &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs)</span><br><span class="line">    &#123;</span><br><span class="line">        _row = rhs._row; _col = rhs._col;</span><br><span class="line">        <span class="keyword">int</span> elem+cnt = _row * _col;</span><br><span class="line">        <span class="keyword">delete</span> [] _pmat;</span><br><span class="line">        _pmat = <span class="keyword">new</span> <span class="keyword">double</span>[elem_cnt];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> ix = <span class="number">0</span>; ix &lt; elem_cnt; ++ix)</span><br><span class="line">            _pmat[ix] = rhs._pmat[ix];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="49-function-object"><a class="markdownIt-Anchor" href="#49-function-object"></a> 4.9 function object</h3>
<p>function object是一种&quot;提供有function call运算符&quot;的class</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">lt(ival) == lt.<span class="keyword">operator</span>(ival);	<span class="comment">// 内部转换结果</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LessThan(<span class="keyword">int</span> val ): _val(val) &#123;&#125;</span><br><span class="line">    <span class="keyword">int</span> comp+val()<span class="keyword">const</span> &#123;<span class="keyword">return</span> _val;&#125;	<span class="comment">// 基值的读取</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">comp_val</span><span class="params">(<span class="keyword">int</span> nval)</span> </span>&#123;_val = nval;&#125;	<span class="comment">// 基值的写入</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> _value)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> _val;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> LessThan::</span><br><span class="line"><span class="keyword">operator</span>()(<span class="keyword">int</span> value) <span class="keyword">const</span> &#123;<span class="keyword">return</span> value &lt; _val;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="410-重载iostream-运算符"><a class="markdownIt-Anchor" href="#410-重载iostream-运算符"></a> 4.10 重载iostream 运算符</h3>
<ol>
<li>ostream</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ostream&amp; <span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="keyword">const</span> Triangular &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"("</span> &lt;&lt; rhs.beg_pos() &lt;&lt; <span class="string">","</span></span><br><span class="line">       &lt;&lt; rhs.length()		   &lt;&lt;<span class="string">")"</span>;</span><br><span class="line">    </span><br><span class="line">    rhs.<span class="built_in">display</span>(rhs.length(), rhs.beg_pos(), os);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tri &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>istream</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">istream&amp; <span class="keyword">operator</span>&gt;&gt;(istream &amp;is, <span class="keyword">const</span> Triangular &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">char</span> ch1, ch2;</span><br><span class="line">    <span class="keyword">int</span> bp, len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 假设输入为(3, 6) 6 10 15 21 28 36</span></span><br><span class="line">    <span class="comment">// 那么ch1 == '(', bp == 3, ch2 == ',', len ==6。</span></span><br><span class="line">    is &gt;&gt; ch1 &gt;&gt; bp</span><br><span class="line">       &gt;&gt; ch2 &gt;&gt; len;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 设定rhs的三个data member……</span></span><br><span class="line">    rhs.beg_pos(bp);</span><br><span class="line">    rhs.length(len);</span><br><span class="line">    rhs.next_reset();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> is;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; tri &lt;&lt; <span class="string">'\n'</span>;</span><br></pre></td></tr></table></figure>
<h3 id="411-指向class-member-function-的指针"><a class="markdownIt-Anchor" href="#411-指向class-member-function-的指针"></a> 4.11 指向Class Member Function 的指针</h3>
<p>与pointer to non-member function相似，但还得指定它所指的是哪一个class</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (num_sequence::*pm)(<span class="keyword">int</span>) = <span class="number">0</span>;</span><br><span class="line"><span class="comment">//将pm声明为一个指针，指向num_sequence的member function。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//可以通过typedef简化</span></span><br><span class="line"><span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(num_sequence::*PtrType)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">PtrType pm = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span><span class="params">(num_sequence::*PtrType)</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// _pmf可指向下列任何一个函数</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pell</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lucas</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">triangular</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">sequare</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pentagonal</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    PtrType _pmf;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;* _elem;		<span class="comment">// 指向目前所用的vector</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> num_seq = <span class="number">7</span>;</span><br><span class="line">    <span class="keyword">static</span> PtrType func_tbl[num_seq];	<span class="comment">// 六个member function的地址</span></span><br><span class="line">    <span class="keyword">static</span> <span class="built_in">vector</span>&lt; <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; seq;	</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> num_sequence::num_seq;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; <span class="title">num_sequence::seq</span><span class="params">(num_seq)</span></span>;</span><br><span class="line"></span><br><span class="line">num_sequence::PtrType</span><br><span class="line">    num_sequence::func_tbl[num_seq] = </span><br><span class="line">	&#123;	<span class="number">0</span>,</span><br><span class="line">     	&amp;num_sequence::fibonacci,</span><br><span class="line">     	&amp;num_sequence::pell,</span><br><span class="line">     	&amp;num_sequence::lucas,</span><br><span class="line">     	&amp;num_sequence::triangular,</span><br><span class="line">     	&amp;num_sequence::sequare,</span><br><span class="line">     	&amp;num_sequence::pentagonal</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Essential C++</tag>
      </tags>
  </entry>
  <entry>
    <title>第六章 以template进行编程</title>
    <url>/2020/01/04/C++/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E4%BB%A5template%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-以template进行编程"><a class="markdownIt-Anchor" href="#第六章-以template进行编程"></a> 第六章 以template进行编程</h2>
<h3 id="60-binary-tree"><a class="markdownIt-Anchor" href="#60-binary-tree"></a> 6.0 Binary tree</h3>
<a id="more"></a>
<ul>
<li>
<p>tree由结点(node 或 vertice) 以及连接不同结点的链接(link)组成。</p>
</li>
<li>
<p>左子节点(left child)、右子节点(right child)，根节点(root)、叶结点(leaf)。</p>
</li>
<li>
<p>insert、remove、find、clear、print</p>
</li>
<li>
<p>包含两个class: BinaryTree储存一个指向根节点的指针，BTnode存储节点实值以及连接至左、右两个子节点的链接。</p>
</li>
<li>
<p>遍历</p>
<p><img src="https://i.loli.net/2020/01/04/k5HXq9MRjQbGNc6.png" alt="image-20200104231238849.png" /></p>
<ul>
<li>
<p>前序(preorder): 节点—&gt;左子树—&gt;右子树</p>
<p>Piglet, Eeyore, Chris, Kanga, Roo, Pooh, Tigger</p>
</li>
<li>
<p>中序(inorder): 左子树—&gt;节点—&gt;右子树</p>
<p>Chris, Eeyore, Kanga, Piglet, Pooh, Roo, Tigger</p>
</li>
<li>
<p>后序(postorder): 左子树—&gt;右子树—&gt;节点</p>
<p>Chris, Kanga, Eeyore,  Pooh, Tigger, Roo, Piglet</p>
</li>
</ul>
</li>
</ul>
<h3 id="61-被参数化的类型"><a class="markdownIt-Anchor" href="#61-被参数化的类型"></a> 6.1 被参数化的类型</h3>
<h4 id="611-template"><a class="markdownIt-Anchor" href="#611-template"></a> 6.1.1 template</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">string_BTnode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    valType _val;</span><br><span class="line">    <span class="keyword">int</span> _cnt;</span><br><span class="line">    string_BTnode *_lchild;</span><br><span class="line">    string_BTnode *_rchild;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>friend</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Type&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>;</span>	<span class="comment">// 前置声明</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BTnode</span> &#123;</span></span><br><span class="line">    <span class="comment">// 以下操作使得BinaryTree的全部member function都成为</span></span><br><span class="line">    <span class="comment">// BTnode的friend</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span>&lt;valType&gt;;</span></span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>实例化</p>
<p>将实际类型绑定至class template。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">BTnode&lt;<span class="keyword">int</span>&gt; bti;</span><br><span class="line">BTnode&lt;<span class="built_in">string</span>&gt; bts;</span><br><span class="line"><span class="comment">// “代入string而产生出来的BinaryTree”是“代入string所产生出来的BTnode”的friend，不是“代入int所产生出来的BTnode”的friend。</span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// BTnode必须以template parameter list加以限定</span></span><br><span class="line">    BTnode&lt;elemType&gt; *_root;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="62-class-template-的定义"><a class="markdownIt-Anchor" href="#62-class-template-的定义"></a> 6.2 Class Template 的定义</h3>
<ol>
<li></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    BinaryTree();</span><br><span class="line">    BinaryTree(<span class="keyword">const</span> BinaryTree&amp;);</span><br><span class="line">    ~BinaryTree();</span><br><span class="line">    BinaryTree&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> BinaryTree&amp;);</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> _root == <span class="number">0</span>;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    BTnode&lt;elemType&gt; *_root;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将src所指子树(subtree)复制到tar所指子树。</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">copy</span><span class="params">(BTnode&lt;elemType&gt;*tar, 		  			BTnode&lt;elemType&gt;*src)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>为class template定义一个inline函数，正常定义，如empty()。</p>
<p>但是在类体外，定义语法则不同。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> BinaryTree&lt;elemType&gt;::</span><br><span class="line">BinaryTree() : _root(<span class="number">0</span>) </span><br><span class="line">&#123;&#125;</span><br><span class="line"><span class="comment">// 在class scope运算符出现后，其后所有的东西</span></span><br><span class="line"><span class="comment">// 都被视为位于class定义范围内。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// copy constructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> BinaryTree&lt;elemType&gt;::</span><br><span class="line">BinaryTree(<span class="keyword">const</span> BinaryTree&amp; rhs)</span><br><span class="line">	&#123;copy(_root, rhs._root);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// destructor</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> BinaryTree&lt;elemType&gt;::</span><br><span class="line">~BinaryTree()</span><br><span class="line">	&#123;<span class="built_in">clear</span>();&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// copy assignment operator</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> BinaryTree&lt;elemType&gt;&amp;</span><br><span class="line">BinaryTree&lt;elemType&gt;::</span><br><span class="line"><span class="keyword">operator</span>=(<span class="keyword">const</span> BinaryTree &amp;rhs)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">this</span> != &amp;rhs) &#123;</span><br><span class="line">        <span class="built_in">clear</span>();</span><br><span class="line">        copy(_root, rhs._root);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-template-类型的参数"><a class="markdownIt-Anchor" href="#63-template-类型的参数"></a> 6.3 Template 类型的参数</h3>
<ol>
<li>constructor初始化</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">inline</span> BTnode&lt;valType&gt;::</span><br><span class="line">BTnode(<span class="keyword">const</span> valType &amp;val)</span><br><span class="line">    <span class="comment">// 将valType视为某种class类型</span></span><br><span class="line">    : _val(val)	<span class="comment">// 不建议在函数体内赋值，因为可能是class类型</span></span><br><span class="line">&#123;</span><br><span class="line">	_cnt = <span class="number">1</span>;</span><br><span class="line">        _lchild  = _rchild = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="64-实现class-template"><a class="markdownIt-Anchor" href="#64-实现class-template"></a> 6.4 实现Class Template</h3>
<h4 id="641-insert"><a class="markdownIt-Anchor" href="#641-insert"></a> 6.4.1 insert</h4>
<ol>
<li>insert</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">BinaryTree&lt;elemType&gt;::</span><br><span class="line">insert(<span class="keyword">const</span> elemType &amp;elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_root)</span><br><span class="line">        _root = <span class="keyword">new</span> BTnode&lt;elemType&gt;(elem);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        _root-&gt;insert_value(elem);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>insert_value</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">insert_value(<span class="keyword">const</span> valType &amp;val)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(val == _val) &#123;</span><br><span class="line">        _cnt++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(val &lt; _val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_lchild)</span><br><span class="line">            _lchild = <span class="keyword">new</span> BTnode(val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _lchild-&gt;insert_value(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_rchild)</span><br><span class="line">            _rchild = <span class="keyword">new</span> BTnode(val);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _rchild-&gt;insert_value(val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="642-remove"><a class="markdownIt-Anchor" href="#642-remove"></a> 6.4.2 remove</h4>
<p>以节点的右子节点取代节点本身，然后搬移左子节点，使它成为右子节点的左子树的叶节点。如果此刻并无右子节点，那么就以左子节点取代节点本身。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">BinaryTree&lt;elemType&gt;::</span><br><span class="line"><span class="built_in">remove</span>(<span class="keyword">const</span> elemType &amp;elem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(_root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(_root-&gt;val == elem)</span><br><span class="line">            remove_root();	<span class="comment">// 根节点的移除操作以特例处理</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            _root-&gt;remove_value(elem, _root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​	无论remove_root()或remove_value()，都会搬移左子节点，使它成为右子节点的左子树的叶结点。将操作剥离至lchild_leaf()</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">lchild_leaf(BTnode *leaf, BTnode *subtree)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(subtree-&gt;_lchild)</span><br><span class="line">        subtree = subtree-&gt;_lchild;</span><br><span class="line">    subtree-&gt;_lchild = leaf;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>remove_root</li>
</ol>
<p>如果根节点拥有任何子节点，remove_root()就会重设根节点。如果右子节点存在，就以右子节点取而代之；如果左子节点存在，就直接搬移，或通过lchild_leaf()完成。如果右子节点为null，_root便以左子节点取代。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;elemType&gt;::</span><br><span class="line">remove_root()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_root) </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    BTnode&lt;elemType&gt; *tmp = _root;</span><br><span class="line">    <span class="keyword">if</span>(_root-&gt;_rchild) &#123;</span><br><span class="line">        _root = _root-&gt;_rchild;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 好啦，现在我们必须将左子节点搬移到</span></span><br><span class="line">        <span class="comment">// 右子节点的左子树的底部</span></span><br><span class="line">        <span class="keyword">if</span>(tmp-&gt;_lchild) &#123;</span><br><span class="line">            <span class="comment">// 为了可读性，分解如下。</span></span><br><span class="line">            BTnode&lt;elemType&gt; *lc = tmp-&gt;_lchild;</span><br><span class="line">            BTnode&lt;elemType&gt; *newlc = _root-&gt;_lchild;</span><br><span class="line">            <span class="keyword">if</span>(!newlc)</span><br><span class="line">                <span class="comment">// 没有任何子树，那么就直接接上</span></span><br><span class="line">                _root-&gt;_lchild= lc;</span><br><span class="line">            <span class="comment">// lchild_leaf()会遍历整个左子树</span></span><br><span class="line">            <span class="comment">// 寻找某个可接上去的null左子节点。</span></span><br><span class="line">            <span class="comment">// lchild_leaf是个static member function。</span></span><br><span class="line">            <span class="keyword">else</span> BTnode&lt;elemType&gt;::lchild_leaf(lc,newlc);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> _root = _root-&gt;_lchild;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">delete</span> tmp;	<span class="comment">// ok：现在我们已移去先前的那个根节点了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>remove_value</p>
<p>remove_value()拥有两个参数，将被删除的值(如果存在的话)以及一个指针，指向目前关注的节点的父节点。</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">remove_value(<span class="keyword">const</span> valType &amp;val, BTnode *&amp; prev);</span><br></pre></td></tr></table></figure>
<p>​	两个参数皆以传址(by reference)方式传递，这是为了避免“当valType被指定为class类型时，因传值(by value)而产生的昂贵的复制开销”。</p>
<p>​	第二个参数用reference to pointer。如果以pointer传递，只能改变pointer所指之物，而不是pointer本身。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">remove_value(<span class="keyword">const</span> valType &amp;val, BTnode *&amp; prev)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(val &lt; _val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_lchild)</span><br><span class="line">            <span class="keyword">return</span>;	<span class="comment">// 不在此二叉树中</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            _lchild-&gt;remove_value(val, _lchild);</span><br><span class="line">        <span class="comment">// 指向下一个</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(val &gt; _val) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!_rchild)</span><br><span class="line">            <span class="keyword">return</span>;	<span class="comment">// 不在此二叉树中</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            _rchild-&gt;romove_value(val, _rchild);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// ok: 找到了</span></span><br><span class="line">        <span class="comment">// 重置此树，然后删除这一节点</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(_rchild) &#123;</span><br><span class="line">            prev = _rchild;</span><br><span class="line">            <span class="comment">// 如果根节点的左子节点存在</span></span><br><span class="line">            <span class="keyword">if</span>(_lchild)</span><br><span class="line">                <span class="comment">// 如果右子节点的左子树点不存在</span></span><br><span class="line">                <span class="keyword">if</span>(! prev-&gt;_lchild)</span><br><span class="line">                    <span class="comment">// 根节点的左子节点给右子节点</span></span><br><span class="line">                    prev-&gt;_lchild = _lchild;</span><br><span class="line">            	<span class="comment">// 如果右子节点的左子树存在</span></span><br><span class="line">            	<span class="keyword">else</span></span><br><span class="line">                    <span class="comment">// 转移到最左边的那一个</span></span><br><span class="line">                    BTnode&lt;valType&gt;::</span><br><span class="line">            		lchild_leaf(_lchild, prev-&gt;_lchild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> prev = _lchild;</span><br><span class="line">        <span class="keyword">delete</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="643-clear"><a class="markdownIt-Anchor" href="#643-clear"></a> 6.4.3 clear</h3>
<p>​	删除整棵二叉树。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BinaryTree</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(_root)</span><br><span class="line">            <span class="built_in">clear</span>(_root);</span><br><span class="line">        _root = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 重载版本</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">clear</span><span class="params">(BTnode&lt;elemType&gt;*)</span></span>;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>定义</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">void</span> BinaryTree&lt;elemType&gt;::</span><br><span class="line"><span class="built_in">clear</span>(BTnode&lt;elemType&gt; *pt)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pt) &#123;</span><br><span class="line">        <span class="built_in">clear</span>(pt-&gt;_lchild);</span><br><span class="line">        <span class="built_in">clear</span>(pt-&gt;_rchild);</span><br><span class="line">        <span class="keyword">delete</span> pt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="644-order"><a class="markdownIt-Anchor" href="#644-order"></a> 6.4.4 order</h3>
<p>​	三个算法的差别仅在于三个操作的执行顺序</p>
<ol>
<li>preorder</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">preorder(BTnode *pt, ostream &amp;os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pt) &#123;</span><br><span class="line">        display_val(pt, os);</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_lchild)</span><br><span class="line">            preorder(pt-&gt;_lchild, os);</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_rchild)</span><br><span class="line">            preorder(pt-&gt;_rchild, os);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>inorder</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">inorder(BTnode *pt, ostream &amp;os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_lchild)</span><br><span class="line">            preorder(pt-&gt;_lchild, os);</span><br><span class="line">        display_val(pt, os);</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_rchild)</span><br><span class="line">            preorder(pt-&gt;_rchild, os);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>postorder</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> valType&gt;</span><br><span class="line"><span class="keyword">void</span> BTnode&lt;valType&gt;::</span><br><span class="line">postorder(BTnode *pt, ostream &amp;os) <span class="keyword">const</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(pt) &#123;</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_lchild)</span><br><span class="line">            preorder(pt-&gt;_lchild, os);</span><br><span class="line">        <span class="keyword">if</span>(pt-&gt;_rchild)</span><br><span class="line">            preorder(pt-&gt;_rchild, os);</span><br><span class="line">         display_val(pt, os);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="65-output运算符"><a class="markdownIt-Anchor" href="#65-output运算符"></a> 6.5 output运算符</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// function template版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="keyword">inline</span> ostream&amp;</span><br><span class="line"><span class="keyword">operator</span>&lt;&lt;(ostream&amp; os, <span class="keyword">const</span> BinaryTree&lt;elemType&gt; &amp;bt)</span><br><span class="line">&#123;</span><br><span class="line">    os &lt;&lt; <span class="string">"Tree: "</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    bt.<span class="built_in">print</span>(os);</span><br><span class="line">    <span class="keyword">return</span> os;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="66-常量表达式与默认参数值"><a class="markdownIt-Anchor" href="#66-常量表达式与默认参数值"></a> 6.6 常量表达式与默认参数值</h3>
<ol>
<li>Template参数并不是非得已某种类型不可，也可以用常量表达式作为template参数。</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> len&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">num_sequence(<span class="keyword">int</span> beg_pos = <span class="number">1</span>);</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> len&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fibonacci</span>:</span><span class="keyword">public</span> num_sequence&lt;len&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Fibonacci(<span class="keyword">int</span> beg_pos = <span class="number">1</span>)</span><br><span class="line">    : num_sequence&lt;len&gt;(beg_pos)&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>默认值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">num_sequence</span>&#123;</span> ... &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos = <span class="number">1</span>&gt;</span><br><span class="line">class Fibonacci:<span class="keyword">public</span> num_sequence&lt;len,beg_pos&gt;</span><br><span class="line">&#123; ... &#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">例：</span><br><span class="line">    <span class="comment">// 下面这行会被展开为</span></span><br><span class="line">    <span class="comment">// num_sequence&lt;32,1&gt; *pnslto32 = new Fibonacci&lt;32,1&gt;;</span></span><br><span class="line">    num_seuquence&lt;<span class="number">32</span>&gt; *pnslto32 = <span class="keyword">new</span> Fibonacci&lt;<span class="number">32</span>&gt;;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>地址也是一种常量表达式</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">void</span> (*pf)(<span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;seq)&gt;	<span class="comment">// 函数指针</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">numeric_sequence</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	numeric_sequence(<span class="keyword">int</span> len, <span class="keyword">int</span> beg_pos = <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!pf)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        </span><br><span class="line">        _len = len &gt; <span class="number">0</span> ? len : <span class="number">1</span>;</span><br><span class="line">        _beg_pos = beg_pos &gt; <span class="number">0</span> ? beg_pos : <span class="number">1</span>;</span><br><span class="line">        pf(beg_pos + len - <span class="number">1</span>, _elems);</span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="keyword">int</span> 		_len;</span><br><span class="line">    <span class="keyword">int</span> 		_beg_pos;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; _elems;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// pf是一个指向“依据特定数列类型，产生pos个元素，放到vector内”的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fibonacci</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;seq)</span></span>;</span><br><span class="line"><span class="function">numeric_sequence&lt;fibonacci&gt; <span class="title">ns_fib</span><span class="params">(<span class="number">12</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="67-以template参数作为设计策略"><a class="markdownIt-Anchor" href="#67-以template参数作为设计策略"></a> 6.7 以Template参数作为设计策略</h3>
<h4 id="671-lessthan-function-object"><a class="markdownIt-Anchor" href="#671-lessthan-function-object"></a> 6.7.1 LessThan function object</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LessThan</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LessThan(<span class="keyword">const</span> elemType &amp;val) : _val(val) &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> elemType &amp;val)</span> <span class="keyword">const</span> </span></span><br><span class="line"><span class="function">    			   </span>&#123; <span class="keyword">return</span> val &lt; _val;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">val</span><span class="params">(<span class="keyword">const</span> elemType &amp;newval)</span> </span>&#123;_val = newval;&#125;</span><br><span class="line">    <span class="function">elemType <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    elemType _val;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line"><span class="comment">// less&lt;&gt;(a, b) &#123;return a &lt; b;&#125;</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType, <span class="keyword">typename</span> Comp = less&lt;elemType&gt; &gt;</span><br><span class="line">class LessThanPred &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	LessThanPred(<span class="keyword">const</span> elemType &amp;val) : _val(val) &#123;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>() (<span class="keyword">const</span> elemType &amp;val) <span class="keyword">const</span></span><br><span class="line">    &#123;<span class="keyword">return</span> Comp(val, _val);&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">val</span><span class="params">(<span class="keyword">const</span> emeTYple &amp;newval)</span> </span>&#123;_val = newval;&#125;</span><br><span class="line">    <span class="function">elemType <span class="title">val</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123;<span class="keyword">return</span> _val;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	elemType _val;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串比较版本</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringLen</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2)</span></span></span><br><span class="line"><span class="function">    </span>&#123;<span class="keyword">return</span> s1.<span class="built_in">size</span>() &lt; s2.<span class="built_in">size</span>();&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">LessThanPred&lt;<span class="keyword">int</span>&gt; <span class="title">ltpi</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line">LessThanPred&lt;string, StringLen&gt; ltps("Pooh");</span><br></pre></td></tr></table></figure>
<h3 id="68-member-template-function"><a class="markdownIt-Anchor" href="#68-member-template-function"></a> 6.8 Member Template Function</h3>
<ol>
<li>member template function</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintIt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PrintIt(ostream &amp;os)</span><br><span class="line">        : _os(os) &#123;&#125;</span><br><span class="line">    <span class="comment">// 下面是一个member template function</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> elemType&gt;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(<span class="keyword">const</span> elemTYpe &amp;elem, <span class="keyword">char</span> delimiter = <span class="string">'\n'</span>)</span></span></span><br><span class="line"><span class="function">    </span>&#123; _os &lt;&lt; elem &lt;&lt; delimiter;&#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	ostream&amp; _os;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用</span></span><br><span class="line"><span class="function">PrintIt <span class="title">to_standard_out</span><span class="params">(<span class="built_in">cout</span>)</span></span>;</span><br><span class="line">to_standard_out.<span class="built_in">print</span>(<span class="string">"hello"</span>);</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>Class template内也可以定义member template function.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> OutStream&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrintIt</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	PrintIt(OutStream &amp;os)</span><br><span class="line">        : _os(os) &#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Essential C++</tag>
      </tags>
  </entry>
  <entry>
    <title>第10章 网络信息获取及Xml处理</title>
    <url>/2021/04/11/C_/%E7%AC%AC10%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="网络信息获取及xml处理"><a class="markdownIt-Anchor" href="#网络信息获取及xml处理"></a> 网络信息获取及Xml处理</h2>
<h3 id="101-网络信息获取的基本方式"><a class="markdownIt-Anchor" href="#101-网络信息获取的基本方式"></a> 10.1 网络信息获取的基本方式</h3>
<h4 id="1011-网络信息浏览"><a class="markdownIt-Anchor" href="#1011-网络信息浏览"></a> 10.1.1 网络信息浏览</h4>
<a id="more"></a>
<ul>
<li>
<p>HTTP协议</p>
</li>
<li>
<p>客户端与服务端</p>
</li>
<li>
<p>Request与Response</p>
</li>
<li>
<p>Stream</p>
</li>
<li>
<p>Get与Post</p>
</li>
</ul>
<h4 id="1012-一些查看工具"><a class="markdownIt-Anchor" href="#1012-一些查看工具"></a> 10.1.2 一些查看工具</h4>
<ul>
<li>Fiddler2</li>
<li>Chrome/FireFox等浏览器F12
<ul>
<li>Chrome中按F12， 或点右键，“审查元素”</li>
</ul>
</li>
</ul>
<h4 id="1013-使用systemweb"><a class="markdownIt-Anchor" href="#1013-使用systemweb"></a> 10.1.3 <a href="http://xn--System-vt9i248w.Web" target="_blank" rel="noopener">使用System.Web</a></h4>
<p>System.Web提供支持浏览器/服务器通讯的类和接口</p>
<p><strong>System.Net中的类</strong></p>
<p><img src="https://i.loli.net/2021/04/20/26HmlvrEXeVpRGf.png" alt="4.png" /></p>
<h4 id="1014-webclient类"><a class="markdownIt-Anchor" href="#1014-webclient类"></a> 10.1.4 WebClient类</h4>
<p><strong>DownloadData及DownloadFile</strong></p>
<ul>
<li>后来又有DownloadString</li>
<li>UploadData及UploadFile</li>
<li>OpenRead及OpenWrite</li>
</ul>
<p><strong>示例</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string url&#x3D; @&quot;http:&#x2F;&#x2F;www.baidu.com&quot;;</span><br><span class="line">WebClientclient &#x3D; new WebClient();</span><br><span class="line">byte[] pageData&#x3D; client.DownloadData(url);</span><br><span class="line">string pageHtml&#x3D; Encoding.Default.GetString(pageData);</span><br><span class="line">Console.WriteLine(pageHtml);</span><br></pre></td></tr></table></figure>
<h4 id="1015-webrequest及webresponse"><a class="markdownIt-Anchor" href="#1015-webrequest及webresponse"></a> 10.1.5 WebRequest及WebResponse</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">WebRequest myRequest &#x3D; WebRequest.Create(&quot;http:&#x2F;&#x2F;www.contoso.com&quot;);</span><br><span class="line">WebResponse myResponse &#x3D; myRequest.GetResponse();</span><br><span class="line">Stream requestStream &#x3D; myRequest.GetRequestStream()</span><br><span class="line">Stream receiveStream &#x3D;myWebResponse.GetResponseStream();</span><br></pre></td></tr></table></figure>
<h4 id="1016-一些术语"><a class="markdownIt-Anchor" href="#1016-一些术语"></a> 10.1.6 一些术语</h4>
<ul>
<li>Credentials: 主要指用户名、密码等</li>
<li>Header：头部信息</li>
<li>Cookie： Cookie信息</li>
<li>User-Agent: 用户代理（浏览器）</li>
<li>Refer：由哪个页面进行的访问</li>
</ul>
<h3 id="102-xml基本操作"><a class="markdownIt-Anchor" href="#102-xml基本操作"></a> 10.2 XML基本操作</h3>
<h4 id="1021-xml的内容"><a class="markdownIt-Anchor" href="#1021-xml的内容"></a> 10.2.1 XML的内容</h4>
<ul>
<li>
<p>声明&lt;?xml version = ‘1.0’ …?&gt;</p>
</li>
<li>
<p>实体&lt;!Entity…&gt;</p>
</li>
<li>
<p>元素&lt;book&gt; … &lt;/book&gt;</p>
</li>
<li>
<p>属性&lt;book title = “…” /&gt;</p>
</li>
<li>
<p>注释&lt;!-- some comments --&gt;</p>
</li>
<li>
<p>特殊字符</p>
<p>&lt; &gt; 分别表示为&amp;lt; &amp;gt;</p>
</li>
</ul>
<h4 id="1022-xml的处理方式"><a class="markdownIt-Anchor" href="#1022-xml的处理方式"></a> 10.2.2 XML的处理方式</h4>
<p><strong>DOM</strong></p>
<p>文档对象模式(Document Object Model)</p>
<ul>
<li>把整个文档装入内存，建立一个树状结构处理</li>
</ul>
<p><strong>SAX</strong></p>
<p>XML解析的简单API(Simple API for XML)</p>
<ul>
<li>读到一个标记处理一下</li>
</ul>
<h4 id="1023-常用的xml类"><a class="markdownIt-Anchor" href="#1023-常用的xml类"></a> 10.2.3 常用的XML类</h4>
<p><strong>XmlDocument</strong></p>
<ul>
<li>.LoadXml()	.DocumentElement</li>
</ul>
<p><strong>XmlNode的属性</strong></p>
<ul>
<li>.ChildNodes	.HasChildNodes,	.FirstChildNode</li>
<li>.InnerXml    .InnerText    .OutterXml    .Value</li>
<li>.NodeType</li>
<li>子类XmlDocument, XmlElement
<ul>
<li>XmlAttribute, XmlEntity</li>
</ul>
</li>
</ul>
<h3 id="103-xpath及xslt编辑"><a class="markdownIt-Anchor" href="#103-xpath及xslt编辑"></a> 10.3 XPath及Xslt编辑</h3>
<h4 id="1031-xpath的概念"><a class="markdownIt-Anchor" href="#1031-xpath的概念"></a> 10.3.1 XPath的概念</h4>
<p>XPath是对XML进行查询的表达式</p>
<ul>
<li>
<p>Axes(路径)	/  及  //</p>
<ul>
<li>/books/book/@title         一层</li>
<li>//price                                一直向下找到为止</li>
</ul>
</li>
<li>
<p>第几个子节点 [1] 等</p>
</li>
<li>
<p>属性  @</p>
</li>
<li>
<p>条件  []</p>
<ul>
<li>para[@type = “warning”][5]</li>
</ul>
</li>
</ul>
<h4 id="1032-xslt"><a class="markdownIt-Anchor" href="#1032-xslt"></a> 10.3.2 XSLT</h4>
<p>XSLT 指 XSL 转换。使用 XSLT 将 XML 文档转换为其他文档，比如 XHTML。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try</span><br><span class="line">&#123;</span><br><span class="line">    XmlDocument doc &#x3D; new XmlDocument();</span><br><span class="line">    doc.Load(@&quot;.\BookList.xml&quot;);</span><br><span class="line"></span><br><span class="line">    XPathNavigator nav &#x3D;doc.CreateNavigator();</span><br><span class="line">    nav.MoveToRoot();</span><br><span class="line"></span><br><span class="line">    XslTransform xt &#x3D; new XslTransform();</span><br><span class="line">    xt.Load(@&quot;.\BookList.xslt&quot;);</span><br><span class="line"></span><br><span class="line">    XmlTextWriter writer &#x3D; new XmlTextWriter(Console.Out);</span><br><span class="line"></span><br><span class="line">    xt.Transform(nav,  null, writer);</span><br><span class="line">&#125;</span><br><span class="line">catch( XmlException e )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;XML Exception:&quot; + e.ToString());</span><br><span class="line">&#125;</span><br><span class="line">catch( XsltException e )</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;XSLT Exception:&quot; + e.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="104-示例"><a class="markdownIt-Anchor" href="#104-示例"></a> 10.4 示例</h3>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第12章 数据库</title>
    <url>/2021/04/13/C_/%E7%AC%AC12%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="数据库"><a class="markdownIt-Anchor" href="#数据库"></a> 数据库</h2>
<h3 id="122-adonet"><a class="markdownIt-Anchor" href="#122-adonet"></a> 12.2 <a href="http://ADO.NET" target="_blank" rel="noopener">ADO.NET</a></h3>
<a id="more"></a>
<p>System.Data名称空间</p>
<h4 id="1221-adonet的四个重要对象"><a class="markdownIt-Anchor" href="#1221-adonet的四个重要对象"></a> 12.2.1 ADO.NET的四个重要对象</h4>
<p><img src="https://i.loli.net/2021/04/20/7wIoXtaiT4vBpUq.png" alt="8.png" /></p>
<h3 id="123-访问数据库的方法"><a class="markdownIt-Anchor" href="#123-访问数据库的方法"></a> 12.3 访问数据库的方法</h3>
<h4 id="1231-方式一-dataadapter及dataset"><a class="markdownIt-Anchor" href="#1231-方式一-dataadapter及dataset"></a> 12.3.1 方式一 DataAdapter及DataSet</h4>
<ul>
<li>适合于“离线”处理</li>
<li>自动建立Command对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OleDbCommandBuilder cmdbld &#x3D; new OleDbCommandBuilder(daAdapter);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 数据集</span><br><span class="line">DataSet dsMyData &#x3D; new DataSet();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 填充数据</span><br><span class="line">daAdapter.Fill(dyMyData);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 访问数据</span><br><span class="line">foreach(DataTable table in dyMyData.Tables) &#123;</span><br><span class="line">    foreach(DataRow row in table.Rows) &#123;</span><br><span class="line">        foreach(object field in row.ItemArray) &#123;</span><br><span class="line">            Console.Write(field);</span><br><span class="line">        &#125;</span><br><span class="line">        Console.WriteLine();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">Console.WriteLine(dyMyData.Table[0].Rows[0][1]);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 提交数据的改变</span><br><span class="line">daAdapter.Update(dyMyData);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; DataSet与XML转换</span><br><span class="line">dyMyData.WriterXml(&quot;test.xml&quot;);</span><br><span class="line">dyMyData.ReadXml(&quot;test.xml&quot;);</span><br></pre></td></tr></table></figure>
<h4 id="1232-datareader"><a class="markdownIt-Anchor" href="#1232-datareader"></a> 12.3.2 DataReader</h4>
<ul>
<li>适合于只读数据，效率较高</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">OleDbDataReader MyReader &#x3D; MyCommand.ExecuteReader();</span><br><span class="line">while(MyReader.Read())</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(</span><br><span class="line">    	MyReader.GetString(1) + </span><br><span class="line">        MyReader[&quot;Name&quot;].ToString() +</span><br><span class="line">        MyReader[2].ToString()</span><br><span class="line">    );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1233-使用command对象"><a class="markdownIt-Anchor" href="#1233-使用command对象"></a> 12.3.3 使用Command对象</h4>
<ul>
<li>ExecuteReader ()
<ul>
<li>得到 Reader 对象，单向只读</li>
</ul>
</li>
<li>ExecuteScalar ()
<ul>
<li>得到单一的量，如 sum,avg 等的结果</li>
</ul>
</li>
<li>ExecuteNonQuery ()
<ul>
<li>执行非查询性的命令（如 Update/Delete/Insert)</li>
<li>返回的是它所影响的记录数</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用Command的ExecuteScalar</span><br><span class="line">MyCommand.CommandText &#x3D; &quot;Select COUNT(*) From [Test]&quot;;</span><br><span class="line">int cnt &#x3D; (int) MyCommand.ExecuteScalar();</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用Command的ExecuteNonQuery</span><br><span class="line">MyCommand.CommandText &#x3D; &quot;Delete From [Test] Where [Name] &#x3D; &#39;T&#39;&quot;;</span><br><span class="line">int cntDeleted &#x3D; MyCommand.ExecuteNonQuery();</span><br></pre></td></tr></table></figure>
<h4 id="1234-使用参数"><a class="markdownIt-Anchor" href="#1234-使用参数"></a> 12.3.4 使用参数</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cmd.CommandText &#x3D; &quot;INSERT INTO CName , EName , FName ) VALUES</span><br><span class="line">(@CName , @EName , @FName);</span><br><span class="line">cmd.Connection &#x3D; this.sqlConnection1;</span><br><span class="line">cmd.Parameters.Add(@CName &quot;, SqlDbType.VarChar, 60).Value &#x3D;</span><br><span class="line">                   &quot; aaaaaa &quot;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 泛型编程风格</title>
    <url>/2019/12/16/C++/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-泛型编程风格"><a class="markdownIt-Anchor" href="#第三章-泛型编程风格"></a> 第三章 泛型编程风格</h2>
<h3 id="34顺序性容器"><a class="markdownIt-Anchor" href="#34顺序性容器"></a> 3.4顺序性容器</h3>
<a id="more"></a>
<h4 id="341-五种定义方式"><a class="markdownIt-Anchor" href="#341-五种定义方式"></a> 3.4.1 五种定义方式</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1. 产生空的容器：</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ivec;</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 产生特定大小的容器。每个元素都以其默认值作为初值。</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ilist</span><span class="params">(<span class="number">1024</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">svec</span><span class="params">(<span class="number">32</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//3. 产生特定大小的容器，并为每个元素指定初值</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">ivec</span><span class="params">(<span class="number">10</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist</span><span class="params">(<span class="number">16</span>, <span class="string">"unassigned"</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//4. 通过一堆iterator产生容器。这对iterator用来标示一整组作为初值的元素的范围：</span></span><br><span class="line"><span class="keyword">int</span> ia[<span class="number">8</span>] = &#123; <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span> &#125;;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">fib</span><span class="params">(ia, ia + <span class="number">8</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//5. 根据某个容器产生出新容器。复制原容器内的元素，作为新容器的初值:</span></span><br><span class="line"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; slist;	<span class="comment">// 空容器</span></span><br><span class="line"><span class="comment">// 填充slist</span></span><br><span class="line"><span class="function"><span class="built_in">list</span>&lt;<span class="built_in">string</span>&gt; <span class="title">slist2</span><span class="params">(slist)</span></span>;	<span class="comment">// 将slist复制给slist2</span></span><br></pre></td></tr></table></figure>
<h4 id="342-push和pop"><a class="markdownIt-Anchor" href="#342-push和pop"></a> 3.4.2 push和pop</h4>
<ul>
<li>push_back()和pop_back()</li>
<li>push_front()和pop_front()</li>
</ul>
<h4 id="343-插入和删除"><a class="markdownIt-Anchor" href="#343-插入和删除"></a> 3.4.3 插入和删除</h4>
<ul>
<li>insert</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- <span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, elemType value)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>, <span class="keyword">int</span> count, elemType </span></span></span><br><span class="line"><span class="function"><span class="params">value)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(iterator1 <span class="built_in">position</span>, iterator2 first, iterator2 last)</span></span>;</span><br><span class="line"></span><br><span class="line">- <span class="function">iterator <span class="title">insert</span><span class="params">(iterator <span class="built_in">position</span>)</span></span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>erase</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- <span class="function">iterator <span class="title">erase</span><span class="params">(iterator posit)</span></span>;	<span class="comment">// posit所指的元素</span></span><br><span class="line"></span><br><span class="line">- <span class="function">iterator <span class="title">erase</span><span class="params">(iterator first, iterator last)</span></span>;	<span class="comment">//[first, last)范围内的元素</span></span><br></pre></td></tr></table></figure>
<h3 id="35-泛型算法"><a class="markdownIt-Anchor" href="#35-泛型算法"></a> 3.5 泛型算法</h3>
<h4 id="351-搜索算法"><a class="markdownIt-Anchor" href="#351-搜索算法"></a> 3.5.1 搜索算法</h4>
<ol>
<li>find()用于搜索无序集合中是否存在某值。范围由iterator[first,last)标出。返回iterator指向该值/last。</li>
<li>binary_search()用于有序集合的搜索。返回true/false。</li>
<li>count()返回数值相符的元素数目。</li>
<li>search()比对某个容器内是否存在某个子序列。返回iterator指向子序列起始处/last。</li>
</ol>
<h4 id="352-max-sort-copy"><a class="markdownIt-Anchor" href="#352-max-sort-copy"></a> 3.5.2 max、sort、copy</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">max_element(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">sort(temp.<span class="built_in">begin</span>(), temp.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">copy(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), temp.<span class="built_in">begin</span>());</span><br></pre></td></tr></table></figure>
<h3 id="36-设计泛型算法"><a class="markdownIt-Anchor" href="#36-设计泛型算法"></a> 3.6 设计泛型算法</h3>
<h4 id="362-function-object"><a class="markdownIt-Anchor" href="#362-function-object"></a> 3.6.2 Function Object</h4>
<h4 id="3621-functional"><a class="markdownIt-Anchor" href="#3621-functional"></a> 3.6.2.1  functional</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- <span class="meta">#<span class="meta-keyword">include</span>  <span class="meta-string">&lt;functional&gt;</span></span></span><br><span class="line"></span><br><span class="line">- 六个算数运算：plus &lt;type&gt;, minus &lt;type&gt;, negate &lt;type&gt;, </span><br><span class="line">		multiplies &lt;type&gt;, divides &lt;type&gt;, modules &lt;type&gt;</span><br><span class="line">                  </span><br><span class="line">- 六个关系运算：less &lt;type&gt;，less_equal &lt;type&gt;，greater &lt;type&gt;，</span><br><span class="line">              greater_equal &lt;type&gt;，euqal_to &lt;type&gt;，not_equal_to &lt;type&gt;</span><br><span class="line"></span><br><span class="line">- 三个逻辑运算：logical_and &lt;type&gt;，logical_or &lt;type&gt;，logical_not &lt;type&gt;</span><br></pre></td></tr></table></figure>
<h4 id="3622-示例"><a class="markdownIt-Anchor" href="#3622-示例"></a> 3.6.2.2  示例</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">- sort(vec.<span class="built_in">begin</span>(), bec.<span class="built_in">end</span>(), greater &lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">- binary_search(vec,<span class="built_in">begin</span>(), vc.<span class="built_in">end</span>(), elem, greater &lt;<span class="keyword">int</span>&gt;());</span><br><span class="line"></span><br><span class="line">- transform(fib.<span class="built_in">begin</span>(), fib.<span class="built_in">end</span>(),		<span class="comment">// (1) 欲转换的元素范围</span></span><br><span class="line">			pell.<span class="built_in">begin</span>(),		<span class="comment">// (2) 所指元素将应用于转换操作</span></span><br><span class="line">			fib_plus_pell.<span class="built_in">begin</span>(), 	<span class="comment">// (3) 所指位指（及后续空间）用来存放转换结果</span></span><br><span class="line">			plus &lt;<span class="keyword">int</span>&gt;());		<span class="comment">// (4) 想要应用的转换操作</span></span><br></pre></td></tr></table></figure>
<h4 id="363-function-object-adapter"><a class="markdownIt-Anchor" href="#363-function-object-adapter"></a> 3.6.3 Function Object Adapter</h4>
<p>​		function object adapter 会对 function object 进行修改操作。所谓binder adapter（绑定适配器）会将 function object 的参数绑定至某特定值，使binary（二元）function object 转化为unary（一元）function object。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">bind2nd(less&lt;<span class="keyword">int</span>&gt;,  val);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会把val绑定与less&lt;int&gt;的第二个参数身上。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 于是，less&lt;int&gt;会将每个元素拿来和val比较。</span></span><br></pre></td></tr></table></figure>
<h3 id="37-map"><a class="markdownIt-Anchor" href="#37-map"></a> 3.7 Map</h3>
<h4 id="371-定义"><a class="markdownIt-Anchor" href="#371-定义"></a> 3.7.1 定义</h4>
<p>map被定义为一对(pair)数值，带有key和value</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; words;</span><br><span class="line"></span><br><span class="line"><span class="comment">//赋值</span></span><br><span class="line">words[<span class="string">"vermeer"</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">string</span> tword;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">cin</span> &gt;&gt; tword) &#123;</span><br><span class="line">    words[tword]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//words[tword]会取出tword相应的value， 如果tword不在map内，它便会因此被放到map内，并获得默认值0。</span></span><br></pre></td></tr></table></figure>
<h4 id="372-查询"><a class="markdownIt-Anchor" href="#372-查询"></a> 3.7.2 查询</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line">    <span class="keyword">if</span>(!count = words[<span class="string">"vermeer"</span>]);</span><br><span class="line">	<span class="comment">//这种方法会将vermeer加入words中</span></span><br><span class="line"><span class="number">2.f</span>ind()函数</span><br><span class="line">    words.<span class="built_in">find</span>(<span class="string">"vermeer"</span>);</span><br><span class="line">	<span class="comment">//返回一个iterator，指向key/value形成的pair，反之返回end()</span></span><br><span class="line"><span class="number">3.</span>count()函数</span><br><span class="line">    words.count(<span class="string">"vermeer"</span>);</span><br><span class="line">    <span class="comment">//返回某特定项在map内的个数</span></span><br></pre></td></tr></table></figure>
<h3 id="38-set"><a class="markdownIt-Anchor" href="#38-set"></a> 3.8 Set</h3>
<h4 id="381-定义"><a class="markdownIt-Anchor" href="#381-定义"></a> 3.8.1 定义</h4>
<ol>
<li>set由一群key组合而成，如果想知道某值是否存在于某个集合内，就可以使用set.</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//创建</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt; word_exclusion;</span><br><span class="line"></span><br><span class="line"><span class="comment">//先排查set，再加入map</span></span><br><span class="line"><span class="keyword">while</span>( <span class="built_in">cin</span> &gt;&gt; tword) &#123;</span><br><span class="line">    <span class="keyword">if</span> (word_exclusion.count(tword))</span><br><span class="line">        <span class="comment">//如果在“排除字集”内</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    </span><br><span class="line">    words[tword]++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="382-操作"><a class="markdownIt-Anchor" href="#382-操作"></a> 3.8.2 操作</h4>
<ol>
<li>set只能储存一份key值</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span>创建</span><br><span class="line">    <span class="keyword">int</span> ia[<span class="number">10</span>] = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(ia,ia+<span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; <span class="title">iset</span><span class="params">(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>())</span></span>;</span><br><span class="line">    <span class="comment">//iset的元素将是&#123;1, 3, 5, 8&#125;</span></span><br><span class="line"><span class="number">2.</span>insert</span><br><span class="line">    iset.insert(ival);</span><br><span class="line">	iset.insert(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>());</span><br><span class="line"><span class="number">3.</span>迭代</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt;::iterator it = iset.<span class="built_in">begin</span>();</span><br><span class="line">	<span class="keyword">for</span> (; it != <span class="built_in">set</span>.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        cout &lt;&lt; *it &lt;&lt; '';</span><br><span class="line">    &#125;</span><br><span class="line"><span class="number">4.</span>其他算法</span><br><span class="line">    set_intersection(), set_union(), set_difference()和set_symmetric_difference()</span><br></pre></td></tr></table></figure>
<h3 id="39-iterator-inserter"><a class="markdownIt-Anchor" href="#39-iterator-inserter"></a> 3.9 Iterator Inserter</h3>
<h4 id="391-insertion-adapter"><a class="markdownIt-Anchor" href="#391-insertion-adapter"></a> 3.9.1 insertion adapter</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="number">1.b</span>ack_inserter</span><br><span class="line">    <span class="comment">//会以容器的push_back()取代assignment运算符</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result_vec;</span><br><span class="line">	unique_copy(ivec.<span class="built_in">begin</span>(), ivec.<span class="built_in">end</span>(),</span><br><span class="line">                back_inserter(result_vec));</span><br><span class="line"><span class="number">2.</span>inserter</span><br><span class="line">    <span class="comment">//会以容器的insert()函数取代assignment运算符</span></span><br><span class="line">    <span class="comment">//两个参数：容器、iterator</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; svec_res;</span><br><span class="line">unique_copy(svec.<span class="built_in">begin</span>(), svec.<span class="built_in">end</span>(),</span><br><span class="line">           inserter(svec_res, svec_res.edn()));</span><br><span class="line"><span class="number">3.f</span>ront_inserter</span><br><span class="line">    <span class="comment">//会以容器的push_front()函数取代assignment运算符</span></span><br><span class="line">    <span class="comment">//只适用于list和deque</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; ilist_clone;</span><br><span class="line">	copy(ilist.<span class="built_in">begin</span>(), ilist.<span class="built_in">end</span>(),</span><br><span class="line">        front_inserter(ilist_clone));</span><br></pre></td></tr></table></figure>
<h3 id="310-iostream-iterator"><a class="markdownIt-Anchor" href="#310-iostream-iterator"></a> 3.10 iostream Iterator</h3>
<h4 id="311-定义"><a class="markdownIt-Anchor" href="#311-定义"></a> 3.1.1 定义</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>istream_iterator</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">is</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">    <span class="comment">//将is定义为一个“绑至标准输入设备”的istream_iterator</span></span><br><span class="line">    istream_iterator&lt;<span class="built_in">string</span>&gt; eof;</span><br><span class="line">    <span class="comment">//eof代表EOF</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span>ostream_iterator</span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">os</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line">    <span class="comment">//将os定义为一个“绑至标准输出设备”的ostream_iterator</span></span><br><span class="line">    <span class="comment">//第二个参数表示各个元素被输出时的分隔符</span></span><br></pre></td></tr></table></figure>
<h4 id="312-用法"><a class="markdownIt-Anchor" href="#312-用法"></a> 3.1.2 用法</h4>
<ol>
<li>标准输入输出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">is</span><span class="params">(<span class="built_in">cin</span>)</span></span>;</span><br><span class="line">    istream_iterator&lt;<span class="built_in">string</span>&gt; eof;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span>;</span><br><span class="line">    copy(is, eof, back_inserter(<span class="built_in">text</span>));</span><br><span class="line">    </span><br><span class="line">    sort(<span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">text</span>.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">os</span><span class="params">(<span class="built_in">cout</span>, <span class="string">" "</span>)</span></span>;</span><br><span class="line">    copy(<span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">text</span>.<span class="built_in">end</span>(), os);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>文件输入输出</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iterator&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">ifstream <span class="title">in_file</span><span class="params">(<span class="string">"input_file.txt"</span>)</span></span>;</span><br><span class="line">    <span class="function">ofstream <span class="title">out_file</span><span class="params">(<span class="string">"output_file.txt"</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (!in_file || !out_file) &#123;</span><br><span class="line">		<span class="built_in">cerr</span> &lt;&lt; <span class="string">"!! unable to open the necessary files.\n"</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">istream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">is</span><span class="params">(in_file)</span></span>;</span><br><span class="line">    istream_iterator&lt;<span class="built_in">string</span>&gt; eof;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="built_in">text</span>;</span><br><span class="line">    copy(is, eof, back_inserter(<span class="built_in">text</span>));</span><br><span class="line">    </span><br><span class="line">    sort(<span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">text</span>.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="function">ostream_iterator&lt;<span class="built_in">string</span>&gt; <span class="title">os</span><span class="params">(out_file, <span class="string">" "</span>)</span></span>;</span><br><span class="line">    copy(<span class="built_in">text</span>.<span class="built_in">begin</span>(), <span class="built_in">text</span>.<span class="built_in">end</span>(), os);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C++</category>
      </categories>
      <tags>
        <tag>Essential C++</tag>
      </tags>
  </entry>
  <entry>
    <title>第1章 C#介绍</title>
    <url>/2021/04/02/C_/%E7%AC%AC1%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="c介绍"><a class="markdownIt-Anchor" href="#c介绍"></a> C#介绍</h2>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/04/20/Icl5pC1zoBsuaMV.png" alt="1.png" /></p>
<h3 id="11-exe文件中的内容"><a class="markdownIt-Anchor" href="#11-exe文件中的内容"></a> 1.1 exe文件中的内容</h3>
<ul>
<li>IL指令</li>
<li>元信息</li>
</ul>
<p><img src="https://i.loli.net/2021/04/20/QUHnFJiKLZBtwdC.png" alt="2.png" /></p>
<h3 id="12-三种应用程序类型"><a class="markdownIt-Anchor" href="#12-三种应用程序类型"></a> 1.2 三种应用程序类型</h3>
<p><strong>控制台程序</strong></p>
<p><strong>Windows应用程序</strong></p>
<ul>
<li>可视化的设计窗体</li>
<li>事件驱动编程机制</li>
</ul>
<p><strong>Web应用程序(ASP.NET应用程序)</strong></p>
<ul>
<li>
<p>应用程序在服务器上运行，客户端使用浏览器来进行输入输出</p>
</li>
<li>
<p>这种方式称为B/S(Browser/Server)方式</p>
</li>
</ul>
<h3 id="13-输入输出"><a class="markdownIt-Anchor" href="#13-输入输出"></a> 1.3 输入输出</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;输出a:&#123;0&#125;&quot;, a);</span><br></pre></td></tr></table></figure>
<h3 id="14-总结"><a class="markdownIt-Anchor" href="#14-总结"></a> 1.4 总结</h3>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MessageBox.Show(&quot;你好！&quot;);</span><br><span class="line"></span><br><span class="line">this.Text &#x3D; &quot;这是一个应用程序&quot;;</span><br><span class="line"></span><br><span class="line">this.BackColor &#x3D; Color.FromArgb(255, 255, 0);</span><br><span class="line"></span><br><span class="line">this.label1.SetBounds(100, 100, 200, 50);</span><br><span class="line"></span><br><span class="line">this.label1.Text &#x3D; e.X + &quot;,&quot; + e.Y;</span><br><span class="line"></span><br><span class="line">Random rnd &#x3D; new Random();</span><br><span class="line"></span><br><span class="line">rnd.Next(255)</span><br><span class="line"></span><br><span class="line">double a &#x3D; double.Parse( textBox1.Text );</span><br><span class="line"></span><br><span class="line">Console.WriteLine( &quot;&#123;0&#125;&#123;1&#125;&quot;, a, b);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第11章 多线程与异步编程</title>
    <url>/2021/04/12/C_/%E7%AC%AC11%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="多线程与异步编程"><a class="markdownIt-Anchor" href="#多线程与异步编程"></a> 多线程与异步编程</h2>
<h3 id="111-线程及其控制"><a class="markdownIt-Anchor" href="#111-线程及其控制"></a> 11.1 线程及其控制</h3>
<h4 id="1111-多线程"><a class="markdownIt-Anchor" href="#1111-多线程"></a> 11.1.1 多线程</h4>
<a id="more"></a>
<ul>
<li>线程中的指令：一个方法(委托)</li>
<li>线程中的数据：相关的对象</li>
</ul>
<h4 id="1112-线程属性"><a class="markdownIt-Anchor" href="#1112-线程属性"></a> 11.1.2 线程属性</h4>
<p><img src="https://i.loli.net/2021/04/20/h57PtgQducvUMH4.png" alt="5.png" /></p>
<h4 id="1113-线程方法"><a class="markdownIt-Anchor" href="#1113-线程方法"></a> 11.1.3 线程方法</h4>
<p><img src="https://i.loli.net/2021/04/20/cGdofq5iAUtCTPw.png" alt="6.png" /></p>
<h4 id="1114-线程的创建"><a class="markdownIt-Anchor" href="#1114-线程的创建"></a> 11.1.4 线程的创建</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Thread(ThreadStart fun);</span><br></pre></td></tr></table></figure>
<h4 id="1115-线程的状态"><a class="markdownIt-Anchor" href="#1115-线程的状态"></a> 11.1.5 线程的状态</h4>
<p><img src="https://i.loli.net/2021/04/20/wi3p9CRITNtmaOr.png" alt="7.png" /></p>
<h4 id="1116-线程的同步"><a class="markdownIt-Anchor" href="#1116-线程的同步"></a> 11.1.6 线程的同步</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">thread.join();</span><br></pre></td></tr></table></figure>
<h4 id="1117-线程池"><a class="markdownIt-Anchor" href="#1117-线程池"></a> 11.1.7 线程池</h4>
<h4 id="1118-systemthreadingtimer类"><a class="markdownIt-Anchor" href="#1118-systemthreadingtimer类"></a> 11.1.8 System.Threading.Timer类</h4>
<h4 id="1119-集合的线程安全性"><a class="markdownIt-Anchor" href="#1119-集合的线程安全性"></a> 11.1.9 集合的线程安全性</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ArrayList mySyncdAL &#x3D; ArrayList.Synchronized(myAL);</span><br></pre></td></tr></table></figure>
<h4 id="11110-windows界面与线程"><a class="markdownIt-Anchor" href="#11110-windows界面与线程"></a> 11.1.10 Windows界面与线程</h4>
<ul>
<li>
<p>界面的主线程</p>
</li>
<li>
<p>对界面的更新只能使用主线程</p>
</li>
<li>
<p>其他线程则可以这样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(this.InvokeRequired)&#123;</span><br><span class="line">	this.BeginInvoke( new AddMsg(this.AddMsgFun),new object[]&#123; msg&#125; ); 		&#x2F;&#x2F;显示到界面上</span><br><span class="line">&#125;else&#123;</span><br><span class="line">	this.AddMsgFun(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="112-并行编程"><a class="markdownIt-Anchor" href="#112-并行编程"></a> 11.2 并行编程</h3>
<p>多CPU协作执行任务</p>
<h4 id="1121-并行任务库"><a class="markdownIt-Anchor" href="#1121-并行任务库"></a> 11.2.1 并行任务库</h4>
<p><strong>Task类</strong></p>
<ul>
<li>Task&lt;double&gt; task = Task.Run( ()=&gt;SomeFun() );<br />
doubleresult = task.Result; 			//等待直到获得结果</li>
<li>可以使用Task.WaitAll( task数组)</li>
<li>可以使用task.ContinueWith( 另一个task)</li>
</ul>
<p><strong>Parallel类</strong></p>
<ul>
<li>Parallel.Invoke( Action[] actions); 并行执行多个任务，直到完成</li>
<li>Parallel.For( 0, 100, i=&gt;{…} )</li>
<li>Parallel.ForEach( list, item =&gt;{…} )</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Parallel.For(0, 10, i &#x3D;&gt;</span><br><span class="line">&#123;</span><br><span class="line">	Console.WriteLine(&quot;i&#x3D;&#123;0&#125;, fac&#x3D;&#123;1&#125;, 线程id&#x3D;&#123;2&#125;&quot;,</span><br><span class="line">		i, Calc(i),</span><br><span class="line">		Thread.CurrentThread.ManagedThreadId);</span><br><span class="line">    Thread.Sleep(10);</span><br><span class="line">&#125;);</span><br><span class="line">Console.ReadLine();</span><br></pre></td></tr></table></figure>
<p><strong>并行Linq</strong></p>
<ul>
<li>只要在集合上加个.AsParallel()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; (from n in persons.AsParallel()</span><br><span class="line">			where n.Age&gt; 20 &amp;&amp; n.Age&lt; 25</span><br><span class="line">			select n)</span><br><span class="line">		.ToList();</span><br></pre></td></tr></table></figure>
<h3 id="113-异步编程"><a class="markdownIt-Anchor" href="#113-异步编程"></a> 11.3 异步编程</h3>
<p>等待一些耗时的任务(特别是文件、网络操作)而<strong>不阻塞</strong>当前任务</p>
<h4 id="1131-传统的方法"><a class="markdownIt-Anchor" href="#1131-传统的方法"></a> 11.3.1 传统的方法</h4>
<p><strong>BeginInvoke及EndInvoke</strong></p>
<p>当使用BeginInvoke异步调用方法时，如果方法未执行完，EndInvoke方法就会一直阻塞，直到被调用的方法执行完毕</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">PrintDelegate printDelegate &#x3D; Print;</span><br><span class="line"></span><br><span class="line">IAsyncResult result &#x3D; printDelegate.BeginInvoke(&quot;Hello World.&quot;, null, null);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(&quot;主线程继续执行...&quot;);</span><br><span class="line"></span><br><span class="line">int n &#x3D; printDelegate.EndInvoke(result);</span><br></pre></td></tr></table></figure>
<p><strong>使用回调</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Console.WriteLine(&quot;主线程.&quot;);</span><br><span class="line"></span><br><span class="line">PrintDelegate printDelegate&#x3D; Print;</span><br><span class="line"></span><br><span class="line">printDelegate.BeginInvoke(&quot;Hello world.&quot;, PrintComeplete, printDelegate);</span><br><span class="line"></span><br><span class="line">Console.WriteLine(“主线程继续执行...”);</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 回调方法要求：1.返回类型为void 2.只有一个参数IAsyncResult</span><br><span class="line">public static void PrintComeplete(IAsyncResultresult)</span><br><span class="line">&#123;</span><br><span class="line">	(result.AsyncState as PrintDelegate).EndInvoke(result);</span><br><span class="line">	Console.WriteLine(&quot;当前线程结束.&quot; + result.AsyncState.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1132-await及async"><a class="markdownIt-Anchor" href="#1132-await及async"></a> 11.3.2 await及async</h4>
<ul>
<li>
<p>await表示等待任务的执行</p>
</li>
<li>
<p>async修饰一个方法，表示其中有await语句</p>
</li>
</ul>
<p><strong>异步任务与主程序任务一起写</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async void Test() &#123;</span><br><span class="line">	double result &#x3D; await FacAsync(10);	&#x2F;&#x2F; 调用异步方法</span><br><span class="line">	Console.WriteLine( result); 	&#x2F;&#x2F;异步方法执行完后才执行此句</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task&lt;double&gt; FacAsync(int n) &#123; 		&#x2F;&#x2F;用Task表示要执行任务</span><br><span class="line">	return Task&lt;double&gt;.Run( ()&#x3D;&gt;&#123;</span><br><span class="line">		double s &#x3D; 1; for(int i &#x3D; 1; i&lt;n; i++) s &#x3D; s*i;</span><br><span class="line">        return s;</span><br><span class="line">	&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="在winform中"><a class="markdownIt-Anchor" href="#在winform中"></a> 在WinForm中</h5>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async Task&lt;string&gt; AccessTheWebAsync(string url)</span><br><span class="line">&#123;</span><br><span class="line">	HttpClient client &#x3D; new HttpClient();</span><br><span class="line">	Task&lt;string&gt; task &#x3D; client.GetStringAsync(url); &#x2F;&#x2F;异步</span><br><span class="line">	DoIndependentWork(); &#x2F;&#x2F;做其他事</span><br><span class="line">	string urlContents &#x3D; awaittask; &#x2F;&#x2F;等待异步执行完毕</span><br><span class="line">	return urlContents;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>await后面的语句，就不用写成Invoke(委托)了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async private void button1_Click(object sender, EventArgse)</span><br><span class="line">&#123;</span><br><span class="line">	string content &#x3D; await AccessTheWebAsync(url);</span><br><span class="line">	this.textBox2.Text &#x3D; content; &#x2F;&#x2F;编译器让这句在界面线程上执行</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="1133-异步的流"><a class="markdownIt-Anchor" href="#1133-异步的流"></a> 11.3.3 异步的流</h4>
<p>await myStream.WriteAsync(…)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Task task&#x3D; myStream.WriteAsync(); 	&#x2F;&#x2F;异步</span><br><span class="line">DoIndependentWork(); 				&#x2F;&#x2F;做其他事</span><br><span class="line">await task; 						&#x2F;&#x2F;等待异步执行完毕</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第2章 C#语言基础</title>
    <url>/2021/04/03/C_/%E7%AC%AC2%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="c语言基础"><a class="markdownIt-Anchor" href="#c语言基础"></a> C#语言基础</h2>
<h3 id="21-数据类型"><a class="markdownIt-Anchor" href="#21-数据类型"></a> 2.1 数据类型</h3>
<a id="more"></a>
<ul>
<li>
<p>值类型</p>
<p>int, double, struct</p>
<p>存放在栈中</p>
</li>
<li>
<p>引用类型</p>
<p>Button, Label, Book</p>
<p>栈中指针指向堆</p>
</li>
</ul>
<img src="images/3.png" alt="3" style="zoom:80%;" />
<h3 id="22-字符串类型"><a class="markdownIt-Anchor" href="#22-字符串类型"></a> 2.2 字符串类型</h3>
<p><strong>@</strong></p>
<ul>
<li>
<p>可以换行，可以不用进行字符转义</p>
<ul>
<li>
<p>@&quot;abcd</p>
<p>​	Pqrst&quot;</p>
</li>
<li>
<p>@“c:\windows\aaa.txt”</p>
</li>
</ul>
</li>
</ul>
<h3 id="23-特殊类型"><a class="markdownIt-Anchor" href="#23-特殊类型"></a> 2.3 特殊类型</h3>
<p><strong>推断类型 var</strong></p>
<p><strong>Nullable，可以为空</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int? a &#x3D; 32;</span><br><span class="line">if(a.HasValue)</span><br></pre></td></tr></table></figure>
<p><strong>Dynamic</strong></p>
<p>编译时不检查，运行时确定类型</p>
<h3 id="24-整型提升"><a class="markdownIt-Anchor" href="#24-整型提升"></a> 2.4 整型提升</h3>
<p>所有的byte, short, char 运算转换为int</p>
<h3 id="25-类型转换"><a class="markdownIt-Anchor" href="#25-类型转换"></a> 2.5 类型转换</h3>
<p><strong>字符串转数值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">double.Parse(s);</span><br><span class="line">int.Parse(s);</span><br></pre></td></tr></table></figure>
<p><strong>Convert</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Convert.ToInt32(textbox.Text);</span><br></pre></td></tr></table></figure>
<h3 id="26-switch与c的不同"><a class="markdownIt-Anchor" href="#26-switch与c的不同"></a> 2.6 Switch与C++的不同</h3>
<ul>
<li>变量除了整型、枚举型、还可以用字符串</li>
</ul>
<h3 id="27-foreach"><a class="markdownIt-Anchor" href="#27-foreach"></a> 2.7 foreach</h3>
<p>只读式遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">foreach(int age in ages)</span><br></pre></td></tr></table></figure>
<h3 id="28-交错数组"><a class="markdownIt-Anchor" href="#28-交错数组"></a> 2.8 交错数组</h3>
<p>c#中多维数组的声明和初始化应按<strong>从高到低的顺序</strong>进行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int [][]t  &#x3D; new int[3][];</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第3章 类</title>
    <url>/2021/04/04/C_/%E7%AC%AC3%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="类"><a class="markdownIt-Anchor" href="#类"></a> 类</h2>
<h3 id="31-this"><a class="markdownIt-Anchor" href="#31-this"></a> 3.1 this</h3>
<a id="more"></a>
<ul>
<li>访问这个对象的字段及方法</li>
<li>区分字段与局部变量</li>
<li>用于构造方法调用另一个构造方法</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public Person() : this(0, &quot;&quot;) &#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="32-属性-索引"><a class="markdownIt-Anchor" href="#32-属性-索引"></a> 3.2 属性、索引</h3>
<h4 id="属性的书写"><a class="markdownIt-Anchor" href="#属性的书写"></a> 属性的书写</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public string Name&#123;get; set;&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>可以只读或只写：只有get或set</li>
<li>可以进行有效性检查：if</li>
<li>可以是计算得到的数据</li>
<li>可以定义抽象属性</li>
</ul>
<h4 id="索引器"><a class="markdownIt-Anchor" href="#索引器"></a> 索引器</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">修饰符	类型名	this[parameter]</span><br><span class="line">&#123;</span><br><span class="line">    set</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    get</span><br><span class="line">    &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="33-类的继承"><a class="markdownIt-Anchor" href="#33-类的继承"></a> 3.3 类的继承</h3>
<ul>
<li>
<p>C#采用单继承（只能继承一个父类）</p>
</li>
<li>
<p>所有类都是通过继承object得到</p>
</li>
</ul>
<h4 id="字段的继承-添加与隐藏"><a class="markdownIt-Anchor" href="#字段的继承-添加与隐藏"></a> 字段的继承、添加与隐藏</h4>
<ul>
<li>继承：自动</li>
<li>添加：定义新变量
<ul>
<li>重载(Overloading)</li>
<li>覆盖(Overriding)</li>
</ul>
</li>
<li>隐藏：同名关键字前面加一个new</li>
</ul>
<h4 id="使用base"><a class="markdownIt-Anchor" href="#使用base"></a> 使用base</h4>
<p>调用父类的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student(string name, int age, string school)</span><br><span class="line">    : base(name, age)</span><br><span class="line">    &#123; this.school &#x3D; school; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="转换"><a class="markdownIt-Anchor" href="#转换"></a> 转换</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Person p1 &#x3D; new Person();</span><br><span class="line">Person p2 &#x3D; new Student();</span><br><span class="line">Student s1 &#x3D; new Student();</span><br><span class="line">Student s2 &#x3D; new Student();</span><br><span class="line">p1 &#x3D; s1;	&#x2F;&#x2F; 可以</span><br><span class="line">s2 &#x3D; p1;	&#x2F;&#x2F; 不行</span><br><span class="line">s2 &#x3D; (Student)p1;	&#x2F;&#x2F; 可以</span><br><span class="line">s2 &#x3D; (Student)p2;	&#x2F;&#x2F;可以，因为p2引用的正好是Student实例</span><br></pre></td></tr></table></figure>
<p><strong>as运算符</strong></p>
<p>如果不能转换，则值为null，<strong>不会引起异常</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Student s3 &#x3D; p1 as Student;		&#x2F;&#x2F; 结果为null</span><br></pre></td></tr></table></figure>
<p><strong>is运算符</strong></p>
<p>判断一个对象是不是某个类(<strong>及其子类</strong>)的实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(p is Person)</span><br></pre></td></tr></table></figure>
<h3 id="34-修饰符"><a class="markdownIt-Anchor" href="#34-修饰符"></a> 3.4 修饰符</h3>
<h4 id="341-访问控制符"><a class="markdownIt-Anchor" href="#341-访问控制符"></a> 3.4.1 访问控制符</h4>
<img src="https://i.loli.net/2021/04/20/3hJB7SmdY8s6eMR.png" alt="3.png" style="zoom:80%;" />
<ul>
<li>类中的字段、方法默认为private，包括构造函数</li>
</ul>
<h4 id="342-static"><a class="markdownIt-Anchor" href="#342-static"></a> 3.4.2 static</h4>
<ul>
<li>调用static方法时，直接用类名访问</li>
</ul>
<h4 id="343-const及readonly"><a class="markdownIt-Anchor" href="#343-const及readonly"></a> 3.4.3 const及readonly</h4>
<ul>
<li>
<p>常量兼有只读和静态，所以常量一定是静态的，但只读字段不一定是。</p>
</li>
<li>
<p>只读字段可以在运行时决定（例如在构造函数中赋值），而常量必须在定义时就赋值。</p>
</li>
<li>
<p>只读字段可修饰任何类型。</p>
</li>
<li>
<p>即使对于引用类型的只读字段，我们也可以更改引用类型引用对象的值，但是， 我们不能更改引用类型的引用本身。</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">A a &#x3D; new A();</span><br><span class="line">a.print();                      &#x2F;&#x2F;0</span><br><span class="line">&#x2F;&#x2F;可以更改引用对象成员的值</span><br><span class="line">a.field.b &#x3D; 999;</span><br><span class="line">a.print();                      &#x2F;&#x2F;999</span><br><span class="line">&#x2F;&#x2F;但是不可以更改引用本身</span><br><span class="line">&#x2F;&#x2F;a.field &#x3D; new B();</span><br><span class="line">&#x2F;&#x2F;a.str &#x3D; &quot;hello&quot;;</span><br></pre></td></tr></table></figure>
<h4 id="344-sealed及abstract"><a class="markdownIt-Anchor" href="#344-sealed及abstract"></a> 3.4.4 sealed及abstract</h4>
<ul>
<li>
<p>sealed类——不可继承</p>
</li>
<li>
<p>abstract类——不可实例化(new)</p>
</li>
<li>
<p>abstract的方法体，不用{}，用;</p>
<ul>
<li>abstract	类型	方法名(参数列表);</li>
</ul>
</li>
</ul>
<h4 id="小结"><a class="markdownIt-Anchor" href="#小结"></a> 小结</h4>
<img src="3 类/2.png" alt="2" style="zoom:80%;" />
<h3 id="35-接口"><a class="markdownIt-Anchor" href="#35-接口"></a> 3.5 接口</h3>
<ul>
<li>接口是一个引用类型，比抽象类更抽象</li>
<li>接口能实现多继承</li>
</ul>
<p>定义一个接口</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface IStringList</span><br><span class="line">&#123;</span><br><span class="line">    void Add(string s);</span><br><span class="line">    int Count&#123;get;&#125;</span><br><span class="line">	string this[int index] &#123;get; set;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>public、abstract这两个关键词不写出来</p>
<h4 id="351-同名"><a class="markdownIt-Anchor" href="#351-同名"></a> 3.5.1 同名</h4>
<ul>
<li>方法名前写接口名</li>
<li>调用前先强制转换((IWindow))f.Close()</li>
</ul>
<h3 id="36-结构及枚举"><a class="markdownIt-Anchor" href="#36-结构及枚举"></a> 3.6 结构及枚举</h3>
<h4 id="361-struct"><a class="markdownIt-Anchor" href="#361-struct"></a> 3.6.1 struct</h4>
<p>struct是值类型</p>
<ul>
<li>
<p>结构不能包含无参数的构造方法</p>
</li>
<li>
<p>每个字在定义时，不能给初始值</p>
</li>
<li>
<p>构造方法中，必须对每个字段进行赋值</p>
</li>
<li>
<p>struct是sealed的，不能被继承</p>
</li>
<li>
<p>值类型变量在赋值时，实行的<strong>是字段的copy</strong></p>
</li>
</ul>
<p><strong>结构 VS 类</strong></p>
<p>​		类的对象是存储在堆空间中，结构存储在栈中。堆空间大，但访问速度较慢，栈空间小，访问速度相对更快。</p>
<p>​		类是引用类型，结构是值类型。<strong>结构体中声明的字段无法赋予初值，类可以</strong>。</p>
<h4 id="362-enum"><a class="markdownIt-Anchor" href="#362-enum"></a> 3.6.2 enum</h4>
<p>枚举值要用来表示符号化的常量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c &#x3D; (MyColor)Enum.Parse(typeof(MyColor), &quot;Red&quot;);</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第13章 深入理解C#语言</title>
    <url>/2021/04/14/C_/%E7%AC%AC13%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="深入理解c语言"><a class="markdownIt-Anchor" href="#深入理解c语言"></a> 深入理解C#语言</h2>
<h3 id="131-类型与转换"><a class="markdownIt-Anchor" href="#131-类型与转换"></a> 13.1 类型与转换</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/04/20/tbK5BFrychEksSD.png" alt="1.png" /></p>
<h4 id="1311-boxing-和-unboxing"><a class="markdownIt-Anchor" href="#1311-boxing-和-unboxing"></a> 13.1.1 Boxing 和 unboxing</h4>
<p><img src="https://i.loli.net/2021/04/20/xFgvzEn6cI3bTOV.png" alt="2.png" /></p>
<h3 id="132-变量及其传递"><a class="markdownIt-Anchor" href="#132-变量及其传递"></a> 13.2 变量及其传递</h3>
<h4 id="1321-ref参数及out参数"><a class="markdownIt-Anchor" href="#1321-ref参数及out参数"></a> 13.2.1 ref参数及out参数</h4>
<ul>
<li>ref参数在传之前必先赋值</li>
<li>out参数在函数中必须赋值后才能返回</li>
</ul>
<h3 id="134-动态类型确定"><a class="markdownIt-Anchor" href="#134-动态类型确定"></a> 13.4 动态类型确定</h3>
<h4 id="1341-反射"><a class="markdownIt-Anchor" href="#1341-反射"></a> 13.4.1 反射</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const string fileName &#x3D; @&quot;.\Test.exe&quot;;</span><br><span class="line"></span><br><span class="line">Assembly assembly &#x3D; Assembly.LoadFrom(fileName);</span><br><span class="line">Type [] types &#x3D; assembly.GetTypes();</span><br><span class="line">foreach(Type type in types)</span><br><span class="line">&#123;</span><br><span class="line">	MethodInfo [] methods &#x3D; type.GetMethods();</span><br><span class="line">    foreach(MethodInfo m in methods)</span><br><span class="line">        Console.WriteLine(m.ToString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="135-对象构造与析构"><a class="markdownIt-Anchor" href="#135-对象构造与析构"></a> 13.5 对象构造与析构</h3>
<h4 id="1351-构造方法的执行过程"><a class="markdownIt-Anchor" href="#1351-构造方法的执行过程"></a> 13.5.1 构造方法的执行过程</h4>
<ul>
<li>若有this(…)，转向之</li>
<li>执行域的初始化</li>
<li>转到base</li>
<li>执行方法体</li>
</ul>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第4章 C#语言高级特性</title>
    <url>/2021/04/05/C_/%E7%AC%AC4%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="c语言高级特性"><a class="markdownIt-Anchor" href="#c语言高级特性"></a> C#语言高级特性</h2>
<h3 id="41-委托delegate"><a class="markdownIt-Anchor" href="#41-委托delegate"></a> 4.1 委托(delegate)</h3>
<h4 id="声明"><a class="markdownIt-Anchor" href="#声明"></a> 声明</h4>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public delegate double MyDelegate(double x);</span><br></pre></td></tr></table></figure>
<h4 id="实例化"><a class="markdownIt-Anchor" href="#实例化"></a> 实例化</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyDeletated d2 &#x3D; new MyDelegate(obj.myMethod);</span><br></pre></td></tr></table></figure>
<h4 id="调用"><a class="markdownIt-Anchor" href="#调用"></a> 调用</h4>
<p>委托变量名（参数列表）</p>
<h4 id="委托的合并多播multicasting"><a class="markdownIt-Anchor" href="#委托的合并多播multicasting"></a> 委托的合并/多播(Multicasting)</h4>
<ul>
<li>一个委托实例中可以“包含”多个函数</li>
<li>调用委托，就是调用其中多个函数</li>
</ul>
<p><strong>运算符 +、 -、 +=、 -=</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delegate int NumberChanger(int n);</span><br><span class="line">namespace DelegateAppl</span><br><span class="line">&#123;</span><br><span class="line">   class TestDelegate</span><br><span class="line">   &#123;</span><br><span class="line">      static int num &#x3D; 10;</span><br><span class="line">      public static int AddNum(int p)</span><br><span class="line">      &#123;</span><br><span class="line">         num +&#x3D; p;</span><br><span class="line">         return num;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      public static int MultNum(int q)</span><br><span class="line">      &#123;</span><br><span class="line">         num *&#x3D; q;</span><br><span class="line">         return num;</span><br><span class="line">      &#125;</span><br><span class="line">      public static int getNum()</span><br><span class="line">      &#123;</span><br><span class="line">         return num;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      static void Main(string[] args)</span><br><span class="line">      &#123;</span><br><span class="line">         &#x2F;&#x2F; 创建委托实例</span><br><span class="line">         NumberChanger nc;</span><br><span class="line">         NumberChanger nc1 &#x3D; new NumberChanger(AddNum);</span><br><span class="line">         NumberChanger nc2 &#x3D; new NumberChanger(MultNum);</span><br><span class="line">         nc &#x3D; nc1;</span><br><span class="line">         nc +&#x3D; nc2;</span><br><span class="line">         &#x2F;&#x2F; 调用多播</span><br><span class="line">         nc(5);</span><br><span class="line">         Console.WriteLine(&quot;Value of Num: &#123;0&#125;&quot;, getNum());</span><br><span class="line">         Console.ReadKey();</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="委托的转换与相等"><a class="markdownIt-Anchor" href="#委托的转换与相等"></a> 委托的转换与相等</h4>
<ul>
<li>委托的转换
<ul>
<li>按声明的名称判断</li>
</ul>
</li>
<li>委托的相等
<ul>
<li>按内容（即“包含的函数”）来判断</li>
<li>有点像两个字符串的“equals”判断</li>
</ul>
</li>
</ul>
<h3 id="42-事件"><a class="markdownIt-Anchor" href="#42-事件"></a> 4.2 事件</h3>
<h4 id="按钮点击事件基本的写法"><a class="markdownIt-Anchor" href="#按钮点击事件基本的写法"></a> 按钮点击事件基本的写法</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.button1.Click +&#x3D; new System.EventHandler(this.button1_Click);</span><br><span class="line"></span><br><span class="line">private void button1_Click(object sender, EventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    this.label1.Text &#x3D; DateTime.Now.ToString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="声明-2"><a class="markdownIt-Anchor" href="#声明-2"></a> 声明</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public event 委托名 事件名;</span><br></pre></td></tr></table></figure>
<h4 id="事件的注册与移除"><a class="markdownIt-Anchor" href="#事件的注册与移除"></a> 事件的注册与移除</h4>
<ul>
<li>事件名+= 或 -=</li>
<li>在事件所在类外面，只能用以上两个运算符</li>
</ul>
<h4 id="事件的发生激发"><a class="markdownIt-Anchor" href="#事件的发生激发"></a> 事件的发生（激发）</h4>
<ul>
<li>事件名（参数列表）</li>
<li>相当于回调所注册的函数</li>
</ul>
<h4 id="定义及使用事件的6步曲"><a class="markdownIt-Anchor" href="#定义及使用事件的6步曲"></a> 定义及使用事件的6步曲</h4>
<p><img src="https://i.loli.net/2021/04/20/nuyQB62FlgackiO.png" alt="1.png" /></p>
<h4 id="事件与委托的关系"><a class="markdownIt-Anchor" href="#事件与委托的关系"></a> 事件与委托的关系</h4>
<ul>
<li>事件一定有相关的委托类型</li>
<li>与委托实例一样，事件也“包含”多个函数</li>
<li>事件的运算受更多限制（在类外只能用+=或-=）</li>
</ul>
<h4 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h4>
<ul>
<li>事件是一种消息机制</li>
<li>事件源调用事件，别的类注册时间</li>
<li>事件的类型是一个委托</li>
</ul>
<h3 id="43-lambda表达式"><a class="markdownIt-Anchor" href="#43-lambda表达式"></a> 4.3 Lambda表达式</h3>
<h4 id="431-泛型"><a class="markdownIt-Anchor" href="#431-泛型"></a> 4.3.1 泛型</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">T add&lt;T&gt; (T a, T b)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="432-匿名方法"><a class="markdownIt-Anchor" href="#432-匿名方法"></a> 4.3.2 匿名方法</h4>
<p>不写名字，直接写方法体的函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">delegate(参数)&#123;方法体&#125;</span><br><span class="line"></span><br><span class="line">new Thread(delegate()&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>可以省略参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(delegate&#123;Console.Write(&quot;my function&quot;;)&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="433-lambda表达式"><a class="markdownIt-Anchor" href="#433-lambda表达式"></a> 4.3.3 Lambda表达式</h4>
<ul>
<li><strong>相当于匿名方法的简写</strong>
<ul>
<li>省略delegate，甚至<strong>省略参数类型</strong>，会<strong>自动推算参数类型</strong></li>
<li>直接用（参数）=&gt;{语句或表达式}</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Thread(()&#x3D;&gt;&#123;Console.Write(&quot;my function&quot;);&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="434-linq"><a class="markdownIt-Anchor" href="#434-linq"></a> 4.3.4 Linq</h4>
<p>Language Integrated Query 集成查询语言</p>
<h3 id="44-运算符重载"><a class="markdownIt-Anchor" href="#44-运算符重载"></a> 4.4 运算符重载</h3>
<h4 id="441-一元运算符"><a class="markdownIt-Anchor" href="#441-一元运算符"></a> 4.4.1 一元运算符</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static 类型 operator 一元运算符(类型 参数名)&#123;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="442-类型转换运算符"><a class="markdownIt-Anchor" href="#442-类型转换运算符"></a> 4.4.2 类型转换运算符</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public static implicit operator 类型(类型 参数名)&#123;&#125;(隐式)</span><br><span class="line">public static explicit operator 类型(类型 参数名)&#123;&#125;(强制)</span><br></pre></td></tr></table></figure>
<h3 id="45-异常处理"><a class="markdownIt-Anchor" href="#45-异常处理"></a> 4.5 异常处理</h3>
<p>子类异常写前面、更一般的异常写后面</p>
<ul>
<li>catch{}表示捕获所有类型的异常</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try&#123;...&#125;</span><br><span class="line">catch(Exception e)&#123;...&#125;</span><br><span class="line">finally&#123;...&#125;</span><br></pre></td></tr></table></figure>
<p><strong>抛出异常</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(xxx) throw new SomeException;</span><br></pre></td></tr></table></figure>
<h4 id="451-内部异常"><a class="markdownIt-Anchor" href="#451-内部异常"></a> 4.5.1 内部异常</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.IO;</span><br><span class="line">public class Program</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main( )</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            try</span><br><span class="line">            &#123;</span><br><span class="line">                var num &#x3D; int.Parse(&quot;abc&quot;);                </span><br><span class="line">            &#125;</span><br><span class="line">            catch ( Exception inner )</span><br><span class="line">            &#123;</span><br><span class="line">                try</span><br><span class="line">                &#123;</span><br><span class="line">                    var openLog &#x3D; File.Open(&quot;DoesNotExist&quot;, FileMode.Open);</span><br><span class="line">                &#125;</span><br><span class="line">                catch</span><br><span class="line">                &#123;</span><br><span class="line">                    throw new FileNotFoundException(&quot;OutterException&quot;, inner);</span><br><span class="line">                &#125;                              </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        catch ( Exception e)</span><br><span class="line">        &#123;</span><br><span class="line">            string inMes, outMes;</span><br><span class="line">            if (e.InnerException !&#x3D; null)</span><br><span class="line">                inMes &#x3D; e.InnerException.Message;</span><br><span class="line">            outMes &#x3D; e.Message;</span><br><span class="line">        &#125;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，将abc转换为int会抛出FormatException异常；打开了一个不存在的文件，会抛出FileNotFoundException异常，<strong>由于我将捕获到的异常作为了FileNotFoundException的内部异常， 我在外部就可以通过内部异常（InnerException）来知道第一个FormatException异常</strong>。<br />
此外，如果一个异常的内部异常为空，通常意味着它是造成当前异常状态的根源。</p>
<h3 id="46-atrribute"><a class="markdownIt-Anchor" href="#46-atrribute"></a> 4.6 Atrribute</h3>
<p>Attribute是与类、结构、方法等元素相关的额外信息，是对元信息的扩展</p>
<h4 id="461-自定义attribute"><a class="markdownIt-Anchor" href="#461-自定义attribute"></a> 4.6.1 自定义Attribute</h4>
<ul>
<li>从System.Attribute继承而来</li>
<li>名字要用xxxAttribute</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[AttributeUsage(AttributeTargets.Class | </span><br><span class="line">               AttributeTargets.Method, </span><br><span class="line">               AllowMultiple &#x3D; true)]</span><br><span class="line">public class HelpAttribute : System.Attribute</span><br><span class="line">&#123;</span><br><span class="line">    public readonly string Url;		&#x2F;&#x2F; 位置参数</span><br><span class="line">    private string topic;			&#x2F;&#x2F; 命名参数</span><br><span class="line">    public string Topic&#123;get; set;&#125;</span><br><span class="line">   	public HelpAttribute(string url)</span><br><span class="line">    &#123;</span><br><span class="line">        this.Url &#x3D; Url;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="47-c语言中的其他成分"><a class="markdownIt-Anchor" href="#47-c语言中的其他成分"></a> 4.7 C#语言中的其他成分</h3>
<h4 id="471-编译预处理"><a class="markdownIt-Anchor" href="#471-编译预处理"></a> 4.7.1 编译预处理</h4>
<p><strong>标识符声明</strong></p>
<ul>
<li>
<p>#define定义一个标识符</p>
</li>
<li>
<p>#undef“取消定义”一个标识符</p>
</li>
</ul>
<p><strong>条件处理</strong></p>
<ul>
<li>#if、#elif、#else、#endif</li>
</ul>
<p><strong>信息报告</strong></p>
<ul>
<li>#error、#warning</li>
</ul>
<p><strong>行号标记</strong></p>
<ul>
<li>#line行号</li>
</ul>
<h4 id="472-unsafe及指针"><a class="markdownIt-Anchor" href="#472-unsafe及指针"></a> 4.7.2 unsafe及指针</h4>
<ol>
<li>
<p>用指针需要加上unsafe</p>
</li>
<li>
<p>fixed及指针</p>
<p>fixed(类型* 指针名 = 表达式) 语句</p>
</li>
<li>
<p>sizeof运算符</p>
<p>sizeof(简单或结构类型名)</p>
</li>
<li>
<p>stackalloc</p>
<p>在栈上分配的内存，而不是在堆上，因此不会担心内存被垃圾回收器自动回收。</p>
</li>
</ol>
<h3 id="48-程序的组织"><a class="markdownIt-Anchor" href="#48-程序的组织"></a> 4.8 程序的组织</h3>
<h4 id="481-名字空间"><a class="markdownIt-Anchor" href="#481-名字空间"></a> 4.8.1 名字空间</h4>
<h4 id="482-嵌套类型"><a class="markdownIt-Anchor" href="#482-嵌套类型"></a> 4.8.2 嵌套类型</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A&#123;public class B&#125;</span><br></pre></td></tr></table></figure>
<h4 id="483-程序集"><a class="markdownIt-Anchor" href="#483-程序集"></a> 4.8.3 程序集</h4>
<h3 id="49-语法总结"><a class="markdownIt-Anchor" href="#49-语法总结"></a> 4.9 语法总结</h3>
<h4 id="491-类的成员"><a class="markdownIt-Anchor" href="#491-类的成员"></a> 4.9.1 类的成员</h4>
<p><strong>常数</strong></p>
<p><strong>域</strong></p>
<ul>
<li>它是类中的变量</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>它实现了可以被类实现的计算和行为</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>它定义了命名的属性和与对这个属性进行读写的相关行为</li>
</ul>
<p><strong>事件</strong></p>
<ul>
<li>它定义了由类产生的通知</li>
</ul>
<p><strong>索引</strong></p>
<ul>
<li>它允许类的实例通过与数组相同的方法来索引</li>
</ul>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第7章 Windows窗体应用与控件</title>
    <url>/2021/04/08/C_/%E7%AC%AC7%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="windows窗体应用与控件"><a class="markdownIt-Anchor" href="#windows窗体应用与控件"></a> Windows窗体应用与控件</h2>
<h3 id="71-布局与事件"><a class="markdownIt-Anchor" href="#71-布局与事件"></a> 7.1 布局与事件</h3>
<h4 id="711-控件与容器"><a class="markdownIt-Anchor" href="#711-控件与容器"></a> 7.1.1 控件与容器</h4>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">容器.Controls.Add(...)</span><br></pre></td></tr></table></figure>
<h4 id="712-布局"><a class="markdownIt-Anchor" href="#712-布局"></a> 7.1.2 布局</h4>
<ul>
<li>Location——以像素为单位，设置控件的X坐标和Y坐标</li>
<li>Size——以像素为单位，设置控件的宽度和高度</li>
<li>Anchor——把控件附着在窗体的一个或多个边框上</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">this.button.Anchor &#x3D; (System.Windows.Forms.AnchorStyles.Bottom);</span><br></pre></td></tr></table></figure>
<ul>
<li>Dock——把控件和窗体的一个或多个边框连接起来</li>
</ul>
<p>在一定意义上，前两者是绝对布局，后两者是相对布局</p>
<h3 id="72-常用控件"><a class="markdownIt-Anchor" href="#72-常用控件"></a> 7.2 常用控件</h3>
<h4 id="721-control的常用属性"><a class="markdownIt-Anchor" href="#721-control的常用属性"></a> 7.2.1 Control的常用属性</h4>
<p><strong>外观</strong></p>
<ul>
<li>Size, Width, Height</li>
<li>Location, Left, Right, Top, Bottom</li>
<li>Font, ForeColor, BackColor</li>
</ul>
<p><strong>状态</strong></p>
<ul>
<li>Visible(可见), Enabled(使能/能不能用)</li>
<li>Text, BackgroundImage</li>
<li>Tag</li>
</ul>
<h4 id="722-control的常用事件"><a class="markdownIt-Anchor" href="#722-control的常用事件"></a> 7.2.2 Control的常用事件</h4>
<p><strong>KeyXXX键盘事件</strong></p>
<p>KeyDown	KeyUp	KeyPress</p>
<p><strong>MouseXXX鼠标事件</strong></p>
<p>MouseDown, MouseUp, MouseMove, MouseEnter, MouseHover, MouseLeave</p>
<p><strong>Click/DoubleClick事件</strong></p>
<p><strong>GotFocus事件</strong></p>
<p><strong>TextChange事件</strong></p>
<h4 id="723-常用控件"><a class="markdownIt-Anchor" href="#723-常用控件"></a> 7.2.3 常用控件</h4>
<ul>
<li>
<p>Label</p>
</li>
<li>
<p>LinkedLabel</p>
</li>
<li>
<p>TextBox</p>
<ul>
<li>PasswordChar    可使之成为密码框  #、X</li>
<li>MultiLine    多行文本       ScrollBars    滚动条</li>
<li>ReadOnly</li>
</ul>
</li>
<li>
<p>Button</p>
</li>
<li>
<p>复选框   CheckBox</p>
</li>
<li>
<p>单选框   RadioButton</p>
<ul>
<li>Checked属性</li>
<li>容器，如GroupBox</li>
</ul>
</li>
<li>
<p>列表框    ListBox</p>
</li>
<li>
<p>组合框    ComboBox</p>
<ul>
<li>复选框列表</li>
<li>Xxx.Items.Add(…)</li>
</ul>
</li>
<li>
<p>数字框    NumbericUpDown</p>
<ul>
<li>Value属性</li>
</ul>
</li>
<li>
<p>日期时间框    DateTimePicker</p>
<ul>
<li>Value属性</li>
<li>Format及CustomFormat属性“yy-MM-dd”</li>
</ul>
</li>
<li>
<p>掩码文本框    MaskedTextBox</p>
<ul>
<li>Mask属性</li>
</ul>
</li>
<li>
<p>进度条    ProgressBar</p>
<ul>
<li>Maximum    Minimum</li>
<li>Step（步进值）    Value（当前值）</li>
</ul>
</li>
<li>
<p>图片框    PictureBox</p>
<ul>
<li>Image属性</li>
<li>SizeMode属性</li>
</ul>
</li>
<li>
<p>富文本框    RichTextBox</p>
<ul>
<li>.Select(start, len)    .SelectText = “…”    .SelectionColor/Font</li>
</ul>
</li>
<li>
<p>网页浏览器    WebBrowser</p>
<ul>
<li>Navigate(“<a href="http://www.baidu.com" target="_blank" rel="noopener">http://www.baidu.com</a>”)</li>
</ul>
</li>
<li>
<p>TreeView</p>
</li>
<li>
<p>ListView</p>
</li>
</ul>
<h4 id="724-容器控件"><a class="markdownIt-Anchor" href="#724-容器控件"></a> 7.2.4 容器控件</h4>
<ul>
<li>
<p>流式布局面板    FlowLayoutPanel</p>
</li>
<li>
<p>成组框                GroupBox</p>
</li>
<li>
<p>面板                    Panel</p>
</li>
<li>
<p>分隔容器            SplitContainer</p>
</li>
<li>
<p>选项卡                TabControl</p>
</li>
<li>
<p>表格布局面板     TableLayoutPanel</p>
</li>
</ul>
<h3 id="73-窗体"><a class="markdownIt-Anchor" href="#73-窗体"></a> 7.3 窗体</h3>
<p>Form类是Control类的子类</p>
<h4 id="731-多窗体"><a class="markdownIt-Anchor" href="#731-多窗体"></a> 7.3.1 多窗体</h4>
<p><strong>打开与关闭</strong></p>
<ul>
<li>Show()</li>
<li>ShowDialog()</li>
</ul>
<p><strong>交互信息</strong></p>
<ul>
<li>static变量</li>
<li>通过构造函数或属性传递变量</li>
</ul>
<h3 id="75-用户控件"><a class="markdownIt-Anchor" href="#75-用户控件"></a> 7.5 用户控件</h3>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第8章 绘图及图像</title>
    <url>/2021/04/09/C_/%E7%AC%AC8%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="绘图及图像"><a class="markdownIt-Anchor" href="#绘图及图像"></a> 绘图及图像</h2>
<h3 id="81-绘图基础gdi"><a class="markdownIt-Anchor" href="#81-绘图基础gdi"></a> 8.1 绘图基础GDI+</h3>
<a id="more"></a>
<p>GDI：Graphics Device Interface（图形设备界面）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graphics g &#x3D; this.CreateGraphics();</span><br><span class="line">Pen pen &#x3D; new Pen(Color.Red, 2);</span><br><span class="line">Brush brush &#x3D; new SolidBrush(Color.Blue);</span><br><span class="line">Font font &#x3D; new Font(&quot;宋体&quot;, 25);</span><br><span class="line">Rectangle rect &#x3D; new Rectangle(20, 120, 100, 160);</span><br><span class="line">g.DrawLine(pen, 20, 100, 100, 100);</span><br><span class="line">g.DrawRectangle(pen, rect);</span><br><span class="line">g.DrawString(&quot;GDI+图形编程&quot;, font, brush, 20, 20);</span><br><span class="line">brush.Dispose(); font.Dispose(); pen.Dispose();</span><br><span class="line">g.Dispose();</span><br></pre></td></tr></table></figure>
<h4 id="811-坐标系统"><a class="markdownIt-Anchor" href="#811-坐标系统"></a> 8.1.1 坐标系统</h4>
<p>(0, 0)	——&gt;	(x, 0)</p>
<p>​	⬇</p>
<p>(0, y)</p>
<h4 id="812-systemdrawing中常用的结构"><a class="markdownIt-Anchor" href="#812-systemdrawing中常用的结构"></a> 8.1.2 System.Drawing中常用的结构</h4>
<h5 id="color"><a class="markdownIt-Anchor" href="#color"></a> Color</h5>
<p><strong>静态成员</strong></p>
<p>Color.Red</p>
<p><strong>静态方法</strong></p>
<ul>
<li>FromArab</li>
<li>FromKnownColor</li>
<li>FromName</li>
</ul>
<h5 id="size和sizef"><a class="markdownIt-Anchor" href="#size和sizef"></a> Size和SizeF</h5>
<h5 id="point"><a class="markdownIt-Anchor" href="#point"></a> Point</h5>
<h5 id="rectangle"><a class="markdownIt-Anchor" href="#rectangle"></a> Rectangle</h5>
<h3 id="82-绘图对象及绘图方法"><a class="markdownIt-Anchor" href="#82-绘图对象及绘图方法"></a> 8.2 绘图对象及绘图方法</h3>
<h4 id="821-得到graphics对象"><a class="markdownIt-Anchor" href="#821-得到graphics对象"></a> 8.2.1 得到Graphics对象</h4>
<ul>
<li>
<p>OnPaint事件中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graphics g &#x3D; e.Graphics;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>在其他情况使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Graphics g &#x3D; this.CreateGraphics();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="822-释放graphics"><a class="markdownIt-Anchor" href="#822-释放graphics"></a> 8.2.2 释放Graphics</h4>
<ul>
<li>g.Dispose();</li>
</ul>
<p>用这样也可以using(Graphics g = this.CreateGraphics()) { …. }</p>
<ul>
<li>这种写法，相当于try{…….} finally{ g.Dispose(); }</li>
</ul>
<h4 id="823graphics对象绘图方法"><a class="markdownIt-Anchor" href="#823graphics对象绘图方法"></a> 8.2.3Graphics对象绘图方法</h4>
<img src="https://i.loli.net/2021/04/20/Dvd5e8jXiASCMha.png" alt="1.png" style="zoom:80%;" />
<ul>
<li>Graphics对象绘制实心图形方法</li>
</ul>
<img src="https://i.loli.net/2021/04/20/pK2ZiPY3r4FTEbC.png" alt="2.png" style="zoom:80%;" />
<h4 id="824-pen画笔"><a class="markdownIt-Anchor" href="#824-pen画笔"></a> 8.2.4 Pen画笔</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Pen pen&#x3D; new Pen(Color.Blue,5);</span><br></pre></td></tr></table></figure>
<h4 id="825-drawstring方法"><a class="markdownIt-Anchor" href="#825-drawstring方法"></a> 8.2.5 DrawString方法</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DrawString(string,Font,Brush,RectangleF);</span><br></pre></td></tr></table></figure>
<h4 id="826-path"><a class="markdownIt-Anchor" href="#826-path"></a> 8.2.6 Path</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GraphicsPath gp &#x3D; new ;</span><br><span class="line">gp.AddString();</span><br><span class="line">Brush brush &#x3D; new;</span><br><span class="line">e.Graphics.DrawPath(Pens.Black, gp);</span><br><span class="line">e.Graphics.FillPath(brush, gp);</span><br></pre></td></tr></table></figure>
<h3 id="84-控件的重绘及双缓冲"><a class="markdownIt-Anchor" href="#84-控件的重绘及双缓冲"></a> 8.4 控件的重绘及双缓冲</h3>
<h4 id="841-处理重绘和无效操作"><a class="markdownIt-Anchor" href="#841-处理重绘和无效操作"></a> 8.4.1 处理重绘和无效操作</h4>
<p>当窗体被覆盖，前面的窗体移开后需要重绘</p>
<ul>
<li>调用以下几个方法
<ul>
<li>
<p>void Invalidate();</p>
</li>
<li>
<p>void Invalidate( Rectangle ) ;</p>
<p>使控件的特定区域无效并向控件发送绘制消息</p>
</li>
<li>
<p>void Update();</p>
<p>使控件重绘其工作区内的无效区域</p>
</li>
<li>
<p>void Refresh();</p>
<p>相当于this.Invalidate(true); this.Update();</p>
</li>
</ul>
</li>
</ul>
<h4 id="842-双缓冲技术"><a class="markdownIt-Anchor" href="#842-双缓冲技术"></a> 8.4.2 双缓冲技术</h4>
<p>在内存中画好再显示在窗体上</p>
<ol>
<li>
<p>在内存中建立一块“虚拟画布”：</p>
<p>Bitmap bmp = new Bitmap(600, 600);</p>
</li>
<li>
<p>获取这块内存画布的Graphics引用：</p>
<p>Graphics g = Graphics.FromImage(bmp);</p>
</li>
<li>
<p>在这块内存画布上绘图：</p>
<p>g.FillEllipse(brush, i* 10, j * 10, 10, 10);</p>
<p>g.DrawLine() g.DrawString()等等</p>
</li>
<li>
<p>将内存画布画到窗口中</p>
<p>this.CreateGraphics().DrawImage(bmp, 0, 0);</p>
</li>
</ol>
<p><strong>控件的DoubleBuffered属性</strong></p>
<p>在framework3以上版本中有</p>
<h3 id="85-图像处理"><a class="markdownIt-Anchor" href="#85-图像处理"></a> 8.5 图像处理</h3>
<h4 id="851-bitmap类"><a class="markdownIt-Anchor" href="#851-bitmap类"></a> 8.5.1 Bitmap类</h4>
<p>可以处理BMP、Jpeg、GIF、PNG等格式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Bitmap bt1 &#x3D; new Bitmap(“c:\\1.bmp”);</span><br><span class="line">Bitmap bt2 &#x3D; new Bitmap(bt1,200,300);</span><br><span class="line">bt3.FromFile(“文件名称”);</span><br></pre></td></tr></table></figure>
<h4 id="852-图像处理"><a class="markdownIt-Anchor" href="#852-图像处理"></a> 8.5.2 图像处理</h4>
<p><strong>使用指针逐点处理</strong></p>
<p>反转、变灰、加亮……</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 需要设置unsafe</span><br><span class="line">bitmapData &#x3D; bitmap.LockBits(bounds, ImageLockMode.ReadWrite, PixelFormat.Format24bppRgb);</span><br><span class="line">pBase &#x3D; (Bypte*)bitmapData.Scan0.ToPointer();</span><br><span class="line">(PixelData*)(pBase + y * stride + x * sizeof(PixelData));</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第5章 基础类及常用算法</title>
    <url>/2021/04/06/C_/%E7%AC%AC5%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="基础类及常用算法"><a class="markdownIt-Anchor" href="#基础类及常用算法"></a> 基础类及常用算法</h2>
<h3 id="51-dotnet基本类库"><a class="markdownIt-Anchor" href="#51-dotnet基本类库"></a> 5.1 DotNet基本类库</h3>
<a id="more"></a>
<h3 id="52-类型转换"><a class="markdownIt-Anchor" href="#52-类型转换"></a> 5.2 类型转换</h3>
<p>任何对象都有以下方法</p>
<ul>
<li>ToString()、Equals()、GetType()</li>
<li>MemberwiseClone()等</li>
</ul>
<p>常量也是对象</p>
<h3 id="53-常用的类型"><a class="markdownIt-Anchor" href="#53-常用的类型"></a> 5.3 常用的类型</h3>
<h4 id="531-math类"><a class="markdownIt-Anchor" href="#531-math类"></a> 5.3.1 Math类</h4>
<ul>
<li>Abs()</li>
<li>Sin()、Cos()、Tan()</li>
<li>Round()</li>
<li>Exp()、Log()</li>
<li>Pow()</li>
</ul>
<h4 id="532-random类"><a class="markdownIt-Anchor" href="#532-random类"></a> 5.3.2 Random类</h4>
<ul>
<li>Next(100)	0~100</li>
<li>NextDouble()    0~1</li>
</ul>
<h4 id="533-datetime及timespan"><a class="markdownIt-Anchor" href="#533-datetime及timespan"></a> 5.3.3 DateTime及TimeSpan</h4>
<ul>
<li>new DateTime(y, m, d, h, m, s)</li>
<li>.Now</li>
<li>.ToString(“yyyy-MM-dd HH:mm:ss”)</li>
<li>.AddMinutes(5)</li>
<li>.Year, .Month, .Day, .Date</li>
</ul>
<p><strong>TimeSpan</strong></p>
<ul>
<li>两个日期相减</li>
</ul>
<h4 id="534-string类"><a class="markdownIt-Anchor" href="#534-string类"></a> 5.3.4 String类</h4>
<p>返回值为一个新串，<strong>不会对原字符串造成改变</strong>(immutable)</p>
<ul>
<li>
<p>.Length、.IndexOf、.LastInedxOf</p>
</li>
<li>
<p>.StartsWith、 .EndsWith</p>
</li>
<li>
<p>.Substring(idx, len)</p>
</li>
<li>
<p>.Trim、.TrimEnd、.PadLeft(补位)、.Insert、.Remove</p>
</li>
<li>
<p>.Split(‘;’)、string.Join</p>
</li>
</ul>
<h4 id="535-stringbuilder类"><a class="markdownIt-Anchor" href="#535-stringbuilder类"></a> 5.3.5 StringBuilder类</h4>
<p>StringBuilder内容可变</p>
<ul>
<li>在循环体中使用 += 可能会带来效率问题</li>
</ul>
<h3 id="54-集合-泛型"><a class="markdownIt-Anchor" href="#54-集合-泛型"></a> 5.4 集合、泛型</h3>
<h4 id="541-集合类"><a class="markdownIt-Anchor" href="#541-集合类"></a> 5.4.1 集合类</h4>
<p><strong>数组列表 ArrayList</strong></p>
<p>相当于动态数组</p>
<p><strong>哈希表 Hashtable</strong></p>
<p><strong>栈和队列Stack Queue</strong></p>
<h4 id="542-泛型集合"><a class="markdownIt-Anchor" href="#542-泛型集合"></a> 5.4.2 泛型集合</h4>
<p>System.Collections.Generic</p>
<ul>
<li>列表	List / LinkedList	SortedList</li>
<li>字典    Dictionary             SortedDictionary</li>
<li>集        HashSet                 SortedSet</li>
<li>栈，队列 Stack, Queue</li>
</ul>
<p><strong>ListTest</strong></p>
<ul>
<li>Add方法、Count属性、[i]索引器</li>
</ul>
<p><strong>HashtableTest</strong></p>
<ul>
<li>[]索引</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Test[&quot;Mr. John&quot;] &#x3D; &quot;071-222-33445&quot;;	&#x2F;&#x2F; 加入或修改</span><br><span class="line">Test[&quot;Mr. John&quot;] &#x3D; &quot;null&quot;;			&#x2F;&#x2F; 删除</span><br></pre></td></tr></table></figure>
<ul>
<li>Foreach遍历</li>
</ul>
<h4 id="543-排序"><a class="markdownIt-Anchor" href="#543-排序"></a> 5.4.3 排序</h4>
<ul>
<li>
<p>自己写</p>
</li>
<li>
<p>使用SortedXXX类</p>
</li>
<li>
<p>使用Array.Sort方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Array.Sort(ary, (a, b)&#x3D;&gt;a.Length - b.Length);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="55-常用算法"><a class="markdownIt-Anchor" href="#55-常用算法"></a> 5.5 常用算法</h3>
<p><strong>遍历</strong></p>
<p>for中用if</p>
<p><strong>迭代</strong></p>
<p>while中n = f(n)</p>
<p><strong>递归</strong></p>
<p>f(n)中用f(n - 1)</p>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第6章 流、文件</title>
    <url>/2021/04/07/C_/%E7%AC%AC6%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="流-文件"><a class="markdownIt-Anchor" href="#流-文件"></a> 流、文件</h2>
<h3 id="61-io及文件管理"><a class="markdownIt-Anchor" href="#61-io及文件管理"></a> 6.1 IO及文件管理</h3>
<h4 id="611-stream类"><a class="markdownIt-Anchor" href="#611-stream类"></a> 6.1.1 Stream类</h4>
<a id="more"></a>
<p><strong>按存取位置分</strong></p>
<ul>
<li>FileStream、MemoryStream、BufferedStream</li>
</ul>
<p><strong>读写类</strong></p>
<ul>
<li>BinaryReader和BinaryWriter</li>
<li>TextReader和TextWriter
<ul>
<li>StreamReader和StreamWriter</li>
<li>StringReader和StringWriter</li>
</ul>
</li>
</ul>
<p><strong>其关系</strong></p>
<ul>
<li>
<p>包装关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FileStream fs &#x3D; new FileStream(&quot;a.txt&quot;, FileMode.Create);</span><br><span class="line">StreamWriter writer &#x3D; new StreamWriter(fs);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="612-文件及文件夹管理"><a class="markdownIt-Anchor" href="#612-文件及文件夹管理"></a> 6.1.2 文件及文件夹管理</h4>
<p><strong>对文件和文件夹操作的类</strong></p>
<ul>
<li>FileInfo			   （具体的文件）
<ul>
<li>使用FileInfo，就可以获取文件大小等各种信息</li>
</ul>
</li>
<li>File				      （提供static方法）</li>
<li>DirectoryInfo     （具体的文件夹）
<ul>
<li>获取文件夹大小等各种信息</li>
</ul>
</li>
<li>Directory            （提供static方法）</li>
<li>FileSystemInfo   （FileInfo + DirectoryInfo）</li>
<li>Path                     （文件路径类）</li>
</ul>
<h3 id="62-文件读写"><a class="markdownIt-Anchor" href="#62-文件读写"></a> 6.2 文件读写</h3>
<h4 id="621-streamreader-streamwriter"><a class="markdownIt-Anchor" href="#621-streamreader-streamwriter"></a> 6.2.1 StreamReader、StreamWriter</h4>
<p><strong>StreamReader</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new StreamReader(文件路径, FileEncode);</span><br></pre></td></tr></table></figure>
<ul>
<li>ReadLine、ReadToEnd、Read、Peek、Close</li>
</ul>
<p><strong>StreamWriter</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new StreamWriter(文件路径, FileMode, FileEncode)</span><br></pre></td></tr></table></figure>
<ul>
<li>WriteLine、Write、Flush、Close</li>
</ul>
<h4 id="622-二进制文件"><a class="markdownIt-Anchor" href="#622-二进制文件"></a> 6.2.2 二进制文件</h4>
<ul>
<li>Seek、Read</li>
</ul>
<p><strong>序列化</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[Serializable]</span><br><span class="line">class Book &#123;</span><br><span class="line"></span><br><span class="line">    public string name;</span><br><span class="line">    &#x2F;&#x2F;public double price;</span><br><span class="line">    public int num&#x3D;13; &#x2F;&#x2F;如果book的版本变了，反序列化时，这个默认值不会被执行</span><br><span class="line">    public string [] reader;</span><br><span class="line"></span><br><span class="line">    override public string ToString()&#123;</span><br><span class="line">        return name + &quot;:&quot; &#x2F;&#x2F;+ price </span><br><span class="line">            + &quot;:&quot; + string.Join(&quot;,&quot;,reader)</span><br><span class="line">            + &quot;:&quot; + num;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Static void Main(string[] args)</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F;Serialization of String Object</span><br><span class="line">    BinaryFormatter formatter &#x3D; new BinaryFormatter();</span><br><span class="line">    FileStream stream &#x3D; new FileStream(&quot;C:\\StrObj.t&quot;, FileMode.Create, </span><br><span class="line">                                       FileAccess.Write ,FileShare.None);</span><br><span class="line">	formatter.Serialize(stream, book);</span><br><span class="line">	stream.Close();</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;Deserialization of String Object</span><br><span class="line">    FileStream readstream &#x3D; new FileStream(&quot;C:\\StrObj.t&quot;, FileMode.Open , </span><br><span class="line">                                           FileAccess.Read ,FileShare.Read );</span><br><span class="line">	Book book2 &#x3D; (Book)formatter.Deserialize(readstream);</span><br><span class="line">	readstream.Close();</span><br><span class="line">	Console.WriteLine(book2);</span><br><span class="line">	Console.ReadLine();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="63-注册表"><a class="markdownIt-Anchor" href="#63-注册表"></a> 6.3 注册表</h3>
<p><strong>|注册表|</strong>：存放计算机运行方式的配置信息的树状表。其中包括Windows操作系统配置信息、应用程序配置信息、专用用户设备配置信息、环境配置信息等。</p>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第9章 文本处理及正则表达式</title>
    <url>/2021/04/10/C_/%E7%AC%AC9%E7%AB%A0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="文本处理及正则表达式"><a class="markdownIt-Anchor" href="#文本处理及正则表达式"></a> 文本处理及正则表达式</h2>
<h3 id="91-基于文本的应用"><a class="markdownIt-Anchor" href="#91-基于文本的应用"></a> 9.1 基于文本的应用</h3>
<a id="more"></a>
<ul>
<li>
<p>Console类</p>
</li>
<li>
<p>String类</p>
</li>
<li>
<p>StringBuilder类</p>
</li>
<li>
<p>System.Text.Encoding类</p>
<ul>
<li>
<p>.Default	.UTF8	.GetEncoding</p>
</li>
<li>
<p>.GetBytes(str)    .GetString(byte[])</p>
</li>
</ul>
</li>
</ul>
<h3 id="92-正则表达式"><a class="markdownIt-Anchor" href="#92-正则表达式"></a> 9.2 正则表达式</h3>
<h4 id="921-正则表达式中几个主要要素"><a class="markdownIt-Anchor" href="#921-正则表达式中几个主要要素"></a> 9.2.1 正则表达式中几个主要要素</h4>
<p><strong>字符</strong>  ab</p>
<p>大写表示非</p>
<ul>
<li>
<p>[a-zA-z] 即\w</p>
</li>
<li>
<p>[0-9] 即\d     [^0-9] 即\D</p>
</li>
<li>
<p>\s 即空白\S 即非空白</p>
</li>
<li>
<p>. 表任意</p>
</li>
</ul>
<p><strong>次数</strong> {2, 6}</p>
<ul>
<li>即{0,} + 即{1,} ? 即{0,1}</li>
</ul>
<ul>
<li>*? +? ?? 表示lazy匹配   (匹配到一次就算数)</li>
</ul>
<p><strong>|表示或者    ()表示成组</strong></p>
<p><strong>位置限定</strong></p>
<ul>
<li>^(首)     xxxxxx$ (尾)</li>
<li>\b单词边界    \B 非单词边界</li>
</ul>
<p><strong>(?&lt;名称&gt;xxxxxxxx)    表示对分组进行命名</strong></p>
<ul>
<li>在替换时, 使用${名称}</li>
<li>若不命名,则为​$1, $2等等    而$0 表示整个匹配</li>
</ul>
<p><strong>(?i:xxxxxxxxx)    表示选项(i表示忽略大小写)</strong></p>
<h4 id="922-regex"><a class="markdownIt-Anchor" href="#922-regex"></a> 9.2.2 Regex</h4>
<p>using System.Text.RegularExpressions;</p>
<p><strong>Static方法</strong></p>
<ul>
<li>Regex.IsMatch( s, pattern )</li>
</ul>
<p><strong>使用对象</strong></p>
<ul>
<li>
<p>Regex对象</p>
<ul>
<li>
<p>.IsMatch(s) 	.Match(s) 	.Matches(s)</p>
</li>
<li>
<p>.Replace(s, r)</p>
</li>
</ul>
</li>
<li>
<p>Match对象</p>
<ul>
<li>.Groups 各组	.Value 原串	.Result(xxxxx)替换</li>
</ul>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">string pattern &#x3D; @&quot;^[\. a-zA-z]+ (?&lt;name&gt;\w+), [a-zA-z]+, x(?&lt;ext&gt;\d+)$&quot;;</span><br><span class="line">string[] sa &#x3D;</span><br><span class="line">&#123;</span><br><span class="line">    &quot;Dr. David Jones, Ophthalmology, x2441&quot;,</span><br><span class="line">    &quot;Ms. Cindy Harriman, Registry, x6231&quot;,</span><br><span class="line">    &quot;Mr. Chester Addams, Mortuary, x1667&quot;,</span><br><span class="line">    &quot;Dr. Hawkeye Pierce, Surgery, x0986&quot;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Regex rx &#x3D; new Regex(pattern);</span><br><span class="line">foreach (string s in sa)</span><br><span class="line">&#123;</span><br><span class="line">    Match m &#x3D; rx.Match(s);</span><br><span class="line">    if (m.Success)</span><br><span class="line">        Console.Write(m.Result(&quot;$&#123;ext&#125;,  $&#123;name&#125;, $1&quot;));</span><br><span class="line">    Console.WriteLine(&quot;\t&quot; +</span><br><span class="line">        rx.Replace(s, &quot;姓：$&#123;name&#125;, 分机号：$&#123;ext&#125;&quot;));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>C#&amp;nbsp;</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 绪论</title>
    <url>/2019/11/24/DS/%E7%AC%AC%E4%B8%80%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="11-计算"><a class="markdownIt-Anchor" href="#11-计算"></a> 1.1 计算</h3>
<h3 id="12-计算模型"><a class="markdownIt-Anchor" href="#12-计算模型"></a> 1.2 计算模型</h3>
<a id="more"></a>
<h3 id="13-大o记号"><a class="markdownIt-Anchor" href="#13-大o记号"></a> 1.3 大O记号</h3>
<p>O(1) &lt; O(logn) &lt; O(n) &lt; O(n<sup>c</sup>)  &lt; O(2<sup>n</sup>)</p>
<h3 id="14-算法分析"><a class="markdownIt-Anchor" href="#14-算法分析"></a> 1.4 算法分析</h3>
<h4 id="141-级数"><a class="markdownIt-Anchor" href="#141-级数"></a> 1.4.1 级数</h4>
<p><img src="https://i.loli.net/2019/11/24/V1btcgR9pLoyizm.jpg" alt="1.jpg" /></p>
<p><img src="https://i.loli.net/2019/11/24/1n7aKGZLTqxRCPd.jpg" alt="2.jpg" /></p>
<h4 id="142-循环"><a class="markdownIt-Anchor" href="#142-循环"></a> 1.4.2 循环</h4>
<p><img src="https://i.loli.net/2019/11/24/tP52nRFeaToH63E.jpg" alt="3.jpg" /></p>
<p><img src="https://i.loli.net/2019/11/24/c1pJ4HBTlyU89Rw.jpg" alt="4.jpg" /></p>
<h4 id="143-非极端元素"><a class="markdownIt-Anchor" href="#143-非极端元素"></a> 1.4.3 非极端元素</h4>
<p><img src="https://i.loli.net/2019/11/24/Z9nc42N8TmuShHY.jpg" alt="5.jpg" /></p>
<h4 id="144-封底估计"><a class="markdownIt-Anchor" href="#144-封底估计"></a> 1.4.4 封底估计</h4>
<p><img src="https://i.loli.net/2019/11/24/uR9e43iNdjlrTb2.jpg" alt="6.jpg" /></p>
<h3 id="15迭代与递归"><a class="markdownIt-Anchor" href="#15迭代与递归"></a> 1.5迭代与递归</h3>
<h4 id="151-减而治之"><a class="markdownIt-Anchor" href="#151-减而治之"></a> 1.5.1 减而治之</h4>
<p><img src="https://i.loli.net/2019/11/24/ATfNyjX3oYC1tOc.jpg" alt="7.jpg" /></p>
<h4 id="152-数组求和线性递归"><a class="markdownIt-Anchor" href="#152-数组求和线性递归"></a> 1.5.2 数组求和：线性递归</h4>
<p><img src="https://i.loli.net/2019/11/24/TVAbndXsEzlCtO6.jpg" alt="8.jpg" /></p>
<p><img src="https://i.loli.net/2019/11/24/UIr4lSGeDCPMsRZ.jpg" alt="10.jpg" /></p>
<h4 id="153-数组倒置"><a class="markdownIt-Anchor" href="#153-数组倒置"></a> 1.5.3 数组倒置</h4>
<p><img src="https://i.loli.net/2019/11/24/WSEHT8b1qiyFYj3.jpg" alt="11.jpg" /></p>
<h4 id="154-分而治之"><a class="markdownIt-Anchor" href="#154-分而治之"></a> 1.5.4 分而治之</h4>
<p><img src="https://i.loli.net/2019/11/24/FqYHMa5eWt7OX3k.jpg" alt="12.jpg" /></p>
<h4 id="155-二分递归数组求和"><a class="markdownIt-Anchor" href="#155-二分递归数组求和"></a> 1.5.5 二分递归：数组求和</h4>
<p><img src="https://i.loli.net/2019/11/24/5sRqHd7JokQPAVB.jpg" alt="13.jpg" /></p>
<p><img src="https://i.loli.net/2019/11/24/ejY9EtvipaHKTMX.jpg" alt="14.jpg" /></p>
<h4 id="156-二分递归-max2"><a class="markdownIt-Anchor" href="#156-二分递归-max2"></a> 1.5.6 二分递归: Max2</h4>
<p><img src="https://i.loli.net/2019/11/24/AiJe6Fn4aEmzMTI.jpg" alt="16.jpg" /></p>
<p><img src="https://i.loli.net/2019/11/25/bWtp5wHOoukqAzn.png" alt="1.5.6 1.png" /></p>
<p><img src="https://i.loli.net/2019/11/25/cGaI89uAQPBMtil.png" alt="1.5.6 2.png" /></p>
<h4 id="157-总结"><a class="markdownIt-Anchor" href="#157-总结"></a> 1.5.7 总结</h4>
<ul>
<li>算法
<ul>
<li>迭代：Iteration</li>
<li>递归：Recursion</li>
</ul>
</li>
<li>策略
<ul>
<li>减而治之：Decrease-and-conquer</li>
<li>分而治之：Divide-and-conquer</li>
</ul>
</li>
<li>分析方法
<ul>
<li>递归跟踪：Recursion trace</li>
<li>递归式：Recurrence</li>
</ul>
</li>
</ul>
<h3 id="16-动态规划"><a class="markdownIt-Anchor" href="#16-动态规划"></a> 1.6 动态规划</h3>
<h4 id="161-动态规划"><a class="markdownIt-Anchor" href="#161-动态规划"></a> 1.6.1 动态规划</h4>
<p><img src="https://i.loli.net/2019/11/26/zTJn8rQB3GsLpKd.png" alt="1.6.1_1_.png" /></p>
<h4 id="162-fibonacci"><a class="markdownIt-Anchor" href="#162-fibonacci"></a> 1.6.2 Fibonacci</h4>
<p class='katex-block katex-error' title='ParseError: KaTeX parse error: Can&#039;t use function &#039;$&#039; in math mode at position 28: …{\sqrt{5}+1}{2}$̲$							//1.618…'>\Phi = \frac{\sqrt{5}+1}{2}$$							//1.618

![1.6.2 _1_.png](https://i.loli.net/2019/11/26/LXgH2ymOrRYGutZ.png)



![1.6.2 (2).png](https://i.loli.net/2019/11/26/j1WKUn3YOlCeBEJ.png)

#### 1.6.3 最长公共子序列(Longest Common Subsequence)

##### 1.6.3.1 递归

![1.6.3.1 (1).png](https://i.loli.net/2019/11/26/RAWx31J5BuorUIc.png)



![1.6.3.1 (2).png](https://i.loli.net/2019/11/26/mpPSC6Z7J2Y8rKz.png)



![1.6.3.1 (3).png](https://i.loli.net/2019/11/26/KBsuFmtA8iq5kVP.png)



![1.6.3.1 (4).png](https://i.loli.net/2019/11/26/HipaucXqz6RrbZF.png)



![1.6.3.1 (5).png](https://i.loli.net/2019/11/26/zfdLshY5UkSJ49i.png)

##### 1.6.3.2 动态规划

![1.6.3.2(1).png](https://i.loli.net/2019/11/26/vCLoYAXsTZB2VUq.png)

</p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>递归</tag>
        <tag>二分</tag>
      </tags>
  </entry>
  <entry>
    <title>第七章 二叉搜索树</title>
    <url>/2020/09/19/DS/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-二叉搜索树"><a class="markdownIt-Anchor" href="#第七章-二叉搜索树"></a> 第七章 二叉搜索树</h2>
<h3 id="二叉搜索树"><a class="markdownIt-Anchor" href="#二叉搜索树"></a> 二叉搜索树</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BST</span> :</span> <span class="keyword">public</span> BinTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span>&amp; <span class="title">search</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="title">BinNodePosi</span><span class="params">(T)</span>&amp; <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    BinNodePosi(T) _hot;</span><br><span class="line">    BinNodePosi(T) connect34(</span><br><span class="line">    	BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),</span><br><span class="line">    BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T));</span><br><span class="line">    BinNodePosi(T) rotateAt(BinNodePosi(T) x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="搜索"><a class="markdownIt-Anchor" href="#搜索"></a> 搜索</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typname T&gt; BinNodePosi(T)&amp; BST&lt;T&gt;::search(<span class="keyword">const</span> T&amp; e)</span><br><span class="line">&#123; <span class="keyword">return</span> searchIn(_root, e, _hot = <span class="literal">NULL</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span>&amp; <span class="title">searchIn</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">	BinNodePosi(T)&amp; v,		<span class="comment">// 当前树根</span></span></span></span><br><span class="line"><span class="function"><span class="params">	<span class="keyword">const</span> T&amp; e,				<span class="comment">// 目标关键码</span></span></span></span><br><span class="line"><span class="function"><span class="params">	BinNodePosi(T)&amp; hot)</span>	<span class="comment">// 记忆热点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!v || (v-&gt;data == e)) <span class="keyword">return</span> v;	<span class="comment">// 返回成功/失败节点</span></span><br><span class="line">    hot = v;</span><br><span class="line">    <span class="keyword">return</span> searchIn((e &lt; v-&gt;data) ? v-&gt;lChild : v-&gt;rChild, e, hot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typname T&gt; BinNodePosi(T)&amp; BST&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    BinNodePosi(T)&amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x) &#123;</span><br><span class="line">        x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot);	<span class="comment">// 以e为关键码，以_hot为父</span></span><br><span class="line">        _size++;</span><br><span class="line">        updateHeightAbove(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;typname T&gt; <span class="keyword">bool</span> BST&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T) x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot);</span><br><span class="line">    _size--;</span><br><span class="line">    updateHeightAbove(_hot);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span></span></span><br><span class="line"><span class="function"><span class="title">removeAt</span><span class="params">(BinNodePosi(T)&amp; x, BinNodePosi(T)&amp; hot)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinNodePosi(T) w = x;				<span class="comment">// 实际被摘除的节点</span></span><br><span class="line">    BinNodePosi(T) succ = <span class="literal">NULL</span>;			<span class="comment">// 实际被删除节点的接替者</span></span><br><span class="line">    <span class="keyword">if</span>(!hasLChild(*x)) succ = x = x-&gt;rChild;		<span class="comment">// 如果单子节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(!hasRChild(*x)) succ = x = x-&gt;lChild;</span><br><span class="line">    <span class="keyword">else</span> &#123;											<span class="comment">// 双子节点</span></span><br><span class="line">        w = w-&gt;succ(); swap(x-&gt;data, w-&gt;data);		<span class="comment">// 寻找直接后继</span></span><br><span class="line">        BinNodePosi(T) u = w-&gt;parent;</span><br><span class="line">        (u == x ? u-&gt;rChild : u-&gt;lChild) = succ = w-&gt;rChild;</span><br><span class="line">    &#125;</span><br><span class="line">    hot = w-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(succ) succ-&gt;parent = hot;</span><br><span class="line">    <span class="built_in">release</span>(w-&gt;data); <span class="built_in">release</span>(w);</span><br><span class="line">    <span class="keyword">return</span> succ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="avl树"><a class="markdownIt-Anchor" href="#avl树"></a> AVL树</h3>
<p>​		|平衡因子| &lt; 1</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Balanced(x) (stature((x).lChild) == stature((x).rChild))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BalFac(x) (stature((x).lChild) - stature((x).rChild))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> AvlBalanced(x) </span></span><br><span class="line">((<span class="number">-2</span> &lt; BalFac(x)) &amp;&amp; (BalFac(x) &lt; <span class="number">2</span>))</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">AVL</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">public</span>:	<span class="comment">//BST::search()</span></span><br><span class="line">    BinNodePosi(T) insert(<span class="keyword">const</span> T&amp;);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>高度为h的AVL树：节点 n = fib(h + 3) - 1</li>
<li>remove操作最多导致父节点失衡</li>
<li>insert操作最多导致logn个祖先节点失衡</li>
<li>insert: O(1), remove: O(n)</li>
</ul>
<h4 id="重平衡"><a class="markdownIt-Anchor" href="#重平衡"></a> 重平衡</h4>
<pre><code>	**既然g(x)是因为x的引入而失衡，则p和v的高度均不会低于其各自的兄弟，可由g(x)找到p和v**
</code></pre>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在左、右孩子中取更高者，若登高，则与父亲p同侧者优先</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> tallerChild(x) (</span></span><br><span class="line">	stature((x).lChild) &gt; stature((x).rChild) ? (x)-&gt;lChild : (</span><br><span class="line">	stature((x).lChild) &lt; stature((x).rChild) ? (x)-&gt;rChild : (</span><br><span class="line">	IsLChild((*x)) ? (x)-&gt;lChild : (x)-&gt;rChild</span><br><span class="line">    )</span><br><span class="line">    )</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<h4 id="插入-2"><a class="markdownIt-Anchor" href="#插入-2"></a> 插入</h4>
<ul>
<li>
<p>调整插入节点x，x的父亲，离x最近的失衡祖先三个节点</p>
</li>
<li>
<p>三代节点同一方向，单旋后子树复衡，全树也复衡</p>
</li>
<li>
<p>三代节点之字形，双旋</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) AVL&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T)&amp; x = search(e); <span class="keyword">if</span>(x) <span class="keyword">return</span> x;</span><br><span class="line">    x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, hot); _size++; BinNodePosi(T) xx = x;</span><br><span class="line">    <span class="keyword">for</span>(BinNodePosi(T) g = x-&gt;parent; g; g = g-&gt;parent) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!AvlBalanced(*g)) &#123;</span><br><span class="line">            FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> xx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除-2"><a class="markdownIt-Anchor" href="#删除-2"></a> 删除</h4>
<ul>
<li>三代节点同一方向，单旋后复衡，子树高度未必复原，更高祖先仍可能失衡</li>
<li>双旋后子树高度收缩1，更高祖先可能失衡</li>
<li>失衡传播：自底而上，高层的某一节点由平衡转为失衡，之可能发生在下层失衡节点恢复平衡之后</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> AVL&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T)&amp; x = search(e); <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    removeAt(x, _hot); _size--;</span><br><span class="line">    <span class="keyword">for</span>(BinNodePosi(T) g = _hot; g; g = g-&gt;parent) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!AvlBalanced(*g))</span><br><span class="line">            g = FromParentTo(*g) =</span><br><span class="line">            rotateAt((tallerChild(tallerChild(g)));</span><br><span class="line">        updateHeight(g);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="34重构"><a class="markdownIt-Anchor" href="#34重构"></a> 3+4重构</h4>
<ul>
<li>按中序遍历，将祖孙三代命名为：a &lt; b &lt; c</li>
<li>按中序遍历，将四棵子树命名为：T<sub>0</sub> &lt; T<sub>1</sub> &lt; T<sub>2</sub> &lt; T<sub>3</sub></li>
</ul>
<p><img src="https://i.loli.net/2020/09/19/xlLTeQqdIp7tuXj.png" alt="image-20200919105312948.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) BST&lt;T&gt;::connect34(</span><br><span class="line">	BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,</span><br><span class="line">	BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, 		BinNodePosi(T) T3)</span><br><span class="line">&#123;</span><br><span class="line">    a-&gt;lChild = T0; <span class="keyword">if</span>(T0) T0-&gt;parent = a;</span><br><span class="line">    a-&gt;rChild = T1; <span class="keyword">if</span>(T1) T1-&gt;parent = a; updateHeight(a);</span><br><span class="line">    c-&gt;lChild = T2; <span class="keyword">if</span>(T2) T2-&gt;parent = c;</span><br><span class="line">    c-&gt;rChild = T3; <span class="keyword">if</span>(T3) T3-&gt;parent = c; updateHeight(c);</span><br><span class="line">    b-&gt;lChild = a; a-&gt;parent = b;</span><br><span class="line">    b-&gt;rChild = c; c-&gt;parent = b; updateHeight(b);</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/09/19/XBTRSPwOZzVlWLN.png" alt="image-20200919110058626.png" style="zoom:80%;" />				<img src="https://i.loli.net/2020/09/19/IPsxfOk3hiSZ75R.png" alt="image-20200919110111220.png" style="zoom:80%;" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 					<span class="comment">// 两种情况</span></span><br><span class="line">BinNodePosi(T) BST&lt;T&gt;::rotateAt(BinNodePosi(T) v) &#123;</span><br><span class="line">    BinNodePosi(T) p = v-&gt;parent, g = p-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(IsLChild(*p))</span><br><span class="line">        <span class="keyword">if</span>(IsRChild(*v)) &#123;</span><br><span class="line">            p-&gt;parent = g-&gt;parent;		<span class="comment">// 向上联接</span></span><br><span class="line">            <span class="keyword">return</span> connect34(v, p, g, </span><br><span class="line">            		v-&gt;lChild, v-&gt;rChild, p-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            v-&gt;parent = g-&gt;parent;		<span class="comment">// 向上联接 	</span></span><br><span class="line">            <span class="keyword">return</span> connect34(p, v, g,</span><br><span class="line">            		p-&gt;lChild, v-&gt;lChild, v-&gt;rChild, g-&gt;rChild);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(IsRChild(*p))</span><br><span class="line">            <span class="keyword">if</span>(IsRChild(*v)) &#123;</span><br><span class="line">                p-&gt;parent = g-&gt;parent;</span><br><span class="line">                <span class="keyword">return</span> connect34(g, p, v,</span><br><span class="line">                	g-&gt;lChild, p-&gt;lChild, v-&gt;lChild, v-&gt;rChild);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                v-&gt;parent = g-&gt;parent;</span><br><span class="line">                <span class="keyword">return</span> connect34(g, v, p,</span><br><span class="line">               		g-&gt;lChild, v-&gt;lChild, v-&gt;rChild, p-&gt;rChild);</span><br><span class="line">            &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>
<p>顺序性：任一节点均不小于/大于其左/右后代</p>
</li>
<li>
<p>单调性：BST的中序遍历，必然单调非降</p>
</li>
<li>
<p>高度渐进地不超过O(logn)，即可称作适度平衡</p>
</li>
<li>
<p>适度平衡地二叉树，称作平衡二叉搜索树(BBST)</p>
</li>
<li>
<p>等价BST</p>
<p>承袭关系可能颠倒，中序遍历完全一致</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>第三章 列表</title>
    <url>/2020/09/09/DS/%E7%AC%AC%E4%B8%89%E7%AB%A0%20%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-列表"><a class="markdownIt-Anchor" href="#第三章-列表"></a> 第三章 列表</h2>
<h3 id="插入排序"><a class="markdownIt-Anchor" href="#插入排序"></a> 插入排序</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::insertionSort</span> <span class="params">(ListNode* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> r = <span class="number">0</span>; r &lt; n; r++) &#123;</span><br><span class="line">        insertAfter(search(p-&gt;data, r, p), p-&gt;data);</span><br><span class="line">        p = p-&gt;succ; </span><br><span class="line">        <span class="built_in">remove</span>(p-&gt;pred);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="选择排序"><a class="markdownIt-Anchor" href="#选择排序"></a> 选择排序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::selectionSort</span><span class="params">(ListNode* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* head = p-&gt;pred;</span><br><span class="line">    ListNode* tail = p-&gt;succ;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        tail = tail-&gt;succ;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        ListNode* <span class="built_in">max</span> = selectMax(head-&gt;succ, n);</span><br><span class="line">        insertBefore(tail, <span class="built_in">remove</span>(<span class="built_in">max</span>));</span><br><span class="line">        tail = tail-&gt;pred;</span><br><span class="line">        n--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序"><a class="markdownIt-Anchor" href="#归并排序"></a> 归并排序</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::mergeSort</span><span class="params">(ListNode* p, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    ListNode* q = p;</span><br><span class="line">    <span class="keyword">int</span> m = n &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)		<span class="comment">// 均分</span></span><br><span class="line">        q = q-&gt;succ;</span><br><span class="line">    mergeSort(p, m);				<span class="comment">// 对前后子列表分别排序</span></span><br><span class="line">    mergeSort(q, n-m);</span><br><span class="line">    merge(p, m, *<span class="keyword">this</span>, q, n-m);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">List::merge</span><span class="params">(ListNode* p, <span class="keyword">int</span> n,List L,ListNode* q,<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode* pp = p-&gt;pred;</span><br><span class="line">    <span class="keyword">while</span>(m &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">if</span>(n &gt; <span class="number">0</span> &amp;&amp; p-&gt;data &lt;= q-&gt;data) &#123;</span><br><span class="line">            <span class="keyword">if</span>(q == (p = p-&gt;succ))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            n--;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">            insertBefore(p, L.<span class="built_in">remove</span>((q = q-&gt;succ)-&gt;pred));</span><br><span class="line">            m--;</span><br><span class="line">        &#125;</span><br><span class="line">    p = pp-&gt;succ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第九章 词典</title>
    <url>/2020/09/25/DS/%E7%AC%AC%E4%B9%9D%E7%AB%A0%20%E8%AF%8D%E5%85%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第九章-词典"><a class="markdownIt-Anchor" href="#第九章-词典"></a> 第九章 词典</h2>
<h3 id="散列函数"><a class="markdownIt-Anchor" href="#散列函数"></a> 散列函数</h3>
<h4 id="除余法"><a class="markdownIt-Anchor" href="#除余法"></a> 除余法</h4>
<a id="more"></a>
<p>hash(key) = key % M</p>
<ul>
<li>M为素数时，数据对散列表的覆盖最充分，分布最均匀</li>
</ul>
<h4 id="mad法"><a class="markdownIt-Anchor" href="#mad法"></a> MAD法</h4>
<p>a &gt; 0, b &gt; 0, a % M ≠ 0</p>
<p>hash(key) = ( a * key + b) % M</p>
<ul>
<li>引入a使原本相邻的关键码不再相邻</li>
<li>引入b增加偏移量消除不动点</li>
</ul>
<h4 id="平方取中"><a class="markdownIt-Anchor" href="#平方取中"></a> 平方取中</h4>
<p>取key<sup>2</sup>的中间若干位，构成地址</p>
<h4 id="折叠法"><a class="markdownIt-Anchor" href="#折叠法"></a> 折叠法</h4>
<p>将key分割成等宽的若干段，取其总和作为地址</p>
<h4 id="位异或法"><a class="markdownIt-Anchor" href="#位异或法"></a> 位异或法</h4>
<p>将key分割成等宽的二进制段，经异或运算得到地址</p>
<h4 id="伪随机数"><a class="markdownIt-Anchor" href="#伪随机数"></a> 伪随机数</h4>
<p>（伪）随机数发生器的实现，因具体平台，不同历史版本而已，创建的散列表可移植性差，需慎用</p>
<h4 id="多项式法"><a class="markdownIt-Anchor" href="#多项式法"></a> 多项式法</h4>
<p>字符串关键码转换成多项式相加</p>
<h3 id="排解冲突"><a class="markdownIt-Anchor" href="#排解冲突"></a> 排解冲突</h3>
<h4 id="平方试探"><a class="markdownIt-Anchor" href="#平方试探"></a> 平方试探</h4>
<p>以平方数为距离，确定下一试探桶单元</p>
<p>[hash(key) + n<sup>2</sup>] % M</p>
<h4 id="双向平方试探"><a class="markdownIt-Anchor" href="#双向平方试探"></a> 双向平方试探</h4>
<p>[hash(key) + n<sup>2</sup>] % M</p>
<p>[hash(key) - n<sup>2</sup>] % M</p>
<h4 id="两类素数"><a class="markdownIt-Anchor" href="#两类素数"></a> 两类素数</h4>
<p>4k + 1、4k + 3</p>
<p>表长取作素数M = 4k + 3，必然可以保证查找链的前M项均互异</p>
<h3 id="散列码转换"><a class="markdownIt-Anchor" href="#散列码转换"></a> 散列码转换</h3>
<h4 id="32位"><a class="markdownIt-Anchor" href="#32位"></a> &lt;32位</h4>
<p>对于byte、short、int和char等本身即可表示为不超过32为整数的数据类型，可直接将它们的这种表示作为其散列码</p>
<h4 id="32位-2"><a class="markdownIt-Anchor" href="#32位-2"></a> &gt;32位</h4>
<ul>
<li>
<p>将高32位和低32位分别看作两个32位整数，将二者之和作为散列码</p>
</li>
<li>
<p>将成员对象各自对应的整数累加起来，再截取低32位作为散列码</p>
</li>
</ul>
<h4 id="多项式散列码"><a class="markdownIt-Anchor" href="#多项式散列码"></a> 多项式散列码</h4>
<p>将字符串中的各个字符，视作一个多项式的各项系数</p>
<ul>
<li>对于英文单词之类的字符串，a = 33、37、39、41都是不错的选择</li>
</ul>
<h3 id="桶计数排序"><a class="markdownIt-Anchor" href="#桶计数排序"></a> 桶/计数排序</h3>
<p>给定[0, M)内的n个互异整数，时间复杂度O(n + M)</p>
<ul>
<li>当M &lt;&lt; n时，时间复杂度O(n)</li>
</ul>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 二叉树</title>
    <url>/2020/09/15/DS/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第五章-二叉树"><a class="markdownIt-Anchor" href="#第五章-二叉树"></a> 第五章 二叉树</h2>
<h3 id="先序遍历"><a class="markdownIt-Anchor" href="#先序遍历"></a> 先序遍历</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">visitAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, <span class="built_in">stack</span>&lt;T&gt;&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">        S.push(x-&gt;rChild);</span><br><span class="line">        x = x-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travePre_E2</span><span class="params">(BinNodePost(T) x, VST&amp; visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; S;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        visitAlongLeftBranch(x, visit, S);</span><br><span class="line">        <span class="keyword">if</span>(S.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x = S.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="中序遍历"><a class="markdownIt-Anchor" href="#中序遍历"></a> 中序遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">goAlongLeftBranch</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, <span class="built_in">stack</span>&lt;T&gt;&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x) &#123;							<span class="comment">// 反复入栈，沿左分支深入</span></span><br><span class="line">        S.push(x);</span><br><span class="line">        x = x-&gt;lChild;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traveIn_E1</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;T&gt; S;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        goAlongLeftBranch(x,visit,  S);	<span class="comment">// 从当前节点出发，入栈</span></span><br><span class="line">        <span class="keyword">if</span>(S.empty())</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        x = S.pop();</span><br><span class="line">        visit(x-&gt;data);        	</span><br><span class="line">        x = x-&gt;rChild;					<span class="comment">// 转向访问右子树，可能为空</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="后序遍历"><a class="markdownIt-Anchor" href="#后序遍历"></a> 后序遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">gotoHL</span><span class="params">(BinNodePosi(T) x, VST&amp; visit, <span class="built_in">stack</span>&lt;T&gt;&amp; S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(x = S.top()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hasLChild(*x)) &#123;</span><br><span class="line">            <span class="keyword">if</span>(hasRChild(*x))</span><br><span class="line">                S.push(x-&gt;rChild);</span><br><span class="line">            S.push(x-&gt;lChild);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            S.push(x-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">    S.pop();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">travPos</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x)</span><br><span class="line">        S.push(x);</span><br><span class="line">    <span class="keyword">while</span>(!S.empty()) &#123;</span><br><span class="line">        <span class="keyword">if</span>(S.top() != x-&gt;parent)</span><br><span class="line">        	gotoHL(x, visit, S);</span><br><span class="line">        x = S.pop();</span><br><span class="line">        visit(x-&gt;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="层次遍历"><a class="markdownIt-Anchor" href="#层次遍历"></a> 层次遍历</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> VST&gt;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">travLevel</span><span class="params">(BinNodePosi(T) x, VST&amp; visit)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;T&gt; Q;</span><br><span class="line">    Q.enqueue(x);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        x = Q.dequeue(x);</span><br><span class="line">        <span class="keyword">if</span>(HasLChild(*x)) Q.enqueue(x-&gt;lChild);</span><br><span class="line">        <span class="keyword">if</span>(HasRChild(*x)) Q.enqueue(x-&gt;rChild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>
<p>单节点高度0，空树高度-1</p>
</li>
<li>
<p>真二叉树：节点度数只为0或2</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>第二章 向量</title>
    <url>/2020/09/09/DS/%E7%AC%AC%E4%BA%8C%E7%AB%A0%20%E5%90%91%E9%87%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第二章-向量"><a class="markdownIt-Anchor" href="#第二章-向量"></a> 第二章 向量</h2>
<h3 id="比较树"><a class="markdownIt-Anchor" href="#比较树"></a> 比较树</h3>
<a id="more"></a>
<h4 id="性质"><a class="markdownIt-Anchor" href="#性质"></a> 性质：</h4>
<ul>
<li>每一内部节点各对应于一次比对操作</li>
<li>内部节点的左、右分支，分别对应于在两种比对结果下的执行方向</li>
<li>叶节点对应于算法某次执行的完整过程及输出</li>
<li>算法的每一运行过程都对应于从根到某一叶节点的路径</li>
</ul>
<p>可以这么描述的算法被称作<strong>基于比较式算法 CBA(comparision-based algorithm)</strong></p>
<h4 id="最小树高"><a class="markdownIt-Anchor" href="#最小树高"></a> 最小树高</h4>
<p>​		叶节点到根节点的距离称作叶结点的深度，最大深度为树的高度，最小树高即为最佳CBA算法</p>
<h4 id="计算"><a class="markdownIt-Anchor" href="#计算"></a> 计算</h4>
<p>​		二叉树：高度为h，叶节点数目≥2<sup>h</sup>；输出为n，树高大于log<sub>2</sub>N</p>
<p>​		三叉树：输出为n，树高大于log<sub>3</sub>N</p>
<h3 id="二路归并算法"><a class="markdownIt-Anchor" href="#二路归并算法"></a> 二路归并算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::merge(T lo, T mi, T hi) &#123;</span><br><span class="line">    T* A = _elem + lo;</span><br><span class="line">    <span class="keyword">int</span> lb = mi - lo;	T* B = <span class="keyword">new</span> T[lb];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; lb; B[i] = A[i++]);</span><br><span class="line">    <span class="keyword">int</span> lc = hi - mi; T* C = _elem + mi;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>, k = <span class="number">0</span>;(j &lt; lb) || (k &lt; lc); ) &#123;</span><br><span class="line">        <span class="keyword">if</span>(j&lt;lb) &amp;&amp; (!(k&lt;lc) || (B[j]&lt;=C[k])) A[i++]=B[j++];</span><br><span class="line">    	<span class="keyword">if</span>(k&lt;lc) &amp;&amp; (!(j&lt;lb) || (C[k]&lt; B[j])) A[i++]=C[k++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">delete</span> [] B;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="归并排序算法"><a class="markdownIt-Anchor" href="#归并排序算法"></a> 归并排序算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> Vector&lt;T&gt;::mergeSort(<span class="keyword">int</span> lo, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">    <span class="keyword">if</span>(hi - lo &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> mi = (lo + hi) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    mergeSort(lo, mi); mergeSort(mi, hi);</span><br><span class="line">    merge(lo, mi, hi);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>
<p>稳定算法(stable algorithm)：重复元素之间的相对次序在排序前后保持一致，起泡排序属于稳定算法</p>
</li>
<li>
<p>线性（时间）归约(linear-time reduction)</p>
<ul>
<li>问题A的任一输入都可在线性时间内转换为B的输入</li>
<li>问题B的任一输出都可在线性时间内转换为A的输出</li>
</ul>
<p>|B| ≥ |A| = Ω( f(n) )</p>
<p>例：</p>
<p>​	问题A：对于任意n个实数，判定其中是否有重复者</p>
<p>​	问题B：无序向量唯一化</p>
<p>解：在线性时间内</p>
<p>​	A输入：n个实数—&gt;B输入：无序向量—&gt;B输出：去重向量—&gt;A输出：规模仍为n</p>
</li>
<li>
<p>马鞍查找</p>
<p>整数矩阵的任何一行(列)都严格递增，找出并报告所有值为x的元素</p>
<p>减而治之：</p>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">saddleback <span class="title">search</span><span class="params">(<span class="keyword">int</span> A[n][n], <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = binSearch(A[<span class="number">0</span>][], x);		<span class="comment">// O(logn)</span></span><br><span class="line">    <span class="keyword">while</span>((i &lt; n) &amp;&amp; (<span class="number">-1</span> &lt; j)) &#123;		<span class="comment">// O(s + r)</span></span><br><span class="line">        <span class="keyword">if</span>(A[i][j] &lt; x) i++;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(x &lt; A[i][j]) j--;</span><br><span class="line">        <span class="keyword">else</span> &#123; report(A[i][j]); i++; j--;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第八章 高级搜索树</title>
    <url>/2020/09/22/DS/%E7%AC%AC%E5%85%AB%E7%AB%A0%20%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%A0%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="高级搜索树"><a class="markdownIt-Anchor" href="#高级搜索树"></a> 高级搜索树</h2>
<h3 id="伸展树splay-tree"><a class="markdownIt-Anchor" href="#伸展树splay-tree"></a> 伸展树(splay tree)</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Splay</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">  	BinNodePosi(T) splay(BinNodePosi(T) v);</span><br><span class="line"><span class="keyword">public</span>:		<span class="comment">// 伸展树的search也会引起整树的结构调整</span></span><br><span class="line">    BinNodePosi(T)&amp; search(<span class="keyword">const</span> T&amp; e);</span><br><span class="line">    BinNodePosi(T) insert(<span class="keyword">const</span> T&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="伸展"><a class="markdownIt-Anchor" href="#伸展"></a> 伸展</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T)</span><br><span class="line">Splay&lt;T&gt;::splay(BinNodePosi(T) v) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!v) <span class="keyword">return</span> <span class="literal">NULL</span>; </span><br><span class="line">    BinNodePosi(T) p; BinNodePosi(T) g;</span><br><span class="line">    <span class="keyword">while</span>((p = v-&gt;parent) &amp;&amp; g = p-&gt;parent) &#123;</span><br><span class="line">        BinNodePosi(T) gg = g-&gt;parent;</span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*v))</span><br><span class="line">            <span class="keyword">if</span>(IsLChild(*p)) &#123; 		<span class="comment">// zig-zig</span></span><br><span class="line">            	attachAsLChild(g, p-&gt;rc);</span><br><span class="line">                attachAsLChild(p, v-&gt;rc);</span><br><span class="line">                attachAsRChild(p, g);</span><br><span class="line">                attachAsRChild(v, p);</span><br><span class="line">            &#125;	</span><br><span class="line">        	<span class="keyword">else</span> &#123; &#125;				<span class="comment">// zag-zig</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(IsRChild(*p)) &#123; &#125;	<span class="comment">// zag-zag</span></span><br><span class="line">        <span class="keyword">else</span> &#123; &#125;					<span class="comment">// zig-zag</span></span><br><span class="line">        <span class="keyword">if</span>(!gg)					<span class="comment">// 若无曾祖父gg,则v现即为树根，</span></span><br><span class="line">            v-&gt;parent = <span class="literal">NULL</span>;	<span class="comment">// 否则，gg应以v为左或右孩子</span></span><br><span class="line">        <span class="keyword">else</span>(g == gg-&gt;lc) ? attachAsLChild(gg, v) : attachAsRChild(gg, v);</span><br><span class="line">        updateHeight(g); updateHeight(p); updateHeight(v);</span><br><span class="line">    &#125;	<span class="comment">// 双层伸展结束时，必有g == NULL,但p可能非空</span></span><br><span class="line">    <span class="keyword">if</span>(p = v-&gt;parent) &#123;	<span class="comment">// 若p为根，只需单旋一次</span></span><br><span class="line">		<span class="keyword">if</span>(IsLChild(*v)) &#123;</span><br><span class="line">            attachAsLChild(p, v-&gt;rChild);</span><br><span class="line">            attachAsRChild(v, p);        </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            attachAsRChild(p, v-&gt;lChild);</span><br><span class="line">            attachAsLChild(v, p);</span><br><span class="line">        &#125;</span><br><span class="line">        updateHeight(p); updateHeight(v);</span><br><span class="line">    &#125;</span><br><span class="line">    v-&gt;parent = <span class="literal">NULL</span>; <span class="keyword">return</span> v;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="查找"><a class="markdownIt-Anchor" href="#查找"></a> 查找</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T)&amp;</span><br><span class="line">Splay&lt;T&gt;::search(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T) p = searchIn(_root, e, _hot = <span class="literal">NULL</span>);</span><br><span class="line">    _root = splay(p ? p : _hot);		<span class="comment">// 成功、失败</span></span><br><span class="line">    <span class="keyword">return</span> _root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入"><a class="markdownIt-Anchor" href="#插入"></a> 插入</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T)&amp;</span><br><span class="line">Splay&lt;T&gt;::search(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!_root) &#123;</span><br><span class="line">        _size++;</span><br><span class="line">        <span class="keyword">return</span> _root = <span class="keyword">new</span> BinNode&lt;T&gt; (e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(e == search(e)-&gt;data) <span class="keyword">return</span> _root;	<span class="comment">// 若存在</span></span><br><span class="line">    _size++; BinNodePosi(T) t = _root;</span><br><span class="line">    <span class="keyword">if</span>(_root-&gt;data &lt; e) &#123;<span class="comment">// 插入新根，以t和t-&gt;rChild为左、右孩子</span></span><br><span class="line">        t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt;(e, <span class="literal">NULL</span>, t, </span><br><span class="line">                                           t-&gt;rChild);</span><br><span class="line">        <span class="keyword">if</span>(HasRChild(*t)) &#123;</span><br><span class="line">            t-&gt;rChild-&gt;parent = _root;</span><br><span class="line">            t-&gt;rChild = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;			<span class="comment">// 插入新根，以t-&gt;lChild和t为左、右孩子</span></span><br><span class="line">            t-&gt;parent = _root = <span class="keyword">new</span> BinNode&lt;T&gt;(e, <span class="literal">NULL</span>, </span><br><span class="line">                                              t-&gt;lChild, t);</span><br><span class="line">        	<span class="keyword">if</span>(HasLChild(*t)) &#123;</span><br><span class="line">                t-&gt;lChild-&gt;parent = _root;</span><br><span class="line">               	t-&gt;lChild = <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">	updateHeightAbove(t);	<span class="comment">// 更新_root的高度</span></span><br><span class="line">    <span class="keyword">return</span> _root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a class="markdownIt-Anchor" href="#删除"></a> 删除</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">bool</span> Splay&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(!_root || (e != search(e)-&gt;data)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BinNodePosi(T) w = _root;	<span class="comment">// 经search后节点已伸展至树根</span></span><br><span class="line">    <span class="keyword">if</span>(!HasLChild(*_root)) &#123;	<span class="comment">// 若无左子树，直接删除</span></span><br><span class="line">        _root = _root-&gt;rChild; <span class="keyword">if</span>(_root) _root-&gt;parent=<span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!HasRChild(*_root)) &#123;	<span class="comment">// 若无右子树，直接删除</span></span><br><span class="line">        _root = _root-&gt;lChild; <span class="keyword">if</span>(_root) _root-&gt;parent=<span class="literal">NULL</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;					<span class="comment">// 左右子树同时存在</span></span><br><span class="line">        BinNodePosi(T) lTree = _root-&gt;lChild;<span class="comment">//暂时切除左子树</span></span><br><span class="line">        lTree-&gt;parent = <span class="literal">NULL</span>; _root-&gt;lChild = <span class="literal">NULL</span>;</span><br><span class="line">        _root = _root-&gt;rChild; _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">        search(w-&gt;data);	  <span class="comment">// 再做一次查找，返回大于e的最小值</span></span><br><span class="line">        _root-&gt;lChild = lTree; lTree-&gt;parent = _root;<span class="comment">//接回</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">release</span>(w-&gt;data); <span class="built_in">release</span>(w); _size--;		<span class="comment">// 释放节点</span></span><br><span class="line">    <span class="keyword">if</span>(_root) updateHeight(_root);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="b-树"><a class="markdownIt-Anchor" href="#b-树"></a> B-树</h3>
<ul>
<li>
<p>每d代合并：m = 2^d路， m - 1个关键码</p>
</li>
<li>
<p>充分利用外存对批量访问的高效支持，将此特点转化为优点，每下降一层，都以超级节点为单位，读入一组关键码</p>
</li>
<li>
<p>m的大小视磁盘的数据块大小而定KB/4 = 200 ~ 300</p>
</li>
<li>
<p><strong>树高h = 外部节点深度</strong></p>
</li>
<li>
<p>内部节点的分支数n+1也不能太少</p>
<ul>
<li>树根：2 &lt;= n+1 &lt;= m</li>
<li>其余： 「m / 2 ⌉ &lt;= n + 1 &lt;= m</li>
</ul>
</li>
<li>
<p>也称为(「m / 2 ⌉,  m)-树</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BTNode</span> &#123;</span></span><br><span class="line">	BTNodePosi(T) parent;</span><br><span class="line">    <span class="built_in">vector</span>&lt;T&gt; key;</span><br><span class="line">    <span class="built_in">vector</span>&lt;BTNodePosi(T)&gt; child;</span><br><span class="line">    BTNode() &#123; parent = <span class="literal">NULL</span>; child.insert(<span class="number">0</span>, <span class="literal">NULL</span>); &#125;</span><br><span class="line">    BTNode(T e, BTNodePosi(T) lc = <span class="literal">NULL</span>, BTNodePosi(T) rc = 													<span class="literal">NULL</span>) </span><br><span class="line">    &#123;</span><br><span class="line">        parent = <span class="literal">NULL</span>;</span><br><span class="line">        key.insert(<span class="number">0</span>, e);</span><br><span class="line">        child.insert(<span class="number">0</span>, lc);</span><br><span class="line">        child.insert(<span class="number">1</span>, rc);</span><br><span class="line">        <span class="keyword">if</span>(lc) lc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span>(rc) rc-&gt;parent = <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BTNodePosi(T) BTNode<span class="meta-string">&lt;T&gt;*</span></span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">BTree</span> &#123;</span></span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">int</span> _size; <span class="keyword">int</span> _order; BTNodePosi(T) _root;<span class="comment">// 总数、阶次</span></span><br><span class="line">    BTNodePosi(T) _hot;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveOverflow</span><span class="params">(BTNodePosi(T))</span></span>;<span class="comment">//因插入而上溢后的分裂处理</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveUnderflow</span><span class="params">(BTNodePosi(T))</span></span>;<span class="comment">//因删除而下溢后的合并</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	BTNodePosi(T) search(<span class="keyword">const</span> T&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="查找-2"><a class="markdownIt-Anchor" href="#查找-2"></a> 查找</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line">BTNodePosi(T) BTree&lt;T&gt;::search(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BTNodePosi(T) v = _root; _hot = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(v) &#123;</span><br><span class="line">        <span class="keyword">int</span> r = v-&gt;key.search(e);</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &lt;= r &amp;&amp; e == v-&gt;key[r]) <span class="keyword">return</span> v;</span><br><span class="line">        _hot = v; v = v-&gt;child[r + <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入-2"><a class="markdownIt-Anchor" href="#插入-2"></a> 插入</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BTree&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BTNodePosi(T) v = search(e);</span><br><span class="line">    <span class="keyword">if</span>(v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> r = _hot-&gt;key.search(e);</span><br><span class="line">    _hot-&gt;key.insert(r + <span class="number">1</span>, e);</span><br><span class="line">    _hot-&gt;child.insert(r + <span class="number">2</span>, <span class="literal">NULL</span>);</span><br><span class="line">    _size++; solveOverflow(_hot);	<span class="comment">// 如发生上溢，需做分裂</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="分裂"><a class="markdownIt-Anchor" href="#分裂"></a> 分裂</h4>
<p>​		取关键码中位数k<sub>s</sub>，k<sub>s</sub>上升一层，并分裂，以所得的两个节点作为左、右孩子</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">tempalte &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveOverflow(BTNodePosi(T) v) &#123;</span><br><span class="line">	<span class="keyword">if</span>(_order &gt;= v-&gt;child.<span class="built_in">size</span>()) <span class="keyword">return</span>;	<span class="comment">// 递归基</span></span><br><span class="line">    <span class="keyword">int</span> s = _order / <span class="number">2</span>;</span><br><span class="line">    BTNodePosi(T) u = <span class="keyword">new</span> BTNode&lt;T&gt;();		<span class="comment">// 新节点有个空孩子</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _order - s - <span class="number">1</span>; j++) &#123;	<span class="comment">// 右侧孩子</span></span><br><span class="line">        u-&gt;child.insert(j, v-&gt;child.<span class="built_in">remove</span>(s + <span class="number">1</span>));<span class="comment">// u的也没</span></span><br><span class="line">        u-&gt;key.insert(j, v-&gt;key.<span class="built_in">remove</span>(s + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    u-&gt;child[_order - s - <span class="number">1</span>] = v-&gt;child.<span class="built_in">remove</span>(s + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">if</span>(u-&gt;child[<span class="number">0</span>])							<span class="comment">// 若u孩子非空</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; _order - s; j++)	<span class="comment">// 将父节点统一</span></span><br><span class="line">            u-&gt;child[j]-&gt;parent = u;</span><br><span class="line">    BTNodePosi(T) p = v-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(!P) &#123;								<span class="comment">// p为空则创建</span></span><br><span class="line">        _root = p = newBTNode&lt;T&gt;();</span><br><span class="line">        p-&gt;child[<span class="number">0</span>] = v;</span><br><span class="line">        v-&gt;parent = p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span> + p-&gt;key.search(v-&gt;key[<span class="number">0</span>]); <span class="comment">// p中指向u的指针的秩</span></span><br><span class="line">    p-&gt;key.insert(r, v-&gt;key.<span class="built_in">remove</span>(s));	  <span class="comment">// 轴点关键码上升</span></span><br><span class="line">    p-&gt;child.insert(r + <span class="number">1</span>, u); u-&gt;parent = p;	<span class="comment">// 互联</span></span><br><span class="line">    solveOverflow(p);	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除-2"><a class="markdownIt-Anchor" href="#删除-2"></a> 删除</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">bool</span> BTree&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BTNodePosi(T) v = search(e);</span><br><span class="line">    <span class="keyword">if</span>(v) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> r = v-&gt;key.search(e);</span><br><span class="line">    <span class="keyword">if</span>(v-&gt;child[<span class="number">0</span>]) &#123;					<span class="comment">// 若v非叶子</span></span><br><span class="line">        BTNodePosi(T) u = v-&gt;child[r + <span class="number">1</span>];	<span class="comment">// 在右子树中向左</span></span><br><span class="line">        <span class="keyword">while</span>(u-&gt;child[<span class="number">0</span>]) u = u-&gt;child[<span class="number">0</span>];	<span class="comment">// 找到e的后继</span></span><br><span class="line">        v-&gt;key[r] = u-&gt;key[<span class="number">0</span>]; v = u; r = <span class="number">0</span>;<span class="comment">// 互换位置</span></span><br><span class="line">    &#125;	<span class="comment">// 至此,v必然位于最底层，且其中第r个关键码就是待删除者			v-&gt;key.remove(r); v-&gt;child.remove(r + 1); _size--;</span></span><br><span class="line">    solveUnderflow(v);				<span class="comment">// 如有必要，需做旋转或合并</span></span><br><span class="line">    <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="旋转"><a class="markdownIt-Anchor" href="#旋转"></a> 旋转</h4>
<ul>
<li>左或右兄弟关键码 ≥ ⌈m / 2⌉</li>
</ul>
<h4 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h4>
<ul>
<li>左或右兄弟关键码 = ⌈m / 2 - 1⌉</li>
</ul>
<p><img src="https://i.loli.net/2020/09/19/Be4tUCRzwpmSEfM.png" alt="image-20200919194411160.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> BTree&lt;T&gt;::solveUnderflow(BTNodePosi(T) v) &#123;</span><br><span class="line">    <span class="keyword">if</span>((_order + <span class="number">1</span>) / <span class="number">2</span> &lt;= v-&gt;child.<span class="built_in">size</span>()) <span class="keyword">return</span>;<span class="comment">// 递归基</span></span><br><span class="line">    BTNodePosi(T) p = v-&gt;parent;</span><br><span class="line">    <span class="keyword">if</span>(!p) &#123;							<span class="comment">// 递归基：已到根节点</span></span><br><span class="line">        <span class="keyword">if</span>(!v-&gt;key.<span class="built_in">size</span>() &amp;&amp; v-&gt;child[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="comment">// 倘若v不含关键码，却有非空孩子</span></span><br><span class="line">            _root = v-&gt;child[<span class="number">0</span>];</span><br><span class="line">            _root-&gt;panret = <span class="literal">NULL</span>;</span><br><span class="line">            v-&gt;child[<span class="number">0</span>] = <span class="literal">NULL</span>; <span class="built_in">release</span>(v);			<span class="comment">// 删除</span></span><br><span class="line">        &#125;	<span class="comment">// 整树高度降低一层</span></span><br><span class="line">        <span class="keyword">return</span>;        </span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">int</span> r = <span class="number">0</span>; <span class="keyword">while</span>(p-&gt;child[r] != v) r++;</span><br><span class="line">    <span class="comment">// 确定v是p的第r个孩子</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况1：向左兄弟借关键码</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt; r) &#123;	<span class="comment">// 若v不是p的第一个孩子，则</span></span><br><span class="line">        BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>];	   <span class="comment">// 左兄弟必存在</span></span><br><span class="line">        <span class="keyword">if</span>((_order + <span class="number">1</span>) / <span class="number">2</span> &lt; ls-&gt;child.<span class="built_in">size</span>()) &#123;	<span class="comment">// 足够胖</span></span><br><span class="line">            v-&gt;key.insert(<span class="number">0</span>, p-&gt;key[r - <span class="number">1</span>]);	<span class="comment">// p借给v</span></span><br><span class="line">            <span class="comment">// ls的最大关键码转入p</span></span><br><span class="line">            p-&gt;key[r - <span class="number">1</span>]=ls-&gt;key.<span class="built_in">remove</span>(ls-&gt;key.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        	v-&gt;child.insert(<span class="number">0</span>, ls-&gt;child.<span class="built_in">remove</span>(</span><br><span class="line">                ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>));		<span class="comment">// ls最右侧孩子给v</span></span><br><span class="line">        	<span class="keyword">if</span>(v-&gt;child[<span class="number">0</span>])</span><br><span class="line">                v-&gt;child[<span class="number">0</span>]-&gt;parent = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="comment">// 至此，左兄弟要么为空，要么太“瘦”</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况2：向右兄弟借关键码</span></span><br><span class="line">	<span class="keyword">if</span>(p-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span> &gt; r) &#123;	<span class="comment">// 若v不是p最后一个孩子</span></span><br><span class="line">        BTNodePosi(T) rs = p-&gt;child.<span class="built_in">size</span>();	<span class="comment">// 右兄弟必存在</span></span><br><span class="line">    	<span class="keyword">if</span>((_order + <span class="number">1</span>) / <span class="number">2</span> &lt; rs-&gt;child.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            v-&gt;key.insert(v-&gt;key.<span class="built_in">size</span>(), p-&gt;key[r]);</span><br><span class="line">            p-&gt;key[r] = rs-&gt;key.<span class="built_in">remove</span>(<span class="number">0</span>);</span><br><span class="line">            v-&gt;child.insert(v-&gt;child.<span class="built_in">size</span>(), </span><br><span class="line">                            rs-&gt;child.<span class="built_in">remove</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">                v-&gt;child[v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = v;</span><br><span class="line">            <span class="keyword">return</span>;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 情况3：左、右兄弟都太“瘦”，需要合并</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &lt; r) &#123;	<span class="comment">// 与左兄弟合并</span></span><br><span class="line">        BTNodePosi(T) ls = p-&gt;child[r - <span class="number">1</span>];	<span class="comment">// 左兄弟必存在</span></span><br><span class="line">    	ls-&gt;key.insert(ls-&gt;key.<span class="built_in">size</span>(), p-&gt;key.<span class="built_in">remove</span>(r<span class="number">-1</span>));</span><br><span class="line">        p-&gt;child.<span class="built_in">remove</span>(r);		<span class="comment">// p的第r-1个关键码转入ls</span></span><br><span class="line">        <span class="comment">// v的最左侧孩子过继给ls做最右侧孩子</span></span><br><span class="line">        ls-&gt;child.insert(ls-&gt;child.<span class="built_in">size</span>(), </span><br><span class="line">                         v-&gt;child.<span class="built_in">remove</span>(<span class="number">0</span>));</span><br><span class="line">        <span class="keyword">if</span>(ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">            ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent = ls;</span><br><span class="line">        <span class="keyword">while</span>(!v-&gt;key.empty()) &#123;	<span class="comment">// v剩余的关键码和孩子入ls</span></span><br><span class="line">            ls.key.insert(ls-&gt;key.<span class="built_in">size</span>(), v-&gt;key.<span class="built_in">remove</span>(<span class="number">0</span>));</span><br><span class="line">            ls-&gt;child.insert(ls-&gt;child.<span class="built_in">size</span>(), </span><br><span class="line">                             v-&gt;child.<span class="built_in">remove</span>(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">if</span>(ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>])</span><br><span class="line">                ls-&gt;child[ls-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>]-&gt;parent=ls;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">release</span>(v);					<span class="comment">//释放v</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 与右兄弟合并</span></span><br><span class="line">    	BTNodePosi(T) rs = p-&gt;child[r + <span class="number">1</span>];	<span class="comment">//右兄弟必存在</span></span><br><span class="line">        rs-&gt;key.insert(<span class="number">0</span>, p-&gt;key.<span class="built_in">remove</span>(r)); </span><br><span class="line">        					p-&gt;childremove(r);</span><br><span class="line">        rs-&gt;child.insert(<span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span>(</span><br><span class="line">            				v-&gt;child.<span class="built_in">size</span>()<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">if</span>(rs-&gt;child[<span class="number">0</span>]) </span><br><span class="line">            rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line">        <span class="keyword">while</span>(!v-&gt;key.empty()) &#123;</span><br><span class="line">            rs-&gt;key.insert(<span class="number">0</span>, v-&gt;key.<span class="built_in">remove</span>(</span><br><span class="line">                				v-&gt;key.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">            rs-&gt;child.insert(<span class="number">0</span>, v-&gt;child.<span class="built_in">remove</span>(</span><br><span class="line">                                v-&gt;child.<span class="built_in">size</span>() - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(rs-&gt;child[<span class="number">0</span>])</span><br><span class="line">                rs-&gt;child[<span class="number">0</span>]-&gt;parent = rs;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">release</span>(v);    </span><br><span class="line">    &#125;</span><br><span class="line">    solveUnderflow(p);		<span class="comment">// 上升一层</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="红黑树"><a class="markdownIt-Anchor" href="#红黑树"></a> 红黑树</h3>
<ul>
<li>支持对历史版本的访问</li>
<li>任何一次动态操作引发的结构变化量不超过O(1)</li>
<li>红黑树与4阶B数相同</li>
</ul>
<h4 id="定义规则"><a class="markdownIt-Anchor" href="#定义规则"></a> 定义规则</h4>
<ul>
<li>树根：黑色</li>
<li>外部节点：均为黑色</li>
<li>其余节点：若为红，则只能有黑孩子</li>
<li>外部节点到根：黑节点数目相等</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">RedBlack</span> :</span> <span class="keyword">public</span> BST&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// search()继承</span></span><br><span class="line">    BinNodePosi(T) insert(<span class="keyword">const</span> T&amp; e);</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">const</span> T&amp; e)</span></span>;</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleRed</span><span class="params">(BinNodePosi(T) x)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solveDoubleBlack</span><span class="params">(BinNodePosi(T) x)</span></span>;	</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">updateHeight</span><span class="params">(BinNodePosi(T) x)</span></span>;		<span class="comment">// 黑高度</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">int</span> RedBlack&lt;T&gt;::updateHeight(BinNodePosi(T) x) &#123;</span><br><span class="line">    x-&gt;<span class="built_in">height</span> = <span class="built_in">max</span>(stature(x-&gt;lc), stature(x-&gt;rc));</span><br><span class="line">    <span class="keyword">if</span>(IsBlack(x)) x-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span> x-&gt;<span class="built_in">height</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入-3"><a class="markdownIt-Anchor" href="#插入-3"></a> 插入</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) </span><br><span class="line">RedBlack&lt;T&gt;::insert(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T) &amp; x = search(e);		</span><br><span class="line">    <span class="keyword">if</span>(x) <span class="keyword">return</span> x;					<span class="comment">// 假设不存在</span></span><br><span class="line">    x = <span class="keyword">new</span> BinNode&lt;T&gt;(e, _hot, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">-1</span>); _size++;</span><br><span class="line">    solveDoubleRed(x);</span><br><span class="line">    <span class="keyword">return</span> x ? x : _hot-&gt;parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双红缺陷"><a class="markdownIt-Anchor" href="#双红缺陷"></a> 双红缺陷</h4>
<p><img src="D:%5Cstudy%5C%E7%BC%96%E7%A8%8B%5C%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%5Cnotes%5Cimages%5Cimage-20200920191030377.png" alt="image-20200920191030377" /></p>
<p><img src="https://i.loli.net/2020/09/20/e3DAoCjkhNWHz6L.png" alt="image-20200920190926947" /></p>
<p><img src="https://i.loli.net/2020/09/20/i9jeYJQbHSd8GLN.png" alt="image-20200920191511955.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RedBlack::solveDoubleRed</span><span class="params">(BinNodePosi(T) x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsRoot(*x))	<span class="comment">// 若递归至树根，则将其转黑，整树黑高度增加</span></span><br><span class="line">    &#123; _root-&gt;color = RB_BLACK; +root-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span>; &#125;</span><br><span class="line">    BinNodePosi(T) p = x-&gt;parent; <span class="keyword">if</span>(IsBlack(p)) <span class="keyword">return</span>;</span><br><span class="line">    BinNodePosi(T) g = p-&gt;parent;	<span class="comment">// p为红，g为黑</span></span><br><span class="line">    BinNodePosi(T) u = uncle(x);	<span class="comment">// 以下，视u颜色分别处理</span></span><br><span class="line">    <span class="keyword">if</span>(IsBlack(u)) &#123;	<span class="comment">// u为黑色</span></span><br><span class="line">        <span class="keyword">if</span>(IsLChild(*x) == IsLChild(*p)) </span><br><span class="line">            p-&gt;color = RB_BLACK;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            x-&gt;color = RB_BLACK;</span><br><span class="line">        g-&gt;color = RB_RED;</span><br><span class="line">        BinNodePosi(T) gg = g-&gt;parent;</span><br><span class="line">        BinNodePosi(T) r= FromParentTo(*g) = rotateAt(x);</span><br><span class="line">        r-&gt;parent = g;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;			<span class="comment">// u为红色</span></span><br><span class="line">        p-&gt;color = RB_BLACK; p-&gt;<span class="built_in">height</span>++;	<span class="comment">// p、u转黑</span></span><br><span class="line">        u-&gt;color = RB_BLACK; u-&gt;<span class="built_in">height</span>++;	<span class="comment">// g非根转红</span></span><br><span class="line">        <span class="keyword">if</span>(!(IsRoot(*g)) g-&gt;color = RB_RED;</span><br><span class="line">           solveDoubleRed(g);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除-3"><a class="markdownIt-Anchor" href="#删除-3"></a> 删除</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; BinNodePosi(T) </span><br><span class="line">RedBlack&lt;T&gt;::<span class="built_in">remove</span>(<span class="keyword">const</span> T&amp; e) &#123;</span><br><span class="line">    BinNodePosi(T)&amp; x = search(e);</span><br><span class="line">    <span class="keyword">if</span>(!x) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    BinNodePosi(T) r = removeAt(x, _hot);</span><br><span class="line">    <span class="keyword">if</span>(<span class="number">0</span> &gt;= --_size) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(!_hot)	<span class="comment">// 如果被删除的是根节点，置黑并更新黑高度</span></span><br><span class="line">    &#123; _root-&gt;color = RB_BLACK; updateHeight(_root); </span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    <span class="keyword">if</span>(BlackHeightUpdated(*(_hot))) <span class="comment">// 若祖先黑深度平衡</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(IsRed(r))		<span class="comment">// 若r为红，转黑</span></span><br><span class="line">    &#123; r-&gt;color = RB_BLACK; r-&gt;<span class="built_in">height</span>++; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">    soloveDoubleBlack(r); <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="双黑缺陷"><a class="markdownIt-Anchor" href="#双黑缺陷"></a> 双黑缺陷</h4>
<p><img src="https://i.loli.net/2020/09/20/AewRLstB45P3ji8.png" alt="image-20200920193316876" /></p>
<p><img src="https://i.loli.net/2020/09/20/VPTHR3Ga5ihZrdA.png" alt="image-20200920193246521" /></p>
<p><img src="https://i.loli.net/2020/09/20/f2rgo8t4s1i7hvN.png" alt="image-20200920193333324" /></p>
<p><img src="https://i.loli.net/2020/09/20/GUz4cfeS8FiAvNK.png" alt="image-20200920193631842.png" /></p>
<p><img src="https://i.loli.net/2020/09/20/lbriztVP6EqvHRp.png" alt="image-20200920193958612.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; </span><br><span class="line"><span class="keyword">void</span> RedBlack&lt;T&gt;::solveDoubleBlack(BinNodePosi(T) r) &#123;</span><br><span class="line">    BinNodePosi(T) p = r ? r-&gt;parent : _hot; </span><br><span class="line">    <span class="keyword">if</span>(!p) <span class="keyword">return</span>;			<span class="comment">// r的父亲</span></span><br><span class="line">    BinNodePosi(T) s = (r == p-&gt;lChild) ? p-&gt;rChild </span><br><span class="line">        							: p-&gt;lChild; <span class="comment">// r的兄弟</span></span><br><span class="line">    <span class="keyword">if</span>(IsBlack(s)) &#123;		<span class="comment">// s为黑</span></span><br><span class="line">        BinNodePosi(T) t = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(HasLChild(*s) &amp;&amp; IsRed(s-&gt;lChild)) t=s-&gt;lChild;</span><br><span class="line">   <span class="keyword">else</span> <span class="keyword">if</span>(HasRChild(*s) &amp;&amp; IsRed(s-&gt;rChild)) t=s-&gt;rChild;</span><br><span class="line">    <span class="keyword">if</span>(t) &#123;</span><br><span class="line">        RBColor oldColor = p-&gt;color;</span><br><span class="line">        <span class="comment">// 重平衡，并将新子树的左、右孩子染黑</span></span><br><span class="line">        BinNodePosi(T) b = FromParentTo(*p) = rotateAt(t);</span><br><span class="line">    	<span class="keyword">if</span>(HasLChild(*b)) b-&gt;lChild-&gt;color = RB_BLACK;</span><br><span class="line">        updateHeight(b-&gt;lChild);</span><br><span class="line">        <span class="keyword">if</span>(HasRChild(*b)) b-&gt;rChild-&gt;color = RB_BLACK;</span><br><span class="line">        updateHeight(b-&gt;rChild);</span><br><span class="line">        b-&gt;color = oldColor; updateHeight(b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 黑s无红孩子</span></span><br><span class="line">        s-&gt;color = RB_RED; s-&gt;<span class="built_in">height</span>--;	<span class="comment">// s转红</span></span><br><span class="line">        <span class="keyword">if</span>(IsRed(p)) &#123;		<span class="comment">// BB-2R</span></span><br><span class="line">            p-&gt;color = RB_BLACK;<span class="comment">// p转黑，但黑高度不变</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;			<span class="comment">// BB-2B</span></span><br><span class="line">            p-&gt;<span class="built_in">height</span>--;		<span class="comment">// p保持黑，但黑高度下降</span></span><br><span class="line">            solveDoubleBlack(p);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;	<span class="comment">// 兄弟s为红：BB-3</span></span><br><span class="line">        s-&gt;color = RB_BLACK; p-&gt;color = RB_RED;	<span class="comment">// s红p黑</span></span><br><span class="line">        BinNodePosi(T) t = IsLChild(*s) ? s-&gt;lChild</span><br><span class="line">            		: s-&gt;rChild;		   <span class="comment">// 取t与其父s同侧</span></span><br><span class="line">        _hot = p; FromParentTo(*p) = rotateAt(t); <span class="comment">//平衡调整</span></span><br><span class="line">        solveDoubleBlack(r);			   <span class="comment">// 继续修正r处双黑</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kd-树"><a class="markdownIt-Anchor" href="#kd-树"></a> kd-树</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">KdTree* <span class="title">buildKdTree</span><span class="params">(P, d)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p == &#123;p&#125;) <span class="keyword">return</span> CreateLeaf(p);	<span class="comment">// 递归基</span></span><br><span class="line">    root = CreateKdNode();				<span class="comment">// 创建子树根</span></span><br><span class="line">    <span class="comment">// 确定划分方向及中位点</span></span><br><span class="line">    root-&gt;splitDirection = Even(d) ? VERTICAL: HORIZONTAL;</span><br><span class="line">    root-&gt;splitLine = FindMedian(root-&gt;splitDirection, P);</span><br><span class="line">    (P1, P2) = Divide(P, root-&gt;splitDirection, </span><br><span class="line">                      root-&gt;splitLine);	  <span class="comment">// 子集划分</span></span><br><span class="line">    root-&gt;lChild = buildKdTree(P1, d + <span class="number">1</span>);<span class="comment">// 在d+1构造左子树</span></span><br><span class="line">    root-&gt;rChild = buildKdTree(P2, d + <span class="number">1</span>);<span class="comment">// 在d+1构造右子树</span></span><br><span class="line">    <span class="keyword">return</span> root;					      <span class="comment">// 返回树根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">kdSearch(v, R) &#123;</span><br><span class="line">    <span class="keyword">if</span>(lsLeaf(v))				<span class="comment">// 直接判断，终止递归</span></span><br><span class="line">    &#123; <span class="keyword">if</span>(inside(v, R)) report(v); <span class="keyword">return</span>; &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(region(v-&gt;lChild) ⊆ R)	<span class="comment">// 若左子树完全包含于R内，遍历</span></span><br><span class="line">        reportSubtree(v-&gt;lChild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;lChild) ∩ R ≠ Ø)<span class="comment">// 与R相交，递归查询</span></span><br><span class="line">        kdSearch(v-&gt;lChild, R);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(region(v-&gt;rChild) ⊆ R)	<span class="comment">// 若右子树完全包含于R内，遍历</span></span><br><span class="line">        reportSubtree(v-&gt;rChild);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(region(v-&gt;rChild) ∩ R ≠ Ø)<span class="comment">// 与R相交，递归查询</span></span><br><span class="line">        kdSearch(v-&gt;rChild, R);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title>第十一章 串</title>
    <url>/2020/10/08/DS/%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0%20%E4%B8%B2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十一章-串"><a class="markdownIt-Anchor" href="#第十一章-串"></a> 第十一章 串</h2>
<h3 id="蛮力匹配"><a class="markdownIt-Anchor" href="#蛮力匹配"></a> 蛮力匹配</h3>
<h4 id="版本一"><a class="markdownIt-Anchor" href="#版本一"></a> 版本一</h4>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* P, <span class="keyword">char</span>* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="built_in">strlen</span>(T), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> m = <span class="built_in">strlen</span>(P), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; m &amp;&amp; i &lt; n) </span><br><span class="line">        <span class="keyword">if</span>(P[j] == T[i]) &#123;</span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="keyword">else</span> &#123;</span><br><span class="line">            i -= j - <span class="number">1</span>;</span><br><span class="line">            j = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> i - j;			<span class="comment">// i - j &gt; n - m 越界</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="版本二"><a class="markdownIt-Anchor" href="#版本二"></a> 版本二</h4>
<p><img src="https://i.loli.net/2020/09/28/OARj3sqQmFgy5Sd.png" alt="image-20200928161008978.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* P, <span class="keyword">char</span>* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> n = <span class="built_in">strlen</span>(T), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">size_t</span> m = <span class="built_in">strlen</span>(P), j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; n - m + <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; m; j++) </span><br><span class="line">            <span class="keyword">if</span>(T[i + j] != P[j])</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(m &lt;= j)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="kmp算法"><a class="markdownIt-Anchor" href="#kmp算法"></a> KMP算法</h3>
<p>​	N(P, j) = {0 ≤ t &lt; j | P[0, t) == P[j - t, j) }</p>
<p><img src="https://i.loli.net/2020/09/28/qrp5MAe28VjEmNv.png" alt="image-20200928170853743.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">match</span><span class="params">(<span class="keyword">char</span>* P, <span class="keyword">char</span>* T)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* next = bulidNext(P);		<span class="comment">// 构造next表</span></span><br><span class="line">    <span class="keyword">int</span> n = (<span class="keyword">int</span>) <span class="built_in">strlen</span>(T), i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> m = (<span class="keyword">int</span> )<span class="built_in">strlen</span>(P), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; m &amp;&amp; i &lt; n) </span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &gt; j || T[i] == P[j]) &#123;	<span class="comment">// 若匹配</span></span><br><span class="line">            i++; j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> 						<span class="comment">// 否则，P右移，T不回退</span></span><br><span class="line">            j = next[j];</span><br><span class="line">    <span class="keyword">delete</span> [] next;					<span class="comment">// 释放next表</span></span><br><span class="line">    <span class="keyword">return</span> i - j;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="next表"><a class="markdownIt-Anchor" href="#next表"></a> next表</h4>
<p>next(j)是在P[0, j)中最大自匹配的真前缀和真后缀的长度</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildNext</span><span class="params">(<span class="keyword">char</span>* P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">size_t</span> m = <span class="built_in">strlen</span>(P), j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span>* N = <span class="keyword">new</span> <span class="keyword">int</span>[m];			<span class="comment">// next表</span></span><br><span class="line">    <span class="keyword">int</span> k = N[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; m - <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">if</span>(<span class="number">0</span> &gt; k || P[j] == P[k]) 	<span class="comment">// 匹配</span></span><br><span class="line">            N[++j] = ++k;</span><br><span class="line">    	<span class="keyword">else</span>						<span class="comment">// 失效</span></span><br><span class="line">            k = N[k];</span><br><span class="line">    <span class="keyword">return</span> N;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bm_bc算法坏字符策略"><a class="markdownIt-Anchor" href="#bm_bc算法坏字符策略"></a> BM_BC算法(坏字符策略)</h3>
<ul>
<li>从后向前匹配</li>
</ul>
<h4 id="bc表"><a class="markdownIt-Anchor" href="#bc表"></a> BC表</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">buildBC</span><span class="params">(<span class="keyword">char</span>* P)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>* bc = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">256</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">256</span>; j++) bc[j] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> m = <span class="built_in">strlen</span>(P), j = <span class="number">0</span>; j &lt; m; j++)</span><br><span class="line">        bc[P[j]] = j;</span><br><span class="line">    <span class="keyword">return</span> bc;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="bm_gs算法好后缀策略"><a class="markdownIt-Anchor" href="#bm_gs算法好后缀策略"></a> BM_GS算法(好后缀策略)</h3>
<h4 id="构建gs表"><a class="markdownIt-Anchor" href="#构建gs表"></a> 构建gs表</h4>
<h5 id="ms-ss"><a class="markdownIt-Anchor" href="#ms-ss"></a> MS[] -&gt; ss[]</h5>
<p><img src="https://i.loli.net/2020/10/08/ltOuBH1ypiINcha.png" alt="image-20201007201021840.png" /></p>
<h5 id="ss-gs"><a class="markdownIt-Anchor" href="#ss-gs"></a> ss[] -&gt; gs[]</h5>
<p><img src="https://i.loli.net/2020/10/08/XJuYFGhi9krAoVy.png" alt="image-20201007201113350.png" /></p>
<h3 id="karp-rabin算法"><a class="markdownIt-Anchor" href="#karp-rabin算法"></a> Karp-Rabin算法</h3>
<p><img src="https://i.loli.net/2020/10/08/BJ8LexK1tCDMOHq.png" alt="image-20201007202217494.png" /></p>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 图</title>
    <url>/2020/09/17/DS/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E5%9B%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-图"><a class="markdownIt-Anchor" href="#第六章-图"></a> 第六章 图</h2>
<h3 id="顶点和边"><a class="markdownIt-Anchor" href="#顶点和边"></a> 顶点和边</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNDISCOVERED, DISCOVERED, VISITED&#125; VStatus;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Vertex</span> &#123;</span></span><br><span class="line">    Tv data; <span class="keyword">int</span> inDegree, outDegree;	<span class="comment">// 数据、出入度数</span></span><br><span class="line">    VStatus status;						<span class="comment">// 状态</span></span><br><span class="line">    <span class="keyword">int</span> dTime, fTime;					<span class="comment">// 发现时刻、访问完时刻</span></span><br><span class="line">    <span class="keyword">int</span> parent;							<span class="comment">// 遍历树中父节点</span></span><br><span class="line">    <span class="keyword">int</span> priority;						<span class="comment">// 遍历树中优先级</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD&#125; </span><br><span class="line">EStatus;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">Edge</span> &#123;</span></span><br><span class="line">    Te data;			<span class="comment">// 数据</span></span><br><span class="line">    <span class="keyword">int</span> weight;			<span class="comment">// 权重</span></span><br><span class="line">    EStatus status;		<span class="comment">// 类型</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2020/09/16/ioFlDQ6NMV8XAug.png" alt="几种图边.png" /></p>
<h3 id="广度优先搜索bfs"><a class="markdownIt-Anchor" href="#广度优先搜索bfs"></a> 广度优先搜索(BFS)</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::BFS(<span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; Q; status(v) = DISCOVERED; Q.euqueue(v);</span><br><span class="line">    <span class="keyword">while</span>(!Q.empty()) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = Q.dequeue();</span><br><span class="line">        dTime = ++clock;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> u = firstNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u))</span><br><span class="line">            <span class="keyword">if</span>(status(u) == UNDISCOVERED) &#123;	<span class="comment">// 若u未被发现</span></span><br><span class="line">                status(u) = DISCOVERED;		<span class="comment">// 发现该顶点</span></span><br><span class="line">                Q.euqueue(u);</span><br><span class="line">                status(v, u) = Tree;		<span class="comment">// 引入树边</span></span><br><span class="line">                parent(u) = v;				</span><br><span class="line">            &#125; </span><br><span class="line">        	<span class="keyword">else</span></span><br><span class="line">                status(v, u) = CROSS;</span><br><span class="line">                </span><br><span class="line">        status(v) = VISITED;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::bfs(<span class="keyword">int</span> s) &#123;		<span class="comment">// s为起始节点</span></span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">int</span> clock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span>(status(v) == UNDISCOVERED)</span><br><span class="line">            BFS(v, clock);</span><br><span class="line">    &#125;<span class="keyword">while</span>(s != (v = ++v % n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>BFS可以得到最短路径</li>
</ul>
<h3 id="深度优先搜索dfs"><a class="markdownIt-Anchor" href="#深度优先搜索dfs"></a> 深度优先搜索(DFS)</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::DFS(<span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock) &#123;</span><br><span class="line">    dTime(v) = ++clock;</span><br><span class="line">    status(v) = DISCOVERED;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = firstNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(status(u)) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNDISCOVERED:		<span class="comment">// u尚未发现，意味支撑树可扩展</span></span><br><span class="line">                status(v, u) = TREE;</span><br><span class="line">                parent(u) = v;</span><br><span class="line">                DFS(u, clock);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// u已被发现但尚未访问完毕，应属被后代指向的祖先</span></span><br><span class="line">            <span class="keyword">case</span> DISCOVERED:		</span><br><span class="line">                status(v, u) = BACKWARD;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:		<span class="comment">// u已访问完毕，视承袭关系分为前向边或跨边</span></span><br><span class="line">                status(v, u) = dTime(v) &lt; dTime(u) ? FORWARD : 						CROSS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status(v) = VISITED;</span><br><span class="line">    fTime(v) = ++clock;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::dfs(<span class="keyword">int</span> s) &#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">int</span> clock = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(status(v) == UNDISCOVERED)</span><br><span class="line">        	DFS(v, clock);</span><br><span class="line">    &#125;<span class="keyword">while</span>(s != (v = v++ % n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="括号引理parenthesis-lemma"><a class="markdownIt-Anchor" href="#括号引理parenthesis-lemma"></a> 括号引理(Parenthesis lemma)</h4>
<p>给定有向图G = (V, E)及其任一DFS森林，则</p>
<ul>
<li>u是v的后代	iff	active[u]	⊆	active[v]</li>
<li>u是v的祖先	iff	active[u]	⊇	active[v]</li>
<li>u与v“无关”	iff	active[u]	∩	active[v]	=	Ø</li>
</ul>
<h3 id="基于dfs搜索框架的拓补排序算法"><a class="markdownIt-Anchor" href="#基于dfs搜索框架的拓补排序算法"></a> 基于DFS搜索框架的拓补排序算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="built_in">stack</span>&lt;Tv&gt;* Graph&lt;Tv, Te&gt;::tSort(<span class="keyword">int</span> s) &#123;</span><br><span class="line">    reset(); <span class="keyword">int</span> clock = <span class="number">0</span>; <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(status(v) == UNDISCOVERED)</span><br><span class="line">            <span class="keyword">if</span>(!TSort(v, clock, s)) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!S.empty())</span><br><span class="line">                    S-&gt;pop();</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>(s != (v = ++v % n));</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt;</span><br><span class="line"><span class="keyword">bool</span> Graph&lt;Tv, Te&gt;::TSort(<span class="keyword">int</span> v, <span class="keyword">int</span>&amp; clock, <span class="built_in">stack</span>&lt;Tv&gt;* S)</span><br><span class="line">&#123;</span><br><span class="line">    dTime(v) = ++clock; status(v) = DISCOVERED;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> u = firstNbr(v); <span class="number">-1</span> &lt; u; u = nextNbr(v, u)) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(status(u)) &#123;</span><br><span class="line">            <span class="keyword">case</span> UNDISCOVERED:		<span class="comment">// u尚未发现，意味支撑树可扩展</span></span><br><span class="line">                status(v, u) = TREE;</span><br><span class="line">                parent(u) = v;</span><br><span class="line">                <span class="keyword">if</span>(!TSort(u, clock, S));</span><br><span class="line">                	<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">// u已被发现但尚未访问完毕，应属被后代指向的祖先</span></span><br><span class="line">            <span class="keyword">case</span> DISCOVERED:		</span><br><span class="line">                status(v, u) = BACKWARD;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">default</span>:		<span class="comment">// u已访问完毕，视承袭关系分为前向边或跨边</span></span><br><span class="line">                status(v, u) = dTime(v) &lt; dTime(u) ? FORWARD : 						CROSS;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    status(v) = VISITED;</span><br><span class="line">	S-&gt;push(vertex(v));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="优先级搜索priority-first-search"><a class="markdownIt-Anchor" href="#优先级搜索priority-first-search"></a> 优先级搜索(priority-first search)</h3>
<p>​		优先级数越大顶点的优先级越低</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::PFS(<span class="keyword">int</span> s, PU prioUpdater) &#123;</span><br><span class="line">    priority(s) = <span class="number">0</span>; status(s) = VISITED; parent(s) = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w = firstNbr(s); <span class="number">-1</span> &lt; w; w = nextNbr(s, w))</span><br><span class="line">            prioUpdater(<span class="keyword">this</span>, s, w);   <span class="comment">// 更新顶点w的优先级及其父节点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> shortest = INT_MAX, w = <span class="number">0</span>; w &lt; n; w++)</span><br><span class="line">            <span class="keyword">if</span>(status(w) == UNDISCOVERED)	<span class="comment">// 从尚未遍历的顶点中</span></span><br><span class="line">                <span class="keyword">if</span>(shortest &gt; priority(w)) &#123;<span class="comment">// 选出下一个</span></span><br><span class="line">                    shortest = priority(w);	<span class="comment">// 优先级最高的顶点</span></span><br><span class="line">                    s = w;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">if</span>(status(s) == VISITED)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        status(s) = VISITED; 			<span class="comment">// 将s及其父顶点的联边加入树</span></span><br><span class="line">        status(parent(s), s) = TREE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="keyword">template</span> &lt;<span class="keyword">typename</span> PU&gt;</span><br><span class="line"><span class="keyword">void</span> Graph&lt;Tv, Te&gt;::pfs(<span class="keyword">int</span> s, PU prioUpdater) &#123;</span><br><span class="line">    reset();</span><br><span class="line">    <span class="keyword">int</span> v = s;</span><br><span class="line">    <span class="keyword">do</span> </span><br><span class="line">        <span class="keyword">if</span>(status(v) = UNDISCOVERED)</span><br><span class="line">            PFS(v, prioUpdater);</span><br><span class="line">    <span class="keyword">while</span>(s != (v = ++v % n));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="基于pfs的bfs算法"><a class="markdownIt-Anchor" href="#基于pfs的bfs算法"></a> 基于PFS的BFS算法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">BfsPU</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g-&gt;status(v) == UNDISCOVERED) &#123;</span><br><span class="line">            <span class="keyword">if</span>(g-&gt;priority(v) &gt; g-&gt;priority(uk) + <span class="number">1</span>)</span><br><span class="line">                g-&gt;priority(v) = g-&gt;priority(uk) + <span class="number">1</span>；</span><br><span class="line">                g-&gt;parent(v) = uk;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="基于pfs的dfs算法"><a class="markdownIt-Anchor" href="#基于pfs的dfs算法"></a> 基于PFS的DFS算法</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">DfsPU</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g-&gt;status(v) == UNDISCOVERED) &#123;</span><br><span class="line">           	<span class="keyword">if</span>(g-&gt;priority(v) &gt; g-&gt;priority(uk) - <span class="number">1</span>) &#123;</span><br><span class="line">                g-&gt;priority(v) = g-&gt;priority(uk) - <span class="number">1</span>;</span><br><span class="line">                g-&gt;parent(v) = uk;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="基于pfs的prim算法"><a class="markdownIt-Anchor" href="#基于pfs的prim算法"></a> 基于PFS的Prim算法</h3>
<p>​		在找到V<sub>k</sub>的最短跨越边e<sub>k</sub>=(v<sub>k</sub>, u<sub>k</sub>)后，可以将T<sub>k</sub>扩展为更大子树T<sub>k+1</sub></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PrimPU</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g-&gt;status(v) == UNDISCOVERED) &#123;<span class="comment">//对uk每一尚未被发现邻接点</span></span><br><span class="line">            <span class="keyword">if</span>(g-&gt;priority(v) &gt; g-&gt;weight(uk, v)) &#123;</span><br><span class="line">                g-&gt;priority(v) = g-&gt;weight(uk, v);	<span class="comment">// 更新优先数</span></span><br><span class="line">                g-&gt;parent(v) = uk;					<span class="comment">// 更新父节点</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="基于pfs的dijkstra算法"><a class="markdownIt-Anchor" href="#基于pfs的dijkstra算法"></a> 基于PFS的Dijkstra算法</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 考虑u~k+1~到起点s的距离</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Tv, <span class="keyword">typename</span> Te&gt; <span class="class"><span class="keyword">struct</span> <span class="title">DijkstraPU</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Graph&lt;Tv, Te&gt;* g, <span class="keyword">int</span> uk, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(g-&gt;status(v) == UNDISCOVERED) &#123;</span><br><span class="line">            <span class="keyword">if</span>(priority(v) &gt; priority(uk) + weight(uk, v)) &#123;</span><br><span class="line">                priority(v) = priority(uk) + weight(uk, v);</span><br><span class="line">                g-&gt;parent(v) = uk;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>
<p>欧拉环路(Eulerian tour)</p>
<p>​	经过每一条边一次且恰好一次的环路</p>
</li>
<li>
<p>哈密尔顿环路(Hamiltonian tour)</p>
<p>​	经过每一个顶点一次且恰好一次的环路</p>
</li>
<li>
<p>活动期</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">active[u] = (dTime[u], fTime[u])</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>拓扑排序</p>
<p>​	对一个DAG进行拓扑排序，将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边&lt;u, v&gt; ∈ E(G)，则u在线性序列中出现在v之前</p>
</li>
<li>
<p>关节点(articulation point)</p>
<p>​	节点的删除将导致连通域的增加</p>
</li>
<li>
<p>双连通图</p>
<p>​	不含任何关节点的图</p>
</li>
<li>
<p>最小支撑树</p>
<p>​	最小支撑树总是会采用联接每一割的最短跨越边</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>图</tag>
      </tags>
  </entry>
  <entry>
    <title>第十章 优先级队列</title>
    <url>/2020/09/27/DS/%E7%AC%AC%E5%8D%81%E7%AB%A0%20%E4%BC%98%E5%85%88%E7%BA%A7%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十章-优先级队列"><a class="markdownIt-Anchor" href="#第十章-优先级队列"></a> 第十章 优先级队列</h2>
<h3 id="优先级队列"><a class="markdownIt-Anchor" href="#优先级队列"></a> 优先级队列</h3>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">struct</span> <span class="title">PQ</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span> </span>= <span class="number">0</span>;	<span class="comment">// 按照优先级插入词条</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">getMax</span><span class="params">()</span> </span>= <span class="number">0</span>;		<span class="comment">// 取出优先级最高的词条</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> T <span class="title">delMax</span><span class="params">()</span> </span>= <span class="number">0</span>;		<span class="comment">// 删除优先级最高的词条</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="完全二叉堆"><a class="markdownIt-Anchor" href="#完全二叉堆"></a> 完全二叉堆</h3>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> Parent(i) ((i - 1) &gt;&gt; 1)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LChild(i) (1 + ((i) &lt;&lt; 1))	<span class="comment">// 奇数</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> RChild(i) ((1 + (i)) &lt;&lt; 1)	<span class="comment">// 偶数</span></span></span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="class"><span class="keyword">class</span> <span class="title">PQ_ComplHeap</span>:</span><span class="keyword">public</span> PQ&lt;T&gt;&#123;</span><br><span class="line"><span class="keyword">protected</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">percolateDown</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> i)</span></span>;	<span class="comment">// 下滤</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">percolate00Up</span><span class="params">(<span class="keyword">int</span> i)</span></span>;				<span class="comment">// 上滤</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="keyword">int</span> n)</span></span>;				<span class="comment">//Floyd建堆算法</span></span><br><span class="line"><span class="keyword">public</span>:				</span><br><span class="line">    <span class="function">PQ <span class="title">ComplHeap</span><span class="params">(T* A, <span class="keyword">int</span> n)</span>			<span class="comment">// 批量构造</span></span></span><br><span class="line"><span class="function">    </span>&#123; copyFrom(A, <span class="number">0</span>, n); &#125;				</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;						<span class="comment">// 插入</span></span><br><span class="line">    <span class="function">T <span class="title">getMax</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _elem[<span class="number">0</span>]; &#125;		<span class="comment">// 读取</span></span><br><span class="line">    <span class="function">T <span class="title">delMax</span><span class="params">()</span></span>;  						<span class="comment">// 删除</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="插入和上滤"><a class="markdownIt-Anchor" href="#插入和上滤"></a> 插入和上滤</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::insert(T e)</span><br><span class="line">&#123; <span class="built_in">vector</span>&lt;T&gt;::insert(e); percolateUp(_size - <span class="number">1</span>); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> PQ_ComplHeap&lt;T&gt;::percolateUp(<span class="keyword">int</span> i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">while</span>(ParentValid(i)) &#123;						<span class="comment">// 未到根</span></span><br><span class="line">        <span class="keyword">int</span> j = Parent(i);</span><br><span class="line">        <span class="keyword">if</span>(less&lt;<span class="keyword">int</span>&gt;(_elem[i], _elem[j])) <span class="keyword">break</span>;<span class="comment">// 不再逆序</span></span><br><span class="line">        swap(_elem[i], _elem[j]); i = j;		<span class="comment">// 交换父子位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> i;									<span class="comment">// 返回最终位置</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="删除和下滤"><a class="markdownIt-Anchor" href="#删除和下滤"></a> 删除和下滤</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T PQ_ComplHeap&lt;T&gt;::delMax()</span><br><span class="line">&#123;</span><br><span class="line">    T maxElem = _elem[<span class="number">0</span>]; _elem[<span class="number">0</span>] = _elem[--<span class="built_in">size</span>];</span><br><span class="line">    percolateDown(_size, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> maxElem;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">int</span> PQ_ComplHeap&lt;T&gt;::percloateDown(<span class="keyword">int</span> n, <span class="keyword">int</span> i)<span class="comment">// 下滤</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> j;</span><br><span class="line">    <span class="keyword">while</span>(i != (j = ProperParent(_elem, n, i)))	<span class="comment">// 只要i非j</span></span><br><span class="line">    &#123; swap(_elem[i], _elem[j]); i = j;&#125;			<span class="comment">// 换位</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="批量建堆"><a class="markdownIt-Anchor" href="#批量建堆"></a> 批量建堆</h3>
<h4 id="自下而上的下滤"><a class="markdownIt-Anchor" href="#自下而上的下滤"></a> 自下而上的下滤</h4>
<p>渐进意义下的O(n)</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">PQ_CompHealp(T* A, <span class="keyword">int</span> n) </span><br><span class="line">&#123; copyFrom(A, <span class="number">0</span>, n); heapify(n); &#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> PQ_ComplHeap&lt;T&gt;::heapify(<span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = n / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)	<span class="comment">// 自下而上，依次</span></span><br><span class="line">        percolateDown(n, i);			<span class="comment">// 下滤各内部节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="堆排序"><a class="markdownIt-Anchor" href="#堆排序"></a> 堆排序</h3>
<p><img src="https://i.loli.net/2020/09/27/Xh1W3cOMVzD2u8L.png" alt="image-20200927151243390.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> <span class="built_in">vector</span>&lt;T&gt;::heapSort(<span class="keyword">int</span> io, <span class="keyword">int</span> hi) &#123;</span><br><span class="line">    <span class="function">PQ_ComplHeap&lt;T&gt; <span class="title">H</span><span class="params">(_elem + lo, hi - lo)</span></span>;	<span class="comment">//待排序区间</span></span><br><span class="line">	<span class="keyword">while</span>(!H.empty())</span><br><span class="line">        _elem[--hi] = H.delMax();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="左式堆"><a class="markdownIt-Anchor" href="#左式堆"></a> 左式堆</h3>
<ul>
<li>高效合并</li>
<li>每个节点的npl值均等于其右侧通路的长度</li>
<li>npl® = d，该堆包含一棵高度为d的满二叉树</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;	<span class="comment">// 基于二叉树，以左式堆形式实现</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PQ_LeftHeap</span> :</span> <span class="keyword">public</span> PQ&lt;T&gt;, <span class="keyword">public</span> BinTree&lt;T&gt; &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(T)</span></span>;</span><br><span class="line">    <span class="function">T <span class="title">getMax</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> _root-&gt;data; &#125;</span><br><span class="line">    <span class="function">T <span class="title">delMax</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="合并"><a class="markdownIt-Anchor" href="#合并"></a> 合并</h4>
<p>围绕右侧链进行，时间复杂度O(logn)</p>
<p><img src="https://i.loli.net/2020/09/27/E4pz1wa2x5RMrqh.png" alt="image-20200927155959786.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;<span class="function"><span class="keyword">static</span> <span class="title">BinNodePosi</span><span class="params">(T)</span> <span class="title">merge</span><span class="params">(BinNodePosi(T) a, BinNodePosi(T) b)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!a) <span class="keyword">return</span> b;	<span class="comment">// 递归基</span></span><br><span class="line">    <span class="keyword">if</span>(!b) <span class="keyword">return</span> a;	<span class="comment">// 递归基</span></span><br><span class="line">    <span class="keyword">if</span>(lt(a-&gt;data, b-&gt;data)) swap(a, b);	<span class="comment">// 确保a&gt;=b</span></span><br><span class="line">    a-&gt;rc = merge(a-&gt;rc, b);	<span class="comment">// 将a的右子堆，与b合并</span></span><br><span class="line">    a-&gt;rc-&gt;parent = a;			<span class="comment">// 更新父子关系</span></span><br><span class="line">    <span class="keyword">if</span>(!a-&gt;lc || a-&gt;lc-&gt;npl &lt; a-&gt;rc-&gt;npl)</span><br><span class="line">        swap(a-&gt;lc, a-&gt;rc);		<span class="comment">// 交换a的左、右子堆</span></span><br><span class="line">    a-&gt;npl = a-&gt;rc ? a-&gt;rc-&gt;npl + <span class="number">1</span> : <span class="number">1</span>; <span class="comment">// 更新a的npl</span></span><br><span class="line">    <span class="keyword">return</span> a;					<span class="comment">// 返回合并后的堆顶</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="插入与删除"><a class="markdownIt-Anchor" href="#插入与删除"></a> 插入与删除</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> PQ_LeftHeap&lt;T&gt;::insert(T e) &#123;</span><br><span class="line">    BinNodePosi(T) v = <span class="keyword">new</span> BinNode&lt;T&gt;(e);</span><br><span class="line">    _root = merge(_root, v);</span><br><span class="line">    _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    _size++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; T PQ_LeftHeap&lt;T&gt;::delMax()</span><br><span class="line">&#123;</span><br><span class="line">    BinNodePosi(T) lHeap = _root-&gt;lc;</span><br><span class="line">    BinNodePosi(T) rHeap = _root-&gt;rc;</span><br><span class="line">    T e = _root-&gt;data;</span><br><span class="line">    <span class="keyword">delete</span> _root; _size--;</span><br><span class="line">    _root = merge(lHeap, rHeap);</span><br><span class="line">    <span class="keyword">if</span>(_root) _root-&gt;parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> e;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>单侧倾斜</li>
</ol>
<ul>
<li>节点分布偏向于左侧</li>
<li>合并操作偏向于右侧</li>
</ul>
<ol start="2">
<li>空节点路径长度(npl)</li>
</ol>
<ul>
<li>
<p>npl(x) = x到外部节点的最近距离</p>
</li>
<li>
<p>npl(x) = 以x为根的最大满子树的高度</p>
</li>
</ul>
<ol start="3">
<li>
<p>左倾</p>
<p>​	npl( lc(x) ) &gt;= npl( rc(x) )</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>第四章 栈与队列</title>
    <url>/2020/09/10/DS/%E7%AC%AC%E5%9B%9B%E7%AB%A0%20%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第四章-栈与队列"><a class="markdownIt-Anchor" href="#第四章-栈与队列"></a> 第四章 栈与队列</h2>
<h3 id="栈应用"><a class="markdownIt-Anchor" href="#栈应用"></a> 栈应用</h3>
<ol>
<li>逆序输出（进制转换）</li>
</ol>
<a id="more"></a>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">convert</span><span class="params">(Stack&lt;<span class="keyword">char</span>&gt;&amp; S, <span class="keyword">int</span> n, <span class="keyword">int</span> base)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> digit[] = </span><br><span class="line">    &#123;<span class="string">'0'</span>, <span class="string">'1'</span>, <span class="string">'2'</span>, <span class="string">'3'</span>, <span class="string">'4'</span>,<span class="string">'5'</span>, <span class="string">'6'</span>, <span class="string">'7'</span>, <span class="string">'8'</span>, <span class="string">'9'</span>,</span><br><span class="line">     <span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>, <span class="string">'D'</span>, <span class="string">'E'</span>, <span class="string">'F'</span>&#125;;</span><br><span class="line">    <span class="keyword">while</span>(n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        S.push([n % base]);</span><br><span class="line">    	n /= base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>
<p>递归嵌套（括号匹配）（栈混洗）</p>
<ul>
<li>括号匹配：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">paren</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> <span class="built_in">exp</span>[], <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack&lt;<span class="keyword">char</span>&gt; S;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = lo; i &lt; hi; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">'('</span> == <span class="built_in">exp</span>[i]) </span><br><span class="line">            S.push(<span class="built_in">exp</span>[i]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!S.empty())</span><br><span class="line">            S.pop();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;		<span class="comment">// 遇右括号时栈已空</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S.empty();			<span class="comment">// 左括号缺少右括号匹配</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>栈混洗</li>
</ul>
<p><img src="https://i.loli.net/2020/09/09/AUgMQrjKin15xIY.png" alt="image-20200909111850275.png" /></p>
</li>
</ol>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mi>C</mi><mi>a</mi><mi>t</mi><mi>a</mi><mi>l</mi><mi>a</mi><mi>n</mi><mo>=</mo><mfrac><mrow><mo stretchy="false">(</mo><mn>2</mn><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow><mrow><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">!</mo><mo stretchy="false">(</mo><mi>n</mi><mo>+</mo><mn>1</mn><mo stretchy="false">)</mo><mo stretchy="false">!</mo></mrow></mfrac></mrow><annotation encoding="application/x-tex">Catalan = \frac{(2n)!}{(n)!(n+1)!}
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathnormal" style="margin-right:0.07153em;">C</span><span class="mord mathnormal">a</span><span class="mord mathnormal">t</span><span class="mord mathnormal">a</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">a</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:2.363em;vertical-align:-0.936em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.427em;"><span style="top:-2.314em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">!</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mord">1</span><span class="mclose">)</span><span class="mclose">!</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mopen">(</span><span class="mord">2</span><span class="mord mathnormal">n</span><span class="mclose">)</span><span class="mclose">!</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.936em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span></span></p>
<p>​		甄别：O(n<sup>3</sup>)：对于i , j, k，出现k, i, j的情况必不为栈混洗</p>
<p>​				    O(n<sup>2</sup>)：对于i, j, j+1, 出现 j+1, i, j的情况必不为栈混洗</p>
<p>​					O(n)：再来一次栈混洗，看能不能实现序列B中的效果</p>
   <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">bool</span> <span class="title">stackWashing</span>(<span class="title">stack</span>&lt;T&gt; <span class="title">a</span>, <span class="title">stack</span>&lt;T&gt; <span class="title">b</span>) &#123;</span>	</span><br><span class="line">	<span class="built_in">stack</span>&lt;T&gt; rb, s;</span><br><span class="line">	<span class="keyword">while</span> (b.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		rb.push(b.top());</span><br><span class="line">		b.pop();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">while</span> (a.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		s.push(a.top());</span><br><span class="line">		a.pop();</span><br><span class="line">		<span class="keyword">while</span> (s.<span class="built_in">size</span>() &amp;&amp; s.top() == rb.top()) &#123;</span><br><span class="line">                <span class="comment">//将s中累计的元素清算</span></span><br><span class="line">			s.pop();</span><br><span class="line">			rb.pop();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> s.empty();<span class="comment">//若s为空则代表栈清洗成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="3">
<li>
<p>延迟缓冲（中缀表达式求值）</p>
<p><img src="https://i.loli.net/2020/09/09/4CGt3Tb9wMSYEus.png" alt="image-20200909140612606.png" /></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">evaluate</span><span class="params">(<span class="keyword">char</span>* S, <span class="keyword">char</span>*&amp; RPN)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Stack&lt;<span class="keyword">char</span>&gt; opnd, optr;</span><br><span class="line">	optr.push(<span class="string">'\0'</span>);</span><br><span class="line">	<span class="keyword">while</span> (!optr.empty()) &#123;</span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isdigit</span>(*S)) &#123;</span><br><span class="line">			readNumber(S, opnd);</span><br><span class="line">			append(RPN, opnd.top());</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			<span class="keyword">switch</span> (orderBetween(optr.top(), *S)) &#123;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&lt;'</span>:</span><br><span class="line">				optr.push(S);</span><br><span class="line">				S++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'='</span>:</span><br><span class="line">				optr.pop();</span><br><span class="line">                S++;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">case</span> <span class="string">'&gt;'</span>:</span><br><span class="line">				<span class="keyword">char</span> op = optr.pop(); append(RPN, op);</span><br><span class="line">				<span class="keyword">if</span> (<span class="string">'!'</span> == op) &#123;</span><br><span class="line">					<span class="keyword">float</span> pOpnd = opnd.pop();</span><br><span class="line">					opnd.push(calcu(op, pOpnd));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">else</span> &#123;</span><br><span class="line">					<span class="keyword">float</span> pOpnd2 = opnd.pop(); pOpnd1 = opnd.pop();</span><br><span class="line">					opnd.push(calcu(pOpnd1, op, pOpnd2));</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">			&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> opnd.pop();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>栈式计算（逆波兰表达式(Reverse Polish Notation)）</p>
<p>​		在由运算符和操作数组成的表达式中不使用括号，即可表示带优先级的运算关系</p>
<p><img src="https://i.loli.net/2020/09/19/Uatq62Pf3kOrmZo.png" alt="image-20200909142359936.png" /></p>
</li>
</ol>
<h3 id="试探回溯法"><a class="markdownIt-Anchor" href="#试探回溯法"></a> 试探回溯法</h3>
<h4 id="n皇后问题"><a class="markdownIt-Anchor" href="#n皇后问题"></a> N皇后问题</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queen</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y;</span><br><span class="line">    Queen(<span class="keyword">int</span> xx = <span class="number">0</span>, <span class="keyword">int</span> yy = <span class="number">0</span>) : x(xx), y(yy) &#123; &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>==(Queen <span class="keyword">const</span>&amp; q) <span class="keyword">const</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (x == q.x)</span><br><span class="line">            || (y == q.y)</span><br><span class="line">            || (x + y == q.x + q.y)</span><br><span class="line">            || (x - y == q.x - q.y)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> !=(Queen <span class="keyword">const</span>&amp; q)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> !(*<span class="keyword">this</span> == q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">placeQueen</span><span class="params">(<span class="keyword">int</span> N)</span> </span>&#123;	<span class="comment">// N皇后算法（迭代版）：反复试探回溯</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;Queen&gt; solu; <span class="comment">//存放（部分）解的栈</span></span><br><span class="line">    <span class="function">Queen <span class="title">q</span><span class="params">(<span class="number">0</span>, <span class="number">0</span>)</span></span>; <span class="comment">//从原点位置出发</span></span><br><span class="line">    <span class="keyword">do</span> &#123; <span class="comment">//反复试探、回溯</span></span><br><span class="line">        <span class="keyword">if</span>(N &lt;= solu.<span class="built_in">size</span>() || q.y &gt;= N) &#123; <span class="comment">//若已出界，则</span></span><br><span class="line">            q = solu.pop();	q.y++;	<span class="comment">// 回溯一行并继续试探下一列</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">             <span class="comment">//通过与已有皇后的比对</span></span><br><span class="line">            <span class="keyword">while</span>((q.y &lt; N) &amp;&amp; (<span class="number">0</span> &lt;= solu.<span class="built_in">find</span>(q))) &#123;</span><br><span class="line">                q.y++; nCheck++; <span class="comment">//尝试找到可摆放下一皇后的列</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(q.y &lt; N) &#123;</span><br><span class="line">                solu.push(q); <span class="comment">//摆上当前皇后，并</span></span><br><span class="line">                <span class="keyword">if</span>(N &lt;= solu.<span class="built_in">size</span>()) nSolu++;<span class="comment">// 全局变量nSolu</span></span><br><span class="line">                q.x++; q.y = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span>((<span class="number">0</span> &lt; q.x) || (q.y &lt; N));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="迷宫寻径"><a class="markdownIt-Anchor" href="#迷宫寻径"></a> 迷宫寻径</h4>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迷宫单元状态</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;AVALIABLE, ROUTE, BACKTRACKED, WALL&#125; Status;</span><br><span class="line"><span class="comment">// 单元的相对邻接方向</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span> &#123;UNKNOWN, EAST, SOUTH, WEST, NORTH, NO_WAY&#125; ESWN;</span><br><span class="line"><span class="comment">// 依次转至下一邻接方向</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> ESWN <span class="title">nextESWN</span><span class="params">(ESWN eswn)</span> </span>&#123; <span class="keyword">return</span> ESWN(eswn + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Cell</span> &#123;</span>					<span class="comment">// 迷宫格点</span></span><br><span class="line">    <span class="keyword">int</span> x, y; 					<span class="comment">// x, y坐标 </span></span><br><span class="line">    Status status;				<span class="comment">// 格点类型</span></span><br><span class="line">    ESWN incoming, outgoing;	<span class="comment">// 进入、走出方向</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LABY_MAX 24 			<span class="comment">// 最大迷宫尺寸</span></span></span><br><span class="line">Cell laby[LABY_MAX][LABY_MAX];</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 邻格查询</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> Cell* <span class="title">neighbor</span><span class="params">(Cell* cell)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(cell-&gt;outgoing) &#123;</span><br><span class="line">        <span class="keyword">case</span> EAST : <span class="keyword">return</span> cell + LABY_MAX;	<span class="comment">// 向东</span></span><br><span class="line">        <span class="keyword">case</span> SOUTH: <span class="keyword">return</span> cell + <span class="number">1</span>;		<span class="comment">// 向南</span></span><br><span class="line">        <span class="keyword">case</span> WEST : <span class="keyword">return</span> cell - LABY_MAX; <span class="comment">// 向西</span></span><br><span class="line">        <span class="keyword">case</span> NORTH: <span class="keyword">return</span> cell - <span class="number">1</span>;		<span class="comment">// 向北</span></span><br><span class="line">    	<span class="keyword">default</span>   : <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">inline</span> Cell* <span class="title">advance</span><span class="params">(Cell* cell)</span> </span>&#123;</span><br><span class="line">    Cell* next;</span><br><span class="line">    <span class="keyword">switch</span>(cell-&gt;outgoing) &#123;</span><br><span class="line">        <span class="keyword">case</span> EAST : next = cell + LABY_MAX;	<span class="comment">// 向东</span></span><br><span class="line">            next-&gt;incoming = WEST; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SOUTH: next = cell + <span class="number">1</span>;		<span class="comment">// 向南</span></span><br><span class="line">            next-&gt;incoming = NORTH; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> WEST : next = cell - LABY_MAX; <span class="comment">// 向西</span></span><br><span class="line">            next-&gt;incoming = EAST; <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> NORTH: next = cell - <span class="number">1</span>;		<span class="comment">// 向北</span></span><br><span class="line">            next-&gt;incoming = SOUTH; <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">labyrinth</span><span class="params">(Cell Laby[LABY_MAX][LABY_MAX],Cell* s,Cell* t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((AVALIABLE != s-&gt;status) || (AVALIABLE != t-&gt;status))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;Cell*&gt; path;	<span class="comment">// 用栈记录通路</span></span><br><span class="line">    s-&gt;incoming = UNKNOWN; s-&gt;status = ROUTE; path.push(s);</span><br><span class="line">    <span class="keyword">do</span> &#123;	<span class="comment">// 从起点出发不断试探、回溯，直到抵达终点</span></span><br><span class="line">        Cell* c = path.top();</span><br><span class="line">        <span class="keyword">if</span>( c == t) <span class="keyword">return</span> <span class="literal">true</span>;		<span class="comment">// 抵达终点</span></span><br><span class="line">        <span class="keyword">while</span>(NO_WAY &gt; (c-&gt;outgoing = nextESWN(c-&gt;outgoing)))</span><br><span class="line">            <span class="keyword">if</span>(AVAILABLE == nerghbor(c)-&gt;status)</span><br><span class="line">                <span class="keyword">break</span>;				<span class="comment">// 试图找到尚未试探的方向</span></span><br><span class="line">        <span class="keyword">if</span>(NO_WAY &lt;= c-&gt;outgoing) &#123;	<span class="comment">// 若所有方向都已尝试过</span></span><br><span class="line">            c-&gt;status = BACKTRACKED;<span class="comment">// 向后回溯一步</span></span><br><span class="line">            c = path.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;						<span class="comment">// 否则，向前试探一步</span></span><br><span class="line">            path.push(c = advance(c));</span><br><span class="line">            c-&gt;outgoing = UNKNOWN;</span><br><span class="line">            c-&gt;status = ROUTE;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; <span class="keyword">while</span>(!path.empty());</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>5 EL 表达式 JSTL 标签库</title>
    <url>/2021/09/05/JAVA%20EE/EL&amp;JSTL/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="el-表达式-jstl-标签库"><a class="markdownIt-Anchor" href="#el-表达式-jstl-标签库"></a> EL 表达式 &amp; JSTL 标签库</h2>
<h3 id="1-el-表达式"><a class="markdownIt-Anchor" href="#1-el-表达式"></a> 1. EL 表达式</h3>
<a id="more"></a>
<p>EL 表达式的全称是：Expression Language。是表达式语言。</p>
<p>EL 表达式的什么作用：EL 表达式主要是代替jsp 页面中的表达式脚本在jsp 页面中进行数据的输出。因为EL 表达式在输出数据的时候，要比jsp 的表达式脚本要简洁很多。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    request.setAttribute(<span class="string">"key"</span>,<span class="string">"值"</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    表达式脚本输出key 的值是：</span><br><span class="line"> &lt;%=request.getAttribute(<span class="string">"key1"</span>)==<span class="keyword">null</span>?<span class="string">""</span>:request.getAttribute(<span class="string">"key1"</span>)%&gt;&lt;br/&gt;</span><br><span class="line">    EL 表达式输出key 的值是：$&#123;key1&#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>EL 表达式的格式是：${表达式}<br />
EL 表达式在输出null 值的时候，输出的是空串。jsp 表达式脚本输出null 值的时候，输出的是null 字符串。</p>
<h4 id="11-el-表达式搜索域数据的顺序"><a class="markdownIt-Anchor" href="#11-el-表达式搜索域数据的顺序"></a> 1.1 EL 表达式搜索域数据的顺序</h4>
<p>EL 表达式主要是在jsp 页面中输出数据。<br />
主要是输出域对象中的数据。</p>
<p>当四个域中都有相同的key 的数据的时候，EL 表达式会按照四个域的从小到大的顺序去进行搜索，找到就输出。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">    <span class="comment">//往四个域中都保存了相同的key 的数据。</span></span><br><span class="line">    request.setAttribute(<span class="string">"key"</span>, <span class="string">"request"</span>);</span><br><span class="line">    session.setAttribute(<span class="string">"key"</span>, <span class="string">"session"</span>);</span><br><span class="line">    application.setAttribute(<span class="string">"key"</span>, <span class="string">"application"</span>);</span><br><span class="line">    pageContext.setAttribute(<span class="string">"key"</span>, <span class="string">"pageContext"</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; key &#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="12-el-表达式输出类的属性"><a class="markdownIt-Anchor" href="#12-el-表达式输出类的属性"></a> 1.2 EL 表达式输出类的属性</h4>
<p>​	EL会找get方法进行调用</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    输出Person：$&#123; p &#125;&lt;br/&gt;</span><br><span class="line">    输出Person 的name 属性：$&#123;p.name&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的pnones 数组属性值：$&#123;p.phones[<span class="number">2</span>]&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的cities 集合中的元素值：$&#123;p.cities&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的List 集合中个别元素值：$&#123;p.cities[<span class="number">2</span>]&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的Map 集合: $&#123;p.map&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的Map 集合中某个key 的值: $&#123;p.map.key3&#125; &lt;br&gt;</span><br><span class="line">    输出Person 的age 属性：$&#123;p.age&#125; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="13-el-表达式运算"><a class="markdownIt-Anchor" href="#13-el-表达式运算"></a> 1.3 EL 表达式运算</h4>
<p>语法：${ 运算表达式} ， EL 表达式支持如下运算符：</p>
<p><strong>1. 关系运算</strong></p>
<p><img src="https://i.loli.net/2021/09/10/xiX2FQYyhvDg7Ib.png" alt="1.png" /></p>
<p><strong>2. 逻辑运算</strong></p>
<p><img src="https://i.loli.net/2021/09/10/DMxi8g2IXQvfc3E.png" alt="2.png" /></p>
<p><strong>3. 算术运算</strong></p>
<p><img src="https://i.loli.net/2021/09/10/7BxNUJsERF6V3kq.png" alt="3.png" /></p>
<p><strong>4. empty运算</strong></p>
<p>empty 运算可以判断一个数据是否为空，如果为空，则输出true,不为空输出false。</p>
<p>以下几种情况为空：<br />
1、值为null 值的时候，为空<br />
2、值为空串的时候，为空<br />
3、值是Object 类型数组，长度为零的时候<br />
4、list 集合，元素个数为零<br />
5、map 集合，元素个数为零</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        <span class="comment">// 1、值为null 值的时候，为空</span></span><br><span class="line">        request.setAttribute(<span class="string">"emptyNull"</span>, <span class="keyword">null</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; empty emptyNull &#125; &lt;br/&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p><strong>5. “.”点运算和[] 中括号运算符</strong></p>
<p>.点运算，可以输出Bean 对象中某个属性的值。</p>
<p>[]中括号运算，可以输出map 集合中key 里含有特殊字符的key 的值。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">        map.put(<span class="string">"a.a.a"</span>, <span class="string">"aaaValue"</span>);</span><br><span class="line">        request.setAttribute(<span class="string">"map"</span>, map);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; map[<span class="string">'a.a.a'</span>] &#125; &lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="14-el-表达式的11个隐含对象"><a class="markdownIt-Anchor" href="#14-el-表达式的11个隐含对象"></a> 1.4 EL 表达式的11个隐含对象</h4>
<p>EL 个达式中11 个隐含对象，是EL 表达式中自己定义的，可以直接使用。</p>
<p><img src="https://i.loli.net/2021/09/10/2fC3sBOZXVuQtIY.png" alt="4.png" /></p>
<h4 id="141-el-获取四个特定域中的属性"><a class="markdownIt-Anchor" href="#141-el-获取四个特定域中的属性"></a> 1.4.1 EL 获取四个特定域中的属性</h4>
<p><img src="https://i.loli.net/2021/09/10/nNQtc4lSB9dHCJ5.png" alt="5.png" /></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">        pageContext.setAttribute(<span class="string">"key1"</span>, <span class="string">"pageContext1"</span>);</span><br><span class="line">        pageContext.setAttribute(<span class="string">"key2"</span>, <span class="string">"pageContext2"</span>);</span><br><span class="line">        request.setAttribute(<span class="string">"key2"</span>, <span class="string">"request"</span>);</span><br><span class="line">        session.setAttribute(<span class="string">"key2"</span>, <span class="string">"session"</span>);</span><br><span class="line">        application.setAttribute(<span class="string">"key2"</span>, <span class="string">"application"</span>);</span><br><span class="line">    %&gt;</span><br><span class="line">    $&#123; applicationScope.key2 &#125;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="142-pagecontext-对象的使用"><a class="markdownIt-Anchor" href="#142-pagecontext-对象的使用"></a> 1.4.2 pageContext 对象的使用</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%</span><br><span class="line">		pageContext.setAttribute(<span class="string">"req"</span>, request);</span><br><span class="line">	%&gt;</span><br><span class="line">    &lt;%=request.getScheme() %&gt; &lt;br&gt;</span><br><span class="line">    <span class="number">1</span>.协议： $&#123; req.scheme &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">2</span>.服务器ip：$&#123; pageContext.request.serverName &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">3</span>.服务器端口：$&#123; pageContext.request.serverPort &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">4</span>.获取工程路径：$&#123; pageContext.request.contextPath &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">5</span>.获取请求方法：$&#123; pageContext.request.method &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">6</span>.获取客户端ip 地址：$&#123; pageContext.request.remoteHost &#125;&lt;br&gt;</span><br><span class="line">    <span class="number">7</span>.获取会话的id 编号：$&#123; pageContext.session.id &#125;&lt;br&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<h4 id="143-el-表达式其他隐含对象的使用"><a class="markdownIt-Anchor" href="#143-el-表达式其他隐含对象的使用"></a> 1.4.3 EL 表达式其他隐含对象的使用</h4>
<p><strong>param、paramValues</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">输出请求参数username 的值：$&#123; param.username &#125; &lt;br&gt;</span><br><span class="line">输出请求参数password 的值：$&#123; param.password &#125; &lt;br</span><br><span class="line">                                          </span><br><span class="line">输出请求参数username 的值：$&#123; paramValues.username[<span class="number">0</span>]&#125;&lt;br&gt;</span><br><span class="line">输出请求参数hobby 的值：$&#123; paramValues.hobby[<span class="number">0</span>] &#125; &lt;br&gt;</span><br><span class="line">输出请求参数hobby 的值：$&#123; paramValues.hobby[<span class="number">1</span>] &#125; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<p><strong>header、headerValues</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">输出请求头【User-Agent】的值：$&#123; header[<span class="string">'User-Agent'</span>] &#125; &lt;br&gt;</span><br><span class="line">输出请求头【Connection】的值：$&#123; header.Connection &#125; &lt;br&gt;</span><br><span class="line">输出请求头【User-Agent】的值：$&#123; headerValues[<span class="string">'User-Agent'</span>][<span class="number">0</span>] &#125; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<p><strong>cookie</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">获取Cookie 的名称：$&#123; cookie.JSESSIONID.name &#125; &lt;br&gt;</span><br><span class="line">获取Cookie 的值：$&#123; cookie.JSESSIONID.value &#125; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<p><strong>initParam</strong></p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">输出&amp;lt;Context-param&amp;gt;username 的值：$&#123; initParam.username &#125; &lt;br&gt;</span><br><span class="line">输出&amp;lt;Context-param&amp;gt;url 的值：$&#123; initParam.url &#125; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<p>web.xml的配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>url<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>jdbc:mysql:///test<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-jstl-标签库"><a class="markdownIt-Anchor" href="#2-jstl-标签库"></a> 2. JSTL 标签库</h3>
<p>JSTL 标签库全称是指JSP Standard Tag Library JSP 标准标签库。是一个不断完善的开放源代码的JSP 标签库。<br />
EL 表达式主要是为了替换jsp 中的表达式脚本，而标签库则是为了替换代码脚本。这样使得整个jsp 页面变得更佳简洁</p>
<h4 id="21-jstl-介绍"><a class="markdownIt-Anchor" href="#21-jstl-介绍"></a> 2.1 JSTL 介绍</h4>
<p>JSTL由五个不同功能的标签库组成。</p>
<p><img src="https://i.loli.net/2021/09/10/HjJF74Dez9LOUAo.png" alt="6.png" /></p>
<p>在jsp标签库中使用taglib 指令引入标签库</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// CORE 标签库</span></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"c"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/core"</span> %&gt;</span><br><span class="line"><span class="comment">// XML 标签库</span></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"x"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/xml"</span> %&gt;</span><br><span class="line"><span class="comment">// FMT 标签库</span></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"fmt"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/fmt"</span> %&gt;</span><br><span class="line"><span class="comment">// SQL 标签库</span></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"sql"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/sql"</span> %&gt;</span><br><span class="line"><span class="comment">// FUNCTIONS 标签库</span></span><br><span class="line">&lt;%@ taglib prefix=<span class="string">"fn"</span> uri=<span class="string">"http://java.sun.com/jsp/jstl/functions"</span> %&gt;</span><br></pre></td></tr></table></figure>
<h4 id="22-jstl-标签库的使用步骤"><a class="markdownIt-Anchor" href="#22-jstl-标签库的使用步骤"></a> 2.2 JSTL 标签库的使用步骤</h4>
<p>1、先导入jstl 标签库的jar 包。<br />
taglibs-standard-impl-1.2.1.jar<br />
taglibs-standard-spec-1.2.1.jar<br />
2、第二步，使用taglib 指令引入标签库。</p>
<h4 id="23-core-核心库使用"><a class="markdownIt-Anchor" href="#23-core-核心库使用"></a> 2.3 core 核心库使用</h4>
<h4 id="231-cset-使用很少"><a class="markdownIt-Anchor" href="#231-cset-使用很少"></a> 2.3.1 &lt;c:set /&gt;（使用很少）</h4>
<pre><code>作用：set 标签可以往域中保存数据
</code></pre>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">i.&lt;c:set /&gt;</span><br><span class="line">    作用：set 标签可以往域中保存数据</span><br><span class="line">        </span><br><span class="line">    域对象.setAttribute(key,value);</span><br><span class="line">    scope 属性设置保存到哪个域</span><br><span class="line">        page 表示PageContext 域（默认值）</span><br><span class="line">        request 表示Request 域</span><br><span class="line">        session 表示Session 域</span><br><span class="line">        application 表示ServletContext 域</span><br><span class="line">    <span class="keyword">var</span> 属性设置key 是多少</span><br><span class="line">    value 属性设置值</span><br><span class="line">--%&gt;           </span><br><span class="line">保存之前：$&#123; sessionScope.abc &#125; &lt;br&gt;</span><br><span class="line">&lt;c:set scope=<span class="string">"session"</span> <span class="keyword">var</span>=<span class="string">"abc"</span> value=<span class="string">"abcValue"</span>/&gt;</span><br><span class="line">保存之后：$&#123; sessionScope.abc &#125; &lt;br&gt;</span><br></pre></td></tr></table></figure>
<h4 id="232-cif"><a class="markdownIt-Anchor" href="#232-cif"></a> 2.3.2 &lt;c:if /&gt;</h4>
<pre><code>if 标签用来做if 判断。
</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">ii.&lt;c:<span class="keyword">if</span> /&gt;</span><br><span class="line">	<span class="keyword">if</span> 标签用来做<span class="keyword">if</span> 判断。</span><br><span class="line">	test 属性表示判断的条件（使用EL 表达式输出）</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123; 12 == 12 &#125;"</span>&gt;</span><br><span class="line">	&lt;h1&gt;12 等于12&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br><span class="line">&lt;c:<span class="keyword">if</span> test=<span class="string">"$&#123; 12 != 12 &#125;"</span>&gt;</span><br><span class="line">	&lt;h1&gt;12 不等于12&lt;/h1&gt;</span><br><span class="line">&lt;/c:if&gt;</span><br></pre></td></tr></table></figure>
<h4 id="233-cchoosecwhencotherwise标签"><a class="markdownIt-Anchor" href="#233-cchoosecwhencotherwise标签"></a> 2.3.3 &lt;c:choose&gt;&lt;c:when&gt;&lt;c:otherwise&gt;标签</h4>
<pre><code>作用：多路判断。跟switch ... case .... default 非常接近
</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">iii.&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签</span><br><span class="line">	作用：多路判断。跟<span class="keyword">switch</span> ... <span class="keyword">case</span> .... <span class="keyword">default</span> 非常接近</span><br><span class="line">    </span><br><span class="line">	choose 标签开始选择判断</span><br><span class="line">	when 标签表示每一种判断情况</span><br><span class="line">		test 属性表示当前这种判断情况的值</span><br><span class="line">	otherwise 标签表示剩下的情况</span><br><span class="line">    </span><br><span class="line">&lt;c:choose&gt; &lt;c:when&gt; &lt;c:otherwise&gt;标签使用时需要注意的点：</span><br><span class="line">	<span class="number">1</span>、标签里不能使用html 注释，要使用jsp 注释</span><br><span class="line">	<span class="number">2</span>、when 标签的父标签一定要是choose 标签</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	request.setAttribute(<span class="string">"height"</span>, <span class="number">180</span>);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:choose&gt;</span><br><span class="line">    &lt;%-- 这是jsp 注释--%&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123; requestScope.height &gt; 190 &#125;"</span>&gt;</span><br><span class="line">    	&lt;h2&gt;小巨人&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123; requestScope.height &gt; 180 &#125;"</span>&gt;</span><br><span class="line">    	&lt;h2&gt;很高&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:when test=<span class="string">"$&#123; requestScope.height &gt; 170 &#125;"</span>&gt;</span><br><span class="line">    	&lt;h2&gt;还可以&lt;/h2&gt;</span><br><span class="line">    &lt;/c:when&gt;</span><br><span class="line">    &lt;c:otherwise&gt;</span><br><span class="line">        &lt;c:choose&gt;</span><br><span class="line">            &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 160&#125;"</span>&gt;</span><br><span class="line">            	&lt;h3&gt;大于160&lt;/h3&gt;</span><br><span class="line">            &lt;/c:when&gt;</span><br><span class="line">            &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 150&#125;"</span>&gt;</span><br><span class="line">            	&lt;h3&gt;大于150&lt;/h3&gt;</span><br><span class="line">            &lt;/c:when&gt;</span><br><span class="line">            &lt;c:when test=<span class="string">"$&#123;requestScope.height &gt; 140&#125;"</span>&gt;</span><br><span class="line">            	&lt;h3&gt;大于140&lt;/h3&gt;</span><br><span class="line">            &lt;/c:when&gt;</span><br><span class="line">            &lt;c:otherwise&gt;</span><br><span class="line">                其他小于<span class="number">140</span></span><br><span class="line">            &lt;/c:otherwise&gt;</span><br><span class="line">    	&lt;/c:choose&gt;</span><br><span class="line">    &lt;/c:otherwise&gt;</span><br><span class="line">&lt;/c:choose&gt;</span><br></pre></td></tr></table></figure>
<h4 id="234-cforeach"><a class="markdownIt-Anchor" href="#234-cforeach"></a> 2.3.4 &lt;c:forEach /&gt;</h4>
<pre><code>作用：遍历输出使用。
</code></pre>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- <span class="number">1</span>.遍历<span class="number">1</span> 到<span class="number">10</span>，输出</span><br><span class="line">    begin 属性设置开始的索引</span><br><span class="line">    end 属性设置结束的索引</span><br><span class="line">    <span class="keyword">var</span> 属性表示循环的变量(也是当前正在遍历到的数据)</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;table border=<span class="string">"1"</span>&gt;</span><br><span class="line">	&lt;c:forEach begin=<span class="string">"1"</span> end=<span class="string">"10"</span> <span class="keyword">var</span>=<span class="string">"i"</span>&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        	&lt;td&gt;第$&#123;i&#125;行&lt;/td&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;/c:forEach&gt;</span><br><span class="line">&lt;/table&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%-- <span class="number">2</span>.遍历Object 数组</span><br><span class="line">    <span class="keyword">for</span> (Object items : arr)</span><br><span class="line">    items 表示遍历的数据源（遍历的集合）</span><br><span class="line">    <span class="keyword">var</span> 表示当前遍历到的数据</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">	request.setAttribute(<span class="string">"arr"</span>, <span class="keyword">new</span> String[]&#123;<span class="string">"18610541354"</span>,<span class="string">"18688886666"</span>,<span class="string">"18699998888"</span>&#125;);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123; requestScope.arr &#125;"</span> <span class="keyword">var</span>=<span class="string">"item"</span>&gt;</span><br><span class="line">	$&#123; item &#125; &lt;br&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    Map&lt;String,Object&gt; map = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line">    map.put(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">    map.put(<span class="string">"key2"</span>, <span class="string">"value2"</span>);</span><br><span class="line">    map.put(<span class="string">"key3"</span>, <span class="string">"value3"</span>);</span><br><span class="line">    <span class="comment">// for ( Map.Entry&lt;String,Object&gt; entry : map.entrySet()) &#123;</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    request.setAttribute(<span class="string">"map"</span>, map);</span><br><span class="line">%&gt;</span><br><span class="line">&lt;c:forEach items=<span class="string">"$&#123; requestScope.map &#125;"</span> <span class="keyword">var</span>=<span class="string">"entry"</span>&gt;</span><br><span class="line">	&lt;h1&gt;$&#123;entry.key&#125; = $&#123;entry.value&#125;&lt;/h1&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
<p><strong>foreach标签所有属性</strong></p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;%--</span><br><span class="line">    items 表示遍历的集合</span><br><span class="line">    <span class="keyword">var</span> 表示遍历到的数据</span><br><span class="line">    begin 表示遍历的开始索引值</span><br><span class="line">    end 表示结束的索引值</span><br><span class="line">    step 属性表示遍历的步长值</span><br><span class="line">    varStatus 属性表示当前遍历到的数据的状态</span><br><span class="line">    <span class="keyword">for</span>（<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">10</span>; i+=<span class="number">2</span>）</span><br><span class="line">--%&gt;</span><br><span class="line">&lt;c:forEach begin=<span class="string">"2"</span> end=<span class="string">"7"</span> step=<span class="string">"2"</span> varStatus=<span class="string">"status"</span> items=<span class="string">"$&#123;requestScope.stus&#125;"</span> <span class="keyword">var</span>=<span class="string">"stu"</span>&gt;</span><br><span class="line">    &lt;tr&gt;</span><br><span class="line">        &lt;td&gt;$&#123;stu.id&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;stu.username&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;stu.password&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;stu.age&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;stu.phone&#125;&lt;/td&gt;</span><br><span class="line">        &lt;td&gt;$&#123;status.step&#125;&lt;/td&gt;</span><br><span class="line">    &lt;/tr&gt;</span><br><span class="line">&lt;/c:forEach&gt;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
  </entry>
  <entry>
    <title>3 Servlet</title>
    <url>/2021/09/03/JAVA%20EE/Servlet/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="servlet"><a class="markdownIt-Anchor" href="#servlet"></a> Servlet</h2>
<h3 id="1-servlet配置"><a class="markdownIt-Anchor" href="#1-servlet配置"></a> 1. Servlet配置</h3>
<a id="more"></a>
<p><strong>web.xml中的配置</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag"><span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee</span></span></span><br><span class="line"><span class="tag"><span class="string">http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd"</span></span></span><br><span class="line"><span class="tag"><span class="attr">version</span>=<span class="string">"4.0"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- servlet 标签给Tomcat 配置Servlet 程序--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签Servlet 程序起一个别名（一般是类名） --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-class 是Servlet 程序的全类名--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>com.atguigu.servlet.HelloServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-mapping 标签给servlet 程序配置访问地址--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--servlet-name 标签的作用是告诉服务器，我当前配置的地址给哪个Servlet 程序使用--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>HelloServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--url-pattern 标签配置访问地址</span></span><br><span class="line"><span class="comment">/ 斜杠在服务器解析的时候，表示地址为：http://ip:port/工程路径</span></span><br><span class="line"><span class="comment">/hello 表示地址为：http://ip:port/工程路径/hello </span></span><br><span class="line"><span class="comment">--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/hello<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>从Servlet3.0开始，配置Servlet支持注解方式</strong></p>
<p>@WebServlet注解用于标注在一个继承了HttpServlet类之上，属于类级别的注解。</p>
<p><img src="https://img2018.cnblogs.com/i-beta/1913588/202001/1913588-20200103165022431-1582263216.png" alt="img" /></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@WebServlet(name &#x3D; &quot;helloServlet&quot;, value &#x3D; &quot;&#x2F;hello-servlet&quot;)</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/09/10/qnEHNAzlDR6wQji.png" alt="1.png" /></p>
<h3 id="2-servlet的生命周期"><a class="markdownIt-Anchor" href="#2-servlet的生命周期"></a> 2. Servlet的生命周期</h3>
<ol>
<li>执行Servlet 构造器方法</li>
<li>执行init 初始化方法</li>
<li>执行service 方法</li>
<li>执行destroy 销毁方法</li>
</ol>
<ul>
<li>
<p>第一、二步，是在第一次访问，的时候创建Servlet 程序会调用。</p>
</li>
<li>
<p>第三步，每次访问都会调用。</p>
</li>
<li>
<p>第四步，在web 工程停止的时候调用。</p>
</li>
</ul>
<h3 id="3-get和post请求的处理"><a class="markdownIt-Anchor" href="#3-get和post请求的处理"></a> 3. GET和POST请求的处理</h3>
<p><strong>1. 将servletRequest转换成HttpServletRequest并处理</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet</span> <span class="keyword">implements</span> <span class="title">Servlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">service</span><span class="params">(ServletRequest servletRequest, ServletResponse servletResponse)</span> <span class="keyword">throws</span></span></span><br><span class="line"><span class="function">    ServletException, IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"3 service === Hello Servlet 被访问了"</span>);</span><br><span class="line">        <span class="comment">// 类型转换（因为它有getMethod()方法）</span></span><br><span class="line">        HttpServletRequest httpServletRequest = (HttpServletRequest) servletRequest;</span><br><span class="line">        <span class="comment">// 获取请求的方式</span></span><br><span class="line">        String method = httpServletRequest.getMethod();</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"GET"</span>.equals(method)) &#123;</span><br><span class="line">        doGet();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"POST"</span>.equals(method)) &#123;</span><br><span class="line">        doPost();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2. 通过继承HttpServlet类实现Servlet程序</strong><br />
一般在实际项目开发中，都是使用继承HttpServlet 类的方式去实现Servlet 程序。<br />
1、编写一个类去继承HttpServlet 类<br />
2、根据业务需要重写doGet 或doPost 方法<br />
3、到web.xml 中的配置Servlet 程序的访问地址</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloServlet2</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">    IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloServlet2 的doGet 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">    IOException </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"HelloServlet2 的doPost 方法"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-servlet类的继承体系"><a class="markdownIt-Anchor" href="#4-servlet类的继承体系"></a> 4. Servlet类的继承体系</h3>
<p><img src="https://i.loli.net/2021/09/10/sXMGemVBli72vKH.png" alt="2.png" /></p>
<h3 id="5-servletconfig类"><a class="markdownIt-Anchor" href="#5-servletconfig类"></a> 5. ServletConfig类</h3>
<p>Servlet 程序和ServletConfig 对象都是由Tomcat 负责创建，我们负责使用。<br />
Servlet 程序默认是第一次访问的时候创建，ServletConfig 是每个Servlet 程序创建时，就创建一个对应的ServletConfig 对象。</p>
<h4 id="51-servletconfig类的三大作用"><a class="markdownIt-Anchor" href="#51-servletconfig类的三大作用"></a> 5.1 ServletConfig类的三大作用</h4>
<p>1、可以获取Servlet 程序的别名servlet-name 的值<br />
2、获取初始化参数init-param<br />
3、获取ServletContext 对象</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是参数名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--是参数值--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、可以获取Servlet 程序的别名servlet-name 的值</span></span><br><span class="line">System.out.println(<span class="string">"HelloServlet 程序的别名是:"</span> + servletConfig.getServletName());</span><br><span class="line"><span class="comment">// 2、获取初始化参数init-param</span></span><br><span class="line">System.out.println(<span class="string">"初始化参数username 的值是;"</span> + servletConfig.getInitParameter(<span class="string">"username"</span>));</span><br><span class="line">System.out.println(<span class="string">"初始化参数url 的值是;"</span> + servletConfig.getInitParameter(<span class="string">"url"</span>));</span><br><span class="line"><span class="comment">// 3、获取ServletContext 对象</span></span><br><span class="line">System.out.println(servletConfig.getServletContext());</span><br></pre></td></tr></table></figure>
<h3 id="6-servletcontext-类"><a class="markdownIt-Anchor" href="#6-servletcontext-类"></a> 6. ServletContext 类</h3>
<p>1、ServletContext 是一个接口，它表示Servlet 上下文对象<br />
2、一个web 工程，只有一个ServletContext 对象实例。<br />
3、ServletContext 对象是一个域对象。<br />
4、ServletContext 是在web 工程部署启动的时候创建。在web 工程停止的时候销毁。</p>
<h4 id="61-servletcontext-类的四个作用"><a class="markdownIt-Anchor" href="#61-servletcontext-类的四个作用"></a> 6.1 ServletContext 类的四个作用</h4>
<p>1、获取web.xml 中配置的上下文参数context-param<br />
2、获取当前的工程路径，格式: /工程路径<br />
3、获取工程部署后在服务器硬盘上的绝对路径<br />
4、像Map 一样存取数据</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>username<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>context<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--context-param 是上下文参数(它属于整个web 工程)--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>password<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>root<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1、获取web.xml 中配置的上下文参数context-param</span></span><br><span class="line">ServletContext context = getServletConfig().getServletContext();</span><br><span class="line">String username = context.getInitParameter(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2、获取当前的工程路径，格式: /工程路径</span></span><br><span class="line">System.out.println( <span class="string">"当前工程路径:"</span> + context.getContextPath() );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3、获取工程部署后在服务器硬盘上的绝对路径</span></span><br><span class="line">System.out.println(<span class="string">"工程部署的路径是:"</span> + context.getRealPath(<span class="string">"/"</span>));</span><br><span class="line">System.out.println(<span class="string">"工程下css 目录的绝对路径是:"</span> + context.getRealPath(<span class="string">"/css"</span>));</span><br><span class="line">System.out.println(<span class="string">"工程下imgs 目录1.jpg 的绝对路径是:"</span> + context.getRealPath(<span class="string">"/imgs/1.jpg"</span>));</span><br></pre></td></tr></table></figure>
<h4 id="62-servletcontext-像map-一样存取数据"><a class="markdownIt-Anchor" href="#62-servletcontext-像map-一样存取数据"></a> 6.2 ServletContext 像Map 一样存取数据</h4>
<p>可以在两个Servlet间传递数据</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Servlet1</span></span><br><span class="line"><span class="comment">// 获取ServletContext 对象</span></span><br><span class="line">ServletContext context = getServletContext();</span><br><span class="line">context.setAttribute(<span class="string">"key1"</span>, <span class="string">"value1"</span>);</span><br><span class="line">System.out.println(<span class="string">"Context1 中获取域数据key1 的值是:"</span>+ context.getAttribute(<span class="string">"key1"</span>));</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Servlet2</span></span><br><span class="line">ServletContext context = getServletContext();</span><br><span class="line">System.out.println(<span class="string">"Context2 中获取域数据key1 的值是:"</span>+ context.getAttribute(<span class="string">"key1"</span>));</span><br></pre></td></tr></table></figure>
<h3 id="7-http-协议"><a class="markdownIt-Anchor" href="#7-http-协议"></a> 7. HTTP 协议</h3>
<h4 id="71-get请求"><a class="markdownIt-Anchor" href="#71-get请求"></a> 7.1 GET请求</h4>
<p><strong>请求行</strong></p>
<p>(1) 请求的方式GET<br />
(2) 请求的资源路径[+?+请求参数]<br />
(3) 请求的协议的版本号HTTP/1.1</p>
<p><strong>请求头</strong></p>
<p>key : value 组成不同的键值对，表示不同的含义。</p>
<p><img src="https://i.loli.net/2021/09/10/vJIQiENUH74SmyR.png" alt="3.png" /></p>
<h4 id="72-post请求"><a class="markdownIt-Anchor" href="#72-post请求"></a> 7.2 POST请求</h4>
<p><strong>请求行</strong></p>
<p>(1) 请求的方式GET<br />
(2) 请求的资源路径[+?+请求参数]<br />
(3) 请求的协议的版本号HTTP/1.1</p>
<p><strong>请求头</strong></p>
<ol>
<li>key : value 不同的请求头，有不同的含义<br />
空行</li>
</ol>
<ul>
<li>常用请求头的说明
<ul>
<li>Accept: 表示客户端可以接收的数据类型</li>
<li>Accpet-Languege: 表示客户端可以接收的语言类型</li>
<li>User-Agent: 表示客户端浏览器的信息</li>
<li>Host： 表示请求时的服务器ip 和端口号</li>
</ul>
</li>
</ul>
<p><strong>请求体</strong></p>
<p>​	发送给服务器的数据</p>
<p><img src="https://i.loli.net/2021/09/10/W89cSpw1yNVnhmM.png" alt="4.png" /></p>
<h4 id="73-get请求和post请求的方式"><a class="markdownIt-Anchor" href="#73-get请求和post请求的方式"></a> 7.3 GET请求和POST请求的方式</h4>
<p><strong>GET请求</strong></p>
<p>1、form 标签method=get<br />
2、a 标签<br />
3、link 标签引入css<br />
4、Script 标签引入js 文件<br />
5、img 标签引入图片<br />
6、iframe 引入html 页面<br />
7、在浏览器地址栏中输入地址后敲回车</p>
<p><strong>POST请求</strong></p>
<p>8、form 标签method=post</p>
<h4 id="74-get-和-post的区别"><a class="markdownIt-Anchor" href="#74-get-和-post的区别"></a> 7.4 Get 和 Post的区别</h4>
<p>1、Get 是用来从服务器上获得数据，而 Post 是用来向服务器上传递数据。</p>
<p>2、Get 将表单中数据的按照 variable=value 的形式，添加到 action 所指向的 URL 后面，并且两者使用“?”连接，而各个变量之间使用“&amp;”连接；Post 是将表单中的数据放在 form 的数据体中，按照变量和值相对应的方式，传递到 action 所指向 URL。</p>
<p>3、Get 是不安全的，因为在传输过程，数据被放在请求的 URL 中，而如今现有的很多服务器、代理服务器或者用户代理都会将请求URL记录到日志文件中，然后放在某个地方，这样就可能会有一些隐私的信息被第三方看到。另外，用户也可以在浏览器上直接看到提交的数据，一些系统内部消息将会一同显示在用户面前。Post 的所有操作对用户来说都是不可见的。</p>
<p>4、Get 传输的数据量小，这主要是因为受 URL 长度限制；而 Post 可以传输大量的数据，所以在上传文件只能使用 Post（当然还有一个原因，将在后面的提到）。</p>
<p>5、Get 限制 Form 表单的数据集的值必须为 ASCII 字符；而 Post 支持整个 ISO10646 字符集。</p>
<p>6、Get 是 Form 的默认方法。</p>
<h4 id="75-响应的http协议格式"><a class="markdownIt-Anchor" href="#75-响应的http协议格式"></a> 7.5 响应的HTTP协议格式</h4>
<p><strong>响应行</strong></p>
<p>(1) 响应的协议和版本号<br />
(2) 响应状态码<br />
(3) 响应状态描述符</p>
<p><strong>响应头</strong></p>
<p>(1) key : value 不同的响应头，有其不同含义<br />
空行</p>
<p><strong>响应体</strong></p>
<p>​	是回传给客户端的数据</p>
<p><img src="https://i.loli.net/2021/09/10/PCEh8pByo5agbDW.png" alt="5.png" /></p>
<h4 id="751-常用的响应码"><a class="markdownIt-Anchor" href="#751-常用的响应码"></a> 7.5.1 常用的响应码</h4>
<p>200 	表示请求成功<br />
302 	表示请求重定向<br />
404 	表示请求服务器已经收到了，但是你要的数据不存在（请求地址错误）<br />
500 	表示服务器已经收到请求，但是服务器内部错误（代码错误）</p>
<h3 id="8-httpservletrequest-类"><a class="markdownIt-Anchor" href="#8-httpservletrequest-类"></a> 8. HttpServletRequest 类</h3>
<p>每次只要有请求进入Tomcat 服务器，Tomcat 服务器就会把请求过来的HTTP 协议信息解析好封装到Request 对象中。然后传递到service 方法（doGet 和doPost）中给我们使用。我们可以通过HttpServletRequest 对象，获取到所有请求的信息。</p>
<h4 id="81-httpservletrequest-类常用方法"><a class="markdownIt-Anchor" href="#81-httpservletrequest-类常用方法"></a> 8.1 HttpServletRequest 类常用方法</h4>
<p><img src="https://i.loli.net/2021/09/10/GzduneiY7jEQ2cp.png" alt="6.png" /></p>
<p><strong>request.setAttribute()</strong></p>
<p>有效范围是一个请求范围，不发送请求的界面无法获取到value的值，jsp界面获取使用EL表达式${num}；<br />
只能在一个request内有效，如果重定向客户端，将取不到值。</p>
<p>request在当次的请求的URL之间有效，比如，你在请求某个servlet，那么你提交的信息，可以使用request.getAttribute()方式获得，而当你再次跳转之后，这些信息将不存在。</p>
<p><strong>request.getSession().setAttribute(“num”,value)；</strong></p>
<p>有效范围是一个session周期，在session过期之前或者用户关闭页面之前是有效的，jsp界面获取使用EL表达式${num}；</p>
<p>可以通过sessionID得到自己的session，将参数存储在session中，即使重定向客户端也没事，这个值可以在多个页面上使用。</p>
<p>比如访问一个网站，登录后用户信息被保存到session中，在session过期之前或者用户关闭页面之前，用户信息可以通过request.getSession().getAttribute()方式获得。</p>
<h4 id="82-获取请求参数"><a class="markdownIt-Anchor" href="#82-获取请求参数"></a> 8.2 获取请求参数</h4>
<p>表单</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;form action=<span class="string">"http://localhost:8080/07_servlet/parameterServlet"</span> method=<span class="string">"get"</span>&gt;</span><br><span class="line">        用户名：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br/&gt;</span><br><span class="line">        密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br/&gt;</span><br><span class="line">        兴趣爱好：&lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"cpp"</span>&gt;C++</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"java"</span>&gt;Java</span><br><span class="line">        &lt;input type=<span class="string">"checkbox"</span> name=<span class="string">"hobby"</span> value=<span class="string">"js"</span>&gt;JavaScript&lt;br/&gt;</span><br><span class="line">        &lt;input type=<span class="string">"submit"</span>&gt;</span><br><span class="line">    &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ParameterServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="keyword">throws</span> ServletException,</span></span><br><span class="line"><span class="function">    IOException </span>&#123;</span><br><span class="line">        <span class="comment">// 防止中文乱码</span></span><br><span class="line">     	response.setContentType(<span class="string">"text/html; charset=utf-8"</span>);   </span><br><span class="line">        </span><br><span class="line">    <span class="comment">// 获取请求参数</span></span><br><span class="line">        String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        String[] hobby = req.getParameterValues(<span class="string">"hobby"</span>);</span><br><span class="line">        </span><br><span class="line">        System.out.println(<span class="string">"用户名："</span> + username);</span><br><span class="line">        System.out.println(<span class="string">"密码："</span> + password);</span><br><span class="line">        System.out.println(<span class="string">"兴趣爱好："</span> + Arrays.asList(hobby));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="83-乱码问题"><a class="markdownIt-Anchor" href="#83-乱码问题"></a> 8.3 乱码问题</h4>
<p><strong>doGet 请求的中文乱码解决</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取请求参数</span></span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//1 先以iso8859-1 进行编码</span></span><br><span class="line"><span class="comment">//2 再以utf-8 进行解码</span></span><br><span class="line">username = <span class="keyword">new</span> String(username.getBytes(<span class="string">"iso-8859-1"</span>), <span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>POST 请求的中文乱码解决</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置请求体的字符集为UTF-8，从而解决post 请求的中文乱码问题</span></span><br><span class="line">req.setCharacterEncoding(<span class="string">"UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="9-请求转发"><a class="markdownIt-Anchor" href="#9-请求转发"></a> 9. 请求转发</h3>
<p>请求转发 是指服务器收到请求后，从一次资源跳转到另一个资源的操作。</p>
<p><img src="https://i.loli.net/2021/09/10/y73DuIRfL8mFM9K.png" alt="7.png" /></p>
<p>Servlet1代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">System.out.println(<span class="string">"在Servlet1（柜台1）中查看参数（材料）："</span> + username);</span><br><span class="line"><span class="comment">// 给材料盖一个章，并传递到Servlet2（柜台2）去查看</span></span><br><span class="line">req.setAttribute(<span class="string">"key1"</span>,<span class="string">"柜台1 的章"</span>);</span><br><span class="line"><span class="comment">// 问路：Servlet2（柜台2）怎么走</span></span><br><span class="line"><span class="comment">/*** 请求转发必须要以斜杠打头，/ 斜杠表示地址为：http://ip:port/工程名/ , 映射到IDEA 代码的web 目录**/</span></span><br><span class="line">RequestDispatcher requestDispatcher = req.getRequestDispatcher(<span class="string">"/servlet2"</span>);</span><br><span class="line"><span class="comment">// RequestDispatcher requestDispatcher = req.getRequestDispatcher("http://www.baidu.com");</span></span><br><span class="line"><span class="comment">// 走向Sevlet2（柜台2）</span></span><br><span class="line">requestDispatcher.forward(req,resp);</span><br></pre></td></tr></table></figure>
<p>Servlet2代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 获取请求的参数（办事的材料）查看</span></span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">System.out.println(<span class="string">"在Servlet2（柜台2）中查看参数（材料）："</span> + username);</span><br><span class="line"><span class="comment">// 查看柜台1 是否有盖章</span></span><br><span class="line">Object key1 = req.getAttribute(<span class="string">"key1"</span>);</span><br><span class="line">System.out.println(<span class="string">"柜台1 是否有章："</span> + key1);</span><br><span class="line"><span class="comment">// 处理自己的业务</span></span><br><span class="line">System.out.println(<span class="string">"Servlet2 处理自己的业务"</span>);</span><br></pre></td></tr></table></figure>
<p><strong>base标签</strong></p>
<p><img src="https://i.loli.net/2021/09/10/iHQR4qzOXCB5dM6.png" alt="8.png" /></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--base 标签设置页面相对路径工作时参照的地址 href 属性就是参数的地址值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">"http://localhost:8080/07_servlet/a/b/"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="10-的意义"><a class="markdownIt-Anchor" href="#10-的意义"></a> 10. / 的意义</h3>
<p>在web 中/ 斜杠是一种绝对路径。</p>
<p>/ 斜杠如果被浏览器解析，得到的地址是：<a href="http://ip" target="_blank" rel="noopener">http://ip</a>:port/</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/"</span>&gt;</span>斜杠<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>/ 斜杠如果被服务器解析，得到的地址是：<a href="http://ip" target="_blank" rel="noopener">http://ip</a>:port/工程路径</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span>、servletContext.getRealPath(“/”);</span><br><span class="line"><span class="number">2</span>、request.getRequestDispatcher(“/”);</span><br></pre></td></tr></table></figure>
<p>特殊情况</p>
<p>把斜杠发给浏览器解析，得到<a href="http://ip" target="_blank" rel="noopener">http://ip</a>:port/</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">response.sendRedirect(<span class="string">"/"</span>)</span><br></pre></td></tr></table></figure>
<h3 id="11-httpservletresponse-类"><a class="markdownIt-Anchor" href="#11-httpservletresponse-类"></a> 11. HttpServletResponse 类</h3>
<p>HttpServletResponse 类和HttpServletRequest 类一样。每次请求进来，Tomcat 服务器都会创建一个Response 对象传递给Servlet 程序去使用。HttpServletRequest 表示请求过来的信息，HttpServletResponse 表示所有响应的信息，我们如果需要设置返回给客户端的信息，都可以通过HttpServletResponse 对象来进行设置</p>
<h4 id="111-两个输出流"><a class="markdownIt-Anchor" href="#111-两个输出流"></a> 11.1 两个输出流</h4>
<p><img src="https://i.loli.net/2021/09/10/UruGaK384NPDJsb.png" alt="9.png" /></p>
<p>两个流同时只能使用一个</p>
<h4 id="112-向客户端回传数据"><a class="markdownIt-Anchor" href="#112-向客户端回传数据"></a> 11.2 向客户端回传数据</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">PrintWriter writer = resp.getWriter();</span><br><span class="line">writer.write(<span class="string">"response's content!!!"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="113-解决响应中文乱码"><a class="markdownIt-Anchor" href="#113-解决响应中文乱码"></a> 11.3 解决响应中文乱码</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 它会同时设置服务器和客户端都使用UTF-8 字符集，还设置了响应头</span></span><br><span class="line"><span class="comment">// 此方法一定要在获取流对象之前调用才有效</span></span><br><span class="line">resp.setContentType(<span class="string">"text/html; charset=UTF-8"</span>);</span><br></pre></td></tr></table></figure>
<h3 id="12-请求重定向"><a class="markdownIt-Anchor" href="#12-请求重定向"></a> 12. 请求重定向</h3>
<p>请求重定向，是指客户端给服务器发请求，然后服务器告诉客户端说。我给你一些地址。你去新地址访问。叫请求重定向（因为之前的地址可能已经被废弃）。</p>
<p><img src="https://i.loli.net/2021/09/10/eOliZKmQuk5HJpt.png" alt="10.png" /></p>
<h4 id="121-第一种方案"><a class="markdownIt-Anchor" href="#121-第一种方案"></a> 12.1 第一种方案</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 设置响应状态码302 ，表示重定向，（已搬迁）</span></span><br><span class="line">resp.setStatus(<span class="number">302</span>);</span><br><span class="line"><span class="comment">// 设置响应头，说明新的地址在哪里</span></span><br><span class="line">resp.setHeader(<span class="string">"Location"</span>, <span class="string">"http://localhost:8080"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="122-第二种方案推荐"><a class="markdownIt-Anchor" href="#122-第二种方案推荐"></a> 12.2 第二种方案（推荐）</h4>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">resp.sendRedirect(<span class="string">"http://localhost:8080"</span>);</span><br></pre></td></tr></table></figure>
<h4 id="123-转发和重定向的区别"><a class="markdownIt-Anchor" href="#123-转发和重定向的区别"></a> 12.3 转发和重定向的区别</h4>
<p>1）使用相对路径在重定向和转发中没有区别<br />
2）重定向和请求转发使用绝对路径时，根/路径代表了不同含义<br />
<strong>重定向</strong>response.sendRedirect(“xxx”)是服务器向客户端发送一个请求头信息，由客户端再请求一次服务器。/指的Tomcat的根目录,写绝对路径应该写成&quot;/当前Web程序根名称/资源名&quot; 。如&quot;/WebModule/login.jsp&quot;,“/bbs/servlet/LoginServlet”</p>
<p><strong>转发</strong>是在服务器内部进行的，写绝对路径/开头指的是当前的Web应用程序。绝对路径写法就是&quot;/login.jsp&quot;或&quot;/servlet/LoginServlet&quot;。</p>
<p><strong>总结</strong>：以上要注意是区分是从服务器外的请求，还在是内部转发，从服务器外的请求，从Tomcat根写起(就是要包括当前Web的根)；是服务器内部的转发，很简单了，因为在当前服务器内，/写起指的就是当前Web的根目录。</p>
<p><strong>注意</strong></p>
<p>假如一开始访问到的是<a href="http://localhost:8080/myProject/index.html" target="_blank" rel="noopener">http://localhost:8080/myProject/index.html</a> , 然后该页面通过GET请求访问到对应的Servlet, 此时重定向的相对路径不是相对于Servlet而言的，而是相对于原先请求路径而言（或者说相对于用户浏览器上面显示的页面地址而言），即相对于：<br />
<a href="http://localhost:8080/myProject/index.html" target="_blank" rel="noopener">http://localhost:8080/myProject/index.html</a> 而言。</p>
]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
  </entry>
  <entry>
    <title>1 Java EE</title>
    <url>/2021/09/01/JAVA%20EE/Java%20EE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="java-ee"><a class="markdownIt-Anchor" href="#java-ee"></a> Java EE</h2>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/09/10/tEQTmnpUJKaDdl3.png" alt="1.png" /></p>
<p><img src="https://i.loli.net/2021/09/10/eDuJ26NmzLh9nxs.png" alt="2.png" /></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String sql = <span class="string">"select"</span></span><br></pre></td></tr></table></figure>
<h3 id="1-路径"><a class="markdownIt-Anchor" href="#1-路径"></a> 1. 路径</h3>
<p>获取绝对路径路径 ,开发项目一定要使用绝对路径，不然肯定出错</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">"://"</span>+request.getServerName()+<span class="string">":"</span>+request.getServerPort()+path+<span class="string">"/"</span>;</span><br><span class="line">&lt;base href=<span class="string">"&lt;%=basePath%&gt;"</span>&gt;</span><br></pre></td></tr></table></figure>
<p>request.getSchema()可以返回当前页面使用的协议，http 或是 https;</p>
<p>request.getServerName()可以返回当前页面所在的服务器的名字;</p>
<p>request.getServerPort()可以返回当前页面所在的服务器使用的端口,就是80;</p>
<p>request.getContextPath()可以返回当前页面所在的应用的名字;</p>
<h3 id="2-debug"><a class="markdownIt-Anchor" href="#2-debug"></a> 2. Debug</h3>
<h4 id="21-测试工具栏"><a class="markdownIt-Anchor" href="#21-测试工具栏"></a> 2.1 测试工具栏</h4>
<p><img src="https://i.loli.net/2021/09/10/ED6S4duG1hqfY3z.png" alt="3.png" /></p>
<p><img src="https://i.loli.net/2021/09/10/akT3cIZNnMvhREU.png" alt="4.png" /></p>
<p><img src="https://i.loli.net/2021/09/10/XyuBN7SPYi153Ap.png" alt="5.png" /></p>
<h4 id="22-方法栈调用窗口"><a class="markdownIt-Anchor" href="#22-方法栈调用窗口"></a> 2.2 方法栈调用窗口</h4>
<p>1、方法调用栈可以查看当前线程有哪些方法调用信息<br />
2、下面的调用上一行的方法</p>
<p><img src="https://i.loli.net/2021/09/10/EoCUDlFtVLHQW1d.png" alt="6.png" /></p>
<h3 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h3>
<ul>
<li>
<p>ctrl + shift + T：新建测试</p>
</li>
<li>
<p>ctrl + alt + T：try + catch</p>
</li>
<li>
<p>ctrl + p：查看函数需要的参数</p>
</li>
<li>
<p>ctrl + alt + shift + L：格式化代码</p>
</li>
<li>
<p>ctrl + shift + / ：多行注释</p>
</li>
</ul>
]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
  </entry>
  <entry>
    <title>4 xml</title>
    <url>/2021/09/04/JAVA%20EE/xml/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="xml"><a class="markdownIt-Anchor" href="#xml"></a> xml</h2>
<h3 id="1-xml语法"><a class="markdownIt-Anchor" href="#1-xml语法"></a> 1. xml语法</h3>
<a id="more"></a>
<p>自己去菜鸟看去</p>
<p><strong>例子</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- xml 声明version 是版本的意思encoding 是编码--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">books</span>&gt;</span> <span class="comment">&lt;!-- 这是xml 注释--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"SN123123413241"</span>&gt;</span> <span class="comment">&lt;!-- book 标签描述一本图书id 属性描述的是图书的编号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>java 编程思想<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- name 标签描述的是图书的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>华仔<span class="tag">&lt;/<span class="name">author</span>&gt;</span> <span class="comment">&lt;!-- author 单词是作者的意思，描述图书作者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>9.9<span class="tag">&lt;/<span class="name">price</span>&gt;</span> <span class="comment">&lt;!-- price 单词是价格，描述的是图书的价格--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">book</span> <span class="attr">id</span>=<span class="string">"SN12341235123"</span>&gt;</span> <span class="comment">&lt;!-- book 标签描述一本图书id 属性描述的是图书的编号--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>葵花宝典<span class="tag">&lt;/<span class="name">name</span>&gt;</span> <span class="comment">&lt;!-- name 标签描述的是图书的信息--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">author</span>&gt;</span>班长<span class="tag">&lt;/<span class="name">author</span>&gt;</span> <span class="comment">&lt;!-- author 单词是作者的意思，描述图书作者--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">price</span>&gt;</span>5.5<span class="tag">&lt;/<span class="name">price</span>&gt;</span> <span class="comment">&lt;!-- price 单词是价格，描述的是图书的价格--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">book</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">books</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="2-xml解析-dom4j"><a class="markdownIt-Anchor" href="#2-xml解析-dom4j"></a> 2. xml解析 dom4j</h3>
<ol>
<li>
<p>导入 dom4j.jar 包</p>
</li>
<li>
<p>创建SaxReader对象</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SAXReader reader = <span class="keyword">new</span> SAXReader();</span><br><span class="line"><span class="comment">// 这个对象用于读取xml 文件，然后返回一个Document。</span></span><br></pre></td></tr></table></figure>
<ol start="3">
<li>读取XML文件</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">Document document = reader.read(<span class="string">"src/books.xml"</span>);</span><br><span class="line"><span class="comment">// 打印到控制台，看看是否创建成功</span></span><br><span class="line">System.out.println(document);</span><br></pre></td></tr></table></figure>
<ol start="4">
<li>通过根元素对象，获取book标签对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Element root &#x3D; document.getRootElement();</span><br><span class="line">List&lt;Element&gt; books &#x3D; root.elements(&quot;book&quot;);</span><br></pre></td></tr></table></figure>
<ol start="5">
<li>拿到book 下面的name 元素对象</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">Element nameElement = book.element("name");</span><br></pre></td></tr></table></figure>
<ol start="6">
<li>getText()得到元素内的文本内容</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">nameElement.getText();</span><br></pre></td></tr></table></figure>
<ol start="7">
<li>elementText()得到元素内的文本内容</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">book.elementText("name");</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
  </entry>
  <entry>
    <title>2 jsp</title>
    <url>/2021/09/02/JAVA%20EE/jsp/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="jsp"><a class="markdownIt-Anchor" href="#jsp"></a> jsp</h2>
<h3 id="1-jsp简介"><a class="markdownIt-Anchor" href="#1-jsp简介"></a> 1. jsp简介</h3>
<a id="more"></a>
<p>jsp 的全换是java server pages。Java 的服务器页面。</p>
<p>jsp 的主要作用是代替Servlet 程序回传html 页面的数据。</p>
<p>jsp 页面本质上是一个Servlet 程序。</p>
<h3 id="2-jsp语法"><a class="markdownIt-Anchor" href="#2-jsp语法"></a> 2. jsp语法</h3>
<h4 id="21-jsp头部的-page-指令"><a class="markdownIt-Anchor" href="#21-jsp头部的-page-指令"></a> 2.1 jsp头部的 page 指令</h4>
<p>jsp 的page 指令可以修改jsp 页面中一些重要的属性，或者行为。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p><strong>language</strong> 属性</p>
<p>表示jsp 翻译后是什么语言文件。暂时只支持java。</p>
</li>
<li>
<p><strong>contentType</strong> 属性</p>
<p>表示jsp 返回的数据类型是什么。也是源码中response.setContentType()参数值</p>
</li>
<li>
<p><strong>pageEncoding</strong> 属性</p>
<p>表示当前jsp 页面文件本身的字符集。</p>
</li>
<li>
<p><strong>import</strong> 属性</p>
<p>跟java 源代码中一样。用于导包，导类。</p>
</li>
<li>
<p><strong>autoFlush</strong> 属性</p>
<p>设置当out 输出流缓冲区满了之后，是否自动刷新缓冲区。默认值是true。</p>
</li>
<li>
<p><strong>buffer</strong> 属性</p>
<p>设置out 缓冲区的大小。默认是8kb</p>
</li>
<li>
<p><strong>errorPage</strong> 属性</p>
<p>设置当jsp 页面运行时出错，自动跳转去的错误页面路径。</p>
</li>
<li>
<p><strong>isErrorPage</strong> 属性</p>
<p>设置当前jsp 页面是否是错误信息页面。默认是false。如果是true 可以获取异常信息。</p>
</li>
<li>
<p><strong>session</strong> 属性</p>
<p>设置访问当前jsp 页面，是否会创建HttpSession 对象。默认是true。</p>
</li>
<li>
<p><strong>extends</strong> 属性</p>
<p>设置jsp 翻译出来的java 类默认继承谁。</p>
</li>
</ol>
<h4 id="22-jsp-声明脚本"><a class="markdownIt-Anchor" href="#22-jsp-声明脚本"></a> 2.2 jsp 声明脚本</h4>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%! 声明java 代码%&gt;</span><br></pre></td></tr></table></figure>
<p>作用：可以给jsp 翻译出来的java 类定义属性和方法甚至是静态代码块。内部类等。</p>
<p><img src="https://i.loli.net/2021/09/10/JsijRt9L1VkErbD.png" alt="1.png" /></p>
<h4 id="23-jsp-表达式脚本"><a class="markdownIt-Anchor" href="#23-jsp-表达式脚本"></a> 2.3 jsp 表达式脚本</h4>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=表达式%&gt;</span><br></pre></td></tr></table></figure>
<p>表达式脚本的作用是：的jsp 页面上输出数据。</p>
<p><strong>表达式脚本的特点</strong></p>
<p>1、表达式脚本都会被翻译成为out.print()输出到页面上</p>
<p>2、由于表达式脚本翻译的内容都在_jspService() 方法中,所以_jspService()方法中的对象都可以直接使用。</p>
<p>3、表达式脚本中的表达式不能以分号结束。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%=<span class="number">12</span> %&gt; &lt;br&gt;</span><br><span class="line">&lt;%=<span class="number">12.12</span> %&gt; &lt;br&gt;</span><br><span class="line">&lt;%=<span class="string">"我是字符串"</span> %&gt; &lt;br&gt;</span><br><span class="line">&lt;%=map%&gt; &lt;br&gt;</span><br><span class="line">&lt;%=request.getParameter(<span class="string">"username"</span>)%&gt;</span><br></pre></td></tr></table></figure>
<h4 id="24-jsp-代码脚本"><a class="markdownIt-Anchor" href="#24-jsp-代码脚本"></a> 2.4 jsp 代码脚本</h4>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">	java 语句</span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>代码脚本的作用是：可以在jsp 页面中，编写我们自己需要的功能（写的是java 语句）。</p>
<p><img src="https://i.loli.net/2021/09/10/KYQHrFA78wUeDuJ.png" alt="2.png" /></p>
<h4 id="25-jsp-中的三种注释"><a class="markdownIt-Anchor" href="#25-jsp-中的三种注释"></a> 2.5 jsp 中的三种注释</h4>
<h5 id="251-html注释"><a class="markdownIt-Anchor" href="#251-html注释"></a> 2.5.1 html注释</h5>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;!-- 这是html 注释--&gt;</span><br></pre></td></tr></table></figure>
<p>html 注释会被翻译到java 源代码中。在_jspService 方法里，以out.writer 输出到客户端。</p>
<h5 id="252-java-注释"><a class="markdownIt-Anchor" href="#252-java-注释"></a> 2.5.2 java 注释</h5>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%</span><br><span class="line">    <span class="comment">// 单行java 注释</span></span><br><span class="line">    <span class="comment">/* 多行java 注释*/</span></span><br><span class="line">%&gt;</span><br></pre></td></tr></table></figure>
<p>java 注释会被翻译到java 源代码中。</p>
<h5 id="253-jsp-注释"><a class="markdownIt-Anchor" href="#253-jsp-注释"></a> 2.5.3 jsp 注释</h5>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%-- 这是jsp 注释--%&gt;</span><br></pre></td></tr></table></figure>
<p>jsp 注释可以注掉jsp 页面中所有代码。</p>
<h3 id="3-jsp-九大内置对象"><a class="markdownIt-Anchor" href="#3-jsp-九大内置对象"></a> 3. jsp 九大内置对象</h3>
<p>jsp 中的内置对象，是指 Tomcat 在翻译 jsp 页面成为 Servlet 源代码后，内部提供的九大对象，叫内置对象。</p>
<p><img src="https://i.loli.net/2021/09/10/aYieUXRo7pu1OZI.png" alt="3.png" /></p>
<h4 id="31-jsp-四大域对象"><a class="markdownIt-Anchor" href="#31-jsp-四大域对象"></a> 3.1 jsp 四大域对象</h4>
<p>四个域对象分别是：</p>
<p><img src="https://i.loli.net/2021/09/10/btTO6vIhSpQrDKV.png" alt="4.png" /></p>
<p>域对象是可以像Map 一样存取数据的对象。四个域对象功能一样。不同的是它们对数据的存取范围。</p>
<h4 id="32-jsp-中的-out-输出和-responsegetwriter-输出的区别"><a class="markdownIt-Anchor" href="#32-jsp-中的-out-输出和-responsegetwriter-输出的区别"></a> 3.2 jsp 中的 out 输出和 response.getWriter 输出的区别</h4>
<p>response 中表示响应，我们经常用于设置返回给客户端的内容（输出）<br />
out 也是给用户做输出使用的。</p>
<p><img src="https://i.loli.net/2021/09/10/Ds5YpfGFERIVxXd.png" alt="5.png" /></p>
<p>由于jsp 翻译之后，底层源代码都是使用out 来进行输出，所以<strong>一般情况下。我们在jsp 页面中统一使用out 来进行输出</strong>。避免打乱页面输出内容的顺序。</p>
<p>out.write() 输出字符串没有问题<br />
out.print() 输出任意数据都没有问题（都转换成为字符串后调用的write 输出）</p>
<h3 id="4-jsp-常用标签"><a class="markdownIt-Anchor" href="#4-jsp-常用标签"></a> 4. jsp 常用标签</h3>
<h4 id="41-jsp-静态包含"><a class="markdownIt-Anchor" href="#41-jsp-静态包含"></a> 4.1 jsp 静态包含</h4>
<p>示例说明：</p>
<p>&lt;%@ include file=“”%&gt; 就是静态包含<br />
file 属性指定你要包含的jsp 页面的路径<br />
地址中第一个斜杠/ 表示为<a href="http://ip" target="_blank" rel="noopener">http://ip</a>:port/工程路径/ 映射到代码的web 目录<br />
静态包含的特点：<br />
1、静态包含不会翻译被包含的jsp 页面。</p>
<p>​    2、静态包含其实是把被包含的jsp 页面的代码拷贝到包含的位置执行输出。</p>
<figure class="highlight jsp"><table><tr><td class="code"><pre><span class="line">&lt;%@ include file=<span class="string">"/include/footer.jsp"</span>%&gt;</span><br></pre></td></tr></table></figure>
<h4 id="42-jsp-动态包含"><a class="markdownIt-Anchor" href="#42-jsp-动态包含"></a> 4.2 jsp 动态包含</h4>
<p>示例说明：</p>
<p>&lt;jsp:include page=“”&gt;&lt;/jsp:include&gt; 这是动态包含<br />
page 属性是指定你要包含的jsp 页面的路径<br />
动态包含也可以像静态包含一样。把被包含的内容执行输出到包含位置<br />
动态包含的特点：<br />
1、动态包含会把包含的jsp 页面也翻译成为java 代码</p>
<p>​	2、动态包含底层代码使用如下代码去调用被包含的jsp 页面执行输出。<br />
​		JspRuntimeLibrary.include(request, response, “/include/footer.jsp”, out, false);</p>
<p>​	3、动态包含，还可以传递参数</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:include page=<span class="string">"/include/footer.jsp"</span>&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"username"</span> value=<span class="string">"bbj"</span>/&gt;</span><br><span class="line">    &lt;jsp:param name=<span class="string">"password"</span> value=<span class="string">"root"</span>/&gt;</span><br><span class="line">&lt;/jsp:include&gt;</span><br></pre></td></tr></table></figure>
<p>动态包含的底层原理：</p>
<p><img src="https://i.loli.net/2021/09/10/96OZqkepSxKrhbu.png" alt="6.png" /></p>
<h4 id="43-jsp-标签-转发"><a class="markdownIt-Anchor" href="#43-jsp-标签-转发"></a> 4.3 jsp 标签-转发</h4>
<p>示例说明：</p>
<ul>
<li>&lt;jsp:forward page=“”&gt;&lt;/jsp:forward&gt; 是请求转发标签，它的功能就是请求转发</li>
<li>page 属性设置请求转发的路径</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;jsp:forward page="/scope2.jsp"&gt;&lt;/jsp:forward&gt;</span><br></pre></td></tr></table></figure>
<h4 id="44-jsp-代码示例"><a class="markdownIt-Anchor" href="#44-jsp-代码示例"></a> 4.4 jsp 代码示例</h4>
<p>九九乘法表：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;%-- 练习一：在jsp 页面中输出九九乘法口诀表--%&gt;</span><br><span class="line">    &lt;h1 align="center"&gt;九九乘法口诀表&lt;/h1&gt;</span><br><span class="line">    &lt;table align=<span class="string">"center"</span>&gt;</span><br><span class="line">    &lt;%-- 外层循环遍历行--%&gt;</span><br><span class="line">    &lt;% <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++) &#123; %&gt;</span><br><span class="line">        &lt;tr&gt;</span><br><span class="line">        &lt;%-- 内层循环遍历单元格--%&gt;</span><br><span class="line">        &lt;% <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= i ; j++) &#123; %&gt;</span><br><span class="line">        	&lt;td&gt;&lt;%=j + "x" + i + "=" + (i*j)%&gt;&lt;/td&gt;</span><br><span class="line">        &lt;% &#125; %&gt;</span><br><span class="line">        &lt;/tr&gt;</span><br><span class="line">    &lt;% &#125; %&gt;</span><br><span class="line">    &lt;/table&gt;</span><br><span class="line">&lt;/body&gt;</span><br></pre></td></tr></table></figure>
<p>jsp 请求转发的使用：<br />
<img src="https://i.loli.net/2021/09/10/PyxsINeo2ib1hjM.png" alt="7.png" /></p>
<h3 id="5-listener监听器"><a class="markdownIt-Anchor" href="#5-listener监听器"></a> 5. Listener监听器</h3>
<p>1、Listener 监听器它是JavaWeb 的三大组件之一。JavaWeb 的三大组件分别是：Servlet 程序、Filter 过滤器、Listener 监<br />
听器。</p>
<p>2、Listener 它是JavaEE 的规范，就是接口</p>
<p>3、监听器的作用是，监听某种事物的变化。然后通过回调函数，反馈给客户（程序）去做一些相应的处理。</p>
<h4 id="51-servletcontextlistener-监听器"><a class="markdownIt-Anchor" href="#51-servletcontextlistener-监听器"></a> 5.1 ServletContextListener 监听器</h4>
<p>ServletContextListener 它可以监听ServletContext 对象的创建和销毁。</p>
<p>ServletContext 对象在web 工程启动的时候创建，在web 工程停止的时候销毁。</p>
<p>监听到创建和销毁之后都会分别调用ServletContextListener 监听器的方法反馈。</p>
<p>两个方法：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ServletContextListener</span> <span class="keyword">extends</span> <span class="title">EventListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在ServletContext 对象创建之后马上调用，做初始化</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span></span>;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 在ServletContext 对象销毁之后调用</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用ServletContextListener 监听器监听ServletContext 对象：</p>
<p>​	1、编写一个类去实现ServletContextListener<br />
​	2、实现其两个回调方法<br />
​	3、到web.xml 中去配置监听器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyServletContextListenerImpl</span> <span class="keyword">implements</span> <span class="title">ServletContextListener</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextInitialized</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"ServletContext 对象被创建了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">contextDestroyed</span><span class="params">(ServletContextEvent sce)</span> </span>&#123;</span><br><span class="line">    	System.out.println(<span class="string">"ServletContext 对象被销毁了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>web.xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--配置监听器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">listener</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">listener-class</span>&gt;</span>com.java.listener.MyServletContextListenerImpl<span class="tag">&lt;/<span class="name">listener-class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">listener</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>JAVA EE</category>
      </categories>
  </entry>
  <entry>
    <title>总结</title>
    <url>/2020/12/20/OS/%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="第1章-导论"><a class="markdownIt-Anchor" href="#第1章-导论"></a> 第1章 导论</h3>
<p><strong>操作系统是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户的程序的集合</strong></p>
<h4 id="multiprogramming"><a class="markdownIt-Anchor" href="#multiprogramming"></a> Multiprogramming</h4>
<ul>
<li>提高CPU利用率</li>
<li>提高内存和I/O设备利用率</li>
<li>增加系统吞吐量</li>
</ul>
<p>多道性 + 无序性</p>
<h4 id="特权指令"><a class="markdownIt-Anchor" href="#特权指令"></a> 特权指令</h4>
<ul>
<li>访问某些禁止用户访问的硬件的指令</li>
<li>直接访问I/O设备的指令</li>
<li>用于操作内存管理状态的指令</li>
<li>设置特殊状态位的指令</li>
<li>HLT(停机指令)</li>
</ul>
<h4 id="kernel-user-mode"><a class="markdownIt-Anchor" href="#kernel-user-mode"></a> kernel / user mode</h4>
<p>kernel → user —— PSW(程序状态字)</p>
<p>user → kernel —— system call</p>
<hr />
<p><strong>1.1</strong>What are the three main purposes of an operating system?</p>
<ul>
<li>提供一个用户可以运行程序的环境</li>
<li>提高软硬件资源的利用率</li>
<li>作为控制系统
<ul>
<li>监督用户程序的执行，以防止错误和不当使用</li>
<li>操作和控制管理I/O设备</li>
</ul>
</li>
</ul>
<h3 id="第2章-操作系统结构"><a class="markdownIt-Anchor" href="#第2章-操作系统结构"></a> 第2章 操作系统结构</h3>
<h4 id="简单结构"><a class="markdownIt-Anchor" href="#简单结构"></a> 简单结构</h4>
<p>用户——系统调用——硬件</p>
<p>优点：内核通信和系统调用的开销小</p>
<p>缺点：用户程序可能导致系统崩溃</p>
<h4 id="分层结构"><a class="markdownIt-Anchor" href="#分层结构"></a> 分层结构</h4>
<p>接受上一层的数据，并使用下一层的操作</p>
<p>优点：构造和调试简单</p>
<p>缺点：适当定义各层、效率较低</p>
<h4 id="微内核"><a class="markdownIt-Anchor" href="#微内核"></a> 微内核</h4>
<p>将内核中不必要的功能封装到用户程序中</p>
<p>优点：内核小，可扩展性强</p>
<p>缺点：系统需要的功能越多，微内核的性能越差</p>
<h3 id="第3章-进程"><a class="markdownIt-Anchor" href="#第3章-进程"></a> 第3章 进程</h3>
<p><strong>进程是活动的程序实体，包括寄存器、堆栈、数据、代码、堆</strong></p>
<h4 id="进程状态转换图"><a class="markdownIt-Anchor" href="#进程状态转换图"></a> 进程状态转换图</h4>
<p><img src="https://i.loli.net/2021/06/17/A2cZ6EyTno8kSgQ.png" alt="39.png" /></p>
<h4 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h4>
<ul>
<li>Long-term scheduler选择应将哪些进程带入ready queue</li>
<li>Short-term scheduler选择CPU执行哪个进程
<ul>
<li>从ready queue</li>
<li>频度高</li>
</ul>
</li>
<li>Medium-term scheduler
<ul>
<li>从内存或CPU中移出进程</li>
<li>可以降低多道程序运行的度（与Long-term scheduler相反）</li>
</ul>
</li>
</ul>
<h4 id="进程间通讯"><a class="markdownIt-Anchor" href="#进程间通讯"></a> 进程间通讯</h4>
<p><strong>消息传递</strong></p>
<ul>
<li>可用于交换少量数据，因为无需避免冲突</li>
<li>更容易实施</li>
<li>通过系统调用（例如send（），receive（））交换信息</li>
</ul>
<p><strong>共享内存</strong></p>
<ul>
<li>通过内存访问有更快的内存速度</li>
<li>系统调用仅用于建立共享内存区域</li>
</ul>
<h3 id="第4章-线程"><a class="markdownIt-Anchor" href="#第4章-线程"></a> 第4章 线程</h3>
<img src="https://i.loli.net/2020/10/23/A5bLvzJX6sPEdCO.png" alt="image-20201011095455371.png" style="zoom: 80%;" />
<h4 id="进程与线程的比较"><a class="markdownIt-Anchor" href="#进程与线程的比较"></a> 进程与线程的比较</h4>
<ul>
<li>进程是资源分配单位，线程是CPU分配单位</li>
<li>进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈</li>
<li>线程同样具有就绪、阻塞和执行三种状态，同样具有状态之间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销</li>
<li>线程 = 轻量级进程</li>
</ul>
<h4 id="线程优点"><a class="markdownIt-Anchor" href="#线程优点"></a> 线程优点</h4>
<ul>
<li>响应性</li>
<li>资源共享</li>
<li>经济</li>
<li>可伸缩性</li>
</ul>
<h3 id="第5章-cpu调度"><a class="markdownIt-Anchor" href="#第5章-cpu调度"></a> 第5章 CPU调度</h3>
<h4 id="cpu调度发生的情况"><a class="markdownIt-Anchor" href="#cpu调度发生的情况"></a> CPU调度发生的情况</h4>
<ul>
<li>从new到ready</li>
<li>从running到waiting</li>
<li>从running到ready</li>
<li>从waiting到ready</li>
<li>terminate</li>
</ul>
<p>2、5非抢占</p>
<h4 id="调度准则"><a class="markdownIt-Anchor" href="#调度准则"></a> 调度准则</h4>
<ul>
<li>CPU利用率</li>
<li>吞吐率：在时间单元内进程完成的数量</li>
<li>周转时间：从进程提交到进程完成的时间段，包括等待进入内存、在就绪队列中等待、在CPU上执行和I/O执行</li>
<li>等待时间：在就绪队列中等待所花时间之和</li>
<li>响应时间：从提交请求到产生第一响应的时间</li>
</ul>
<h4 id="调度算法"><a class="markdownIt-Anchor" href="#调度算法"></a> 调度算法</h4>
<p>FCFS、SJF、SRTF、优先级调度、RR、多级队列/多级反馈队列调度、实时调度算法（单调速率和最早截止优先调度）</p>
<p>饥饿：SJF、SRTF、优先级、多级队列</p>
<h4 id="线程调度"><a class="markdownIt-Anchor" href="#线程调度"></a> 线程调度</h4>
<p>PCS发生在同一进程的线程之间，会将线程调度到可用LWP上；SCS用来决定哪个内核级线程调度到处理器上，发生在系统内的所有线程之间</p>
<h3 id="第6章-进程同步"><a class="markdownIt-Anchor" href="#第6章-进程同步"></a> 第6章 进程同步</h3>
<p><strong>竞争条件：多个进程并发访问且要求修改同一个数据</strong></p>
<h4 id="临界区问题解决"><a class="markdownIt-Anchor" href="#临界区问题解决"></a> 临界区问题解决</h4>
<ul>
<li>mutual exclusion</li>
<li>progress</li>
<li>bounded waiting</li>
</ul>
<h4 id="互斥锁"><a class="markdownIt-Anchor" href="#互斥锁"></a> 互斥锁</h4>
<p><img src="https://i.loli.net/2021/06/17/eAcW4CXnOPSzKjZ.png" alt="40.png" /></p>
<p>优点：进程等待时无需上下文切换，简单容易实现</p>
<p>缺点：浪费CPU资源，会忙碌等待，饥饿</p>
<h4 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h4>
<p><img src="https://i.loli.net/2021/06/17/XfB9nwozpQMIGdi.png" alt="41.png" /></p>
<p>优点：避免了busy waiting，可以适用于非互斥的情况</p>
<p>缺点：用户的错误使用会导致死锁和饥饿</p>
<h4 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h4>
<p><img src="https://i.loli.net/2021/06/17/y9SgXLVRr68zUua.png" alt="42.png" /></p>
<h3 id="第7章-死锁"><a class="markdownIt-Anchor" href="#第7章-死锁"></a> 第7章 死锁</h3>
<p><strong>死锁：在系统的某一部分中，所有进程都在等待其他进程释放资源而陷入的无尽循环的等待过程</strong></p>
<ul>
<li>互斥</li>
<li>占有并等待</li>
<li>非抢占</li>
<li>循环等待</li>
</ul>
<h4 id="系统资源分配图申请边-分配边"><a class="markdownIt-Anchor" href="#系统资源分配图申请边-分配边"></a> 系统资源分配图：申请边、分配边</h4>
<h4 id="死锁预防"><a class="markdownIt-Anchor" href="#死锁预防"></a> 死锁预防</h4>
<p><strong>持有并等待</strong></p>
<p>每个进程必须一次申请完自己所需的所有资源</p>
<p>缺点：资源利用率低</p>
<p><strong>防止循环等待</strong></p>
<p>规划资源申请顺序，防止死锁</p>
<p><strong>安全状态</strong></p>
<p>进程的资源申请顺序&lt;p1, pn&gt;改顺序使得每个p都可申请到所需资源</p>
<h4 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h4>
<p><strong>安全算法</strong></p>
<p><img src="https://i.loli.net/2021/06/17/xvoqhD3LCN41HwY.png" alt="43.png" /></p>
<p><img src="https://i.loli.net/2021/06/17/pTlnzIDc8qBiv6K.png" alt="44.png" /></p>
<p><strong>资源请求算法</strong></p>
<p><img src="https://i.loli.net/2021/06/17/pTlnzIDc8qBiv6K.png" alt="45.png" /></p>
<h3 id="第8章-内存管理"><a class="markdownIt-Anchor" href="#第8章-内存管理"></a> 第8章 内存管理</h3>
<h4 id="连续内存分配"><a class="markdownIt-Anchor" href="#连续内存分配"></a> 连续内存分配</h4>
<p><strong>固定分区</strong></p>
<p><strong>可变分区</strong></p>
<ul>
<li>首次适应</li>
<li>最优适应</li>
<li>最差适应</li>
</ul>
<p>问题：内部碎片、外部碎片</p>
<h4 id="分页"><a class="markdownIt-Anchor" href="#分页"></a> 分页</h4>
<h4 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h4>
<p>&lt;段号、偏移&gt;</p>
<p>STBR、STLR</p>
<h4 id="分页与分段的区别"><a class="markdownIt-Anchor" href="#分页与分段的区别"></a> 分页与分段的区别</h4>
<p><strong>动机和目的</strong></p>
<ul>
<li>分页：<strong>面向系统、物理上离散、减少外部和内部碎片、提高内存利用率</strong>；页是信息的物理单元</li>
<li>分段：<strong>面向用户，逻辑上离散，满足用户需求</strong>；段是具有相对完整含义的信息的逻辑单元</li>
</ul>
<p><strong>大小</strong></p>
<ul>
<li>分页：大小固定，由硬件决定</li>
<li>分段：大小不固定，由程序和编译时决定</li>
</ul>
<p><strong>维度</strong></p>
<ul>
<li>分页：一维</li>
<li>分段：二维</li>
</ul>
<h3 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h3>
<p><strong>请求调页：在程序需要一部分内存页面时，从硬盘中加载对应页面到内存的技术</strong></p>
<p><strong>系统抖动：进程的调页时间多于执行时间，监视cpu利用率，降低说明发生抖动</strong></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第10章 存储管理</title>
    <url>/2020/11/29/OS/%E7%AC%AC10%E7%AB%A0%20%E5%AD%98%E5%82%A8%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="存储管理"><a class="markdownIt-Anchor" href="#存储管理"></a> 存储管理</h2>
<h3 id="101-文件概念"><a class="markdownIt-Anchor" href="#101-文件概念"></a> 10.1 文件概念</h3>
<a id="more"></a>
<ul>
<li>
<p>文件是记录在外存上的相关信息的命名组合</p>
</li>
<li>
<p>文件是逻辑外存的最小分配单元</p>
</li>
</ul>
<h4 id="1011-文件属性"><a class="markdownIt-Anchor" href="#1011-文件属性"></a> 10.1.1 文件属性</h4>
<p>文件的属性包括：名称、标识符、类型、位置、尺寸、保护、时间、日期和用户标识</p>
<p><strong>目录</strong></p>
<ul>
<li>所有的文件信息保存在目录结构中，目录结构也保存在外存上</li>
<li>通常，目录条目由文件的名称及其唯一的标志符组成</li>
<li>根据标识符可定位其他文件属性</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/K7mRNYafjDu9XMJ.png" alt="1.png" /></p>
<h4 id="1012-文件操作"><a class="markdownIt-Anchor" href="#1012-文件操作"></a> 10.1.2 文件操作</h4>
<p>​	创建：分配空间 + 创建目录条目</p>
<p>​	写：写指针</p>
<p>​	读：读指针</p>
<p>​	重定位文件：搜索</p>
<p>​	删除：释放空间 + 删除目录条目</p>
<p>​	截断(Truncate): 文件重置为0， 释放空间，保留其他文件属性</p>
<h5 id="每个进程表per-process-table-整个系统表system-wide-table"><a class="markdownIt-Anchor" href="#每个进程表per-process-table-整个系统表system-wide-table"></a> 每个进程表(per-process table) &amp; 整个系统表(system-wide table)</h5>
<p>每个进程表：存放进程对文件的使用信息</p>
<p>整个系统表：存放与进程无关的文件的信息</p>
<p><img src="https://i.loli.net/2021/06/17/hJKXLFw2fde7vVj.png" alt="2.png" /></p>
<p>​	文件指针：上次读写位置，<strong>每个进程都是唯一的</strong></p>
<p>​	文件打开计数：跟踪打开文件的进程个数，为0时删除条目</p>
<p>​	文件的磁盘位置：查找磁盘上的文件所需的信息保存在内存中</p>
<p>​	访问权限：每个进程采用访问模式打开文件</p>
<h5 id="打开文件锁"><a class="markdownIt-Anchor" href="#打开文件锁"></a> 打开文件锁</h5>
<p><strong>共享锁</strong></p>
<p>类似于读者锁，多个进程可以并发获取它</p>
<p><strong>独占(Exclusive)锁</strong></p>
<p>类似于写者锁，一次只有一个进程可以获取这样的锁</p>
<h6 id="强制-建议"><a class="markdownIt-Anchor" href="#强制-建议"></a> 强制 &amp; 建议</h6>
<p>操作系统可以提供<strong>强制</strong>或<strong>建议</strong>文件锁定机制。如果锁是<strong>强制性</strong>的，则一旦进程获取独占锁，操作系统就阻止任何其他进程访问锁定的文件。如果锁是<strong>建议性</strong>的，则操作系统不会阻止其他进程的访问。</p>
<h4 id="1013-文件类型"><a class="markdownIt-Anchor" href="#1013-文件类型"></a> 10.1.3 文件类型</h4>
<h4 id="1014-文件结构"><a class="markdownIt-Anchor" href="#1014-文件结构"></a> 10.1.4 文件结构</h4>
<p>大多现代操作系统支持最小数量的文件结构</p>
<ul>
<li>Example: UNIX认为每个文件为8个字节序列</li>
</ul>
<p>优点：</p>
<ul>
<li>应用程序更灵活</li>
<li>简化OS</li>
</ul>
<h4 id="1015-内部文件结构"><a class="markdownIt-Anchor" href="#1015-内部文件结构"></a> 10.1.5 内部文件结构</h4>
<p>将<strong>逻辑文件(记录)<strong>放入</strong>物理块</strong>中</p>
<h5 id="打包packing"><a class="markdownIt-Anchor" href="#打包packing"></a> 打包(Packing)</h5>
<ul>
<li>
<p>打包 &amp; 解包：文件系统会自动将字节打包以存入物理磁盘块，或从磁盘块中解包得到字节</p>
</li>
<li>
<p>有内部碎片出现</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/ZzRuLnrITcY4N2d.png" alt="3.png" /></p>
<h3 id="102-访问方法"><a class="markdownIt-Anchor" href="#102-访问方法"></a> 10.2 访问方法</h3>
<h4 id="1021-顺序访问"><a class="markdownIt-Anchor" href="#1021-顺序访问"></a> 10.2.1 顺序访问</h4>
<p><img src="https://i.loli.net/2021/06/17/HvYlOfDs78mTwiX.png" alt="4.png" /></p>
<h4 id="1022-直接访问"><a class="markdownIt-Anchor" href="#1022-直接访问"></a> 10.2.2 直接访问</h4>
<p>磁盘允许对任何文件块的随机访问</p>
<p>通过<strong>相对块号</strong>进行索引</p>
<p><img src="https://i.loli.net/2021/06/17/i1som3LxfrWGOBC.png" alt="5.png" /></p>
<h4 id="1023-索引访问方式"><a class="markdownIt-Anchor" href="#1023-索引访问方式"></a> 10.2.3 索引访问方式</h4>
<p><img src="https://i.loli.net/2021/06/17/7GKNVfpo3nh65Ea.png" alt="7.png" /></p>
<h3 id="103-目录与磁盘的结构"><a class="markdownIt-Anchor" href="#103-目录与磁盘的结构"></a> 10.3 目录与磁盘的结构</h3>
<h4 id="1031-储存结构"><a class="markdownIt-Anchor" href="#1031-储存结构"></a> 10.3.1 储存结构</h4>
<p><strong>分区</strong> = <strong>文件</strong> + <strong>目录</strong></p>
<p><img src="https://i.loli.net/2021/06/17/tIDCVeJHjUTx9n2.png" alt="8.png" /></p>
<h4 id="1032-目录概述"><a class="markdownIt-Anchor" href="#1032-目录概述"></a> 10.3.2 目录概述</h4>
<p>搜索、创建、删除文件、遍历目录、重命名文件、遍历文件系统</p>
<h4 id="1033-单层目录"><a class="markdownIt-Anchor" href="#1033-单层目录"></a> 10.3.3 单层目录</h4>
<p><img src="https://i.loli.net/2021/06/17/JrKoAsHSZ3aLv4m.png" alt="9.png" /></p>
<ul>
<li>搜索速度慢</li>
<li>多用户时出现<strong>命名冲突</strong></li>
</ul>
<h4 id="1034-双层目录"><a class="markdownIt-Anchor" href="#1034-双层目录"></a> 10.3.4 双层目录</h4>
<p>用户文件目录(User File Directory, <strong>UFD</strong>)：每个条目拥有用户文件的信息</p>
<p>主文件目录(Master File Directory, <strong>MFD</strong>)：每个词条包含用户名和指向UFD的指针</p>
<p><img src="https://i.loli.net/2021/06/17/qOTzANPZj7kErlR.png" alt="10.png" /></p>
<ul>
<li>可以为不同的用户使用相同文件名</li>
<li>搜索效率提升</li>
<li>分组能力</li>
</ul>
<h4 id="1035-树形目录"><a class="markdownIt-Anchor" href="#1035-树形目录"></a> 10.3.5 树形目录</h4>
<p>​		目录只不过是一个文件，但它是按特殊方式处理的。每个目录条目都有一位来将条目定义为文件(0)或子目录(1)</p>
<p><strong>当前目录</strong></p>
<p>包含进程当前感兴趣的大多数文件。当引用一个文件就搜索当前目录</p>
<p><img src="https://i.loli.net/2021/06/17/B6poQeu9OWzxkCZ.png" alt="11.png" /></p>
<ul>
<li>搜索效率</li>
<li>分组能力</li>
<li>但阻止了文件和目录的共享</li>
</ul>
<h4 id="1036-无环图目录"><a class="markdownIt-Anchor" href="#1036-无环图目录"></a> 10.3.6 无环图目录</h4>
<p>允许目录共享子目录和文件，但不能出现循环</p>
<h5 id="链接link"><a class="markdownIt-Anchor" href="#链接link"></a> 链接(link)</h5>
<p>文件的内容是真实文件的路径名</p>
<h5 id="复制目录条目"><a class="markdownIt-Anchor" href="#复制目录条目"></a> 复制目录条目</h5>
<p>在两个共享目录中复制有关共享文件的所有信息，因此两个条目相同切相等</p>
<ul>
<li>但是难以维护一致性，在修改文件时要维护一致性</li>
</ul>
<h5 id="遍历问题"><a class="markdownIt-Anchor" href="#遍历问题"></a> 遍历问题</h5>
<ul>
<li>不同的名字，实际上是同一个文件</li>
<li>需要不止一次地遍历共享结构</li>
</ul>
<h5 id="删除问题"><a class="markdownIt-Anchor" href="#删除问题"></a> 删除问题</h5>
<ul>
<li>只要有用户删除就删除—&gt;空悬指针</li>
<li>保留文件，直到它的所有引用都被删除</li>
</ul>
<h4 id="1037-通用图目录"><a class="markdownIt-Anchor" href="#1037-通用图目录"></a> 10.3.7 通用图目录</h4>
<p><img src="https://i.loli.net/2021/06/17/FB9eYrLo6tjnSKW.png" alt="12.png" /></p>
<p><strong>遍历问题</strong>和<strong>删除问题</strong>依旧存在，甚至更复杂</p>
<ul>
<li>限制访问目录的数量</li>
<li>垃圾回收方案</li>
</ul>
<p><strong>如何保证无环</strong></p>
<ul>
<li>可以只允许链接到文件而不是子目录</li>
<li>每次添加新链接时，使用周期检测算法</li>
</ul>
<h3 id="104-文件系统安装挂载mounting"><a class="markdownIt-Anchor" href="#104-文件系统安装挂载mounting"></a> 10.4 文件系统安装/挂载(Mounting)</h3>
<ul>
<li>
<p>文件系统在用于系统的进程之前必须先安装</p>
</li>
<li>
<p>没有挂载的文件系统需要被挂载到挂载点</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/Zrg8GO1FMod3k5D.png" alt="13.png" /></p>
<h3 id="105-文件共享"><a class="markdownIt-Anchor" href="#105-文件共享"></a> 10.5 文件共享</h3>
<h4 id="1053-一致性语义"><a class="markdownIt-Anchor" href="#1053-一致性语义"></a> 10.5.3 一致性语义</h4>
<p>一致性语义指定多个用户如何同时访问共享文件</p>
<h5 id="10531-unix语义"><a class="markdownIt-Anchor" href="#10531-unix语义"></a> 10.5.3.1 UNIX语义</h5>
<ul>
<li>写入一个打开的文件，该打开文件对同一打开文件的其他用户立即可见</li>
<li>共享文件指针以允许多个用户同时读写会话语义</li>
</ul>
<h5 id="10532-会话语义"><a class="markdownIt-Anchor" href="#10532-会话语义"></a> 10.5.3.2 会话语义</h5>
<ul>
<li>仅在关闭文件后开始的会话中可见</li>
</ul>
<h3 id="106-保护"><a class="markdownIt-Anchor" href="#106-保护"></a> 10.6 保护</h3>
<h4 id="1061-访问类型"><a class="markdownIt-Anchor" href="#1061-访问类型"></a> 10.6.1 访问类型</h4>
<p>读、写、执行、附加、删除、列表</p>
<h4 id="1062-访问控制"><a class="markdownIt-Anchor" href="#1062-访问控制"></a> 10.6.2 访问控制</h4>
<p><strong>访问控制列表(Access-Control List, ACL)</strong></p>
<ul>
<li>
<p>为每个文件和目录关联一个ACL，指定每个用户的名称及其允许的访问类型</p>
</li>
<li>
<p>存储在目录项中</p>
</li>
</ul>
<p><strong>三类用户</strong></p>
<p>所有者权限：1 1 1 RWX</p>
<p>组权限：1 1 0 	RW</p>
<p>其他权限：0 0 1	X</p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>11.1 Some systems automatically delete all user files when a user logs off or<br />
a job terminates, unless the user explicitly requests that they be kept.<br />
Other systems keep all files unless the user explicitly deletes them.<br />
Discuss the relative merits of each approach.</p>
<p>11.2 Why do some systems keep track of the type of a file, while others leave<br />
it to the user and others simply do not implement multiple file types?<br />
Which system is “better”?</p>
<p>11.3 Similarly, some systems support many types of structures for a file’s<br />
data, while others simply support a stream of bytes. What are the<br />
advantages and disadvantages of each approach?</p>
<p>11.4 Could you simulate a multilevel directory structure with a single-level<br />
directory structure in which arbitrarily long names can be used? If your<br />
answer is yes, explain how you can do so, and contrast this scheme with<br />
the multilevel directory scheme. If your answer is no, explain what<br />
prevents your simulation’s success. How would your answer change<br />
if file names were limited to seven characters?</p>
<p>11.5 Explain the purpose of the open() and close() operations.</p>
<p>11.6 In some systems, a subdirectory can be read and written by an<br />
authorized user, just as ordinary files can be.<br />
a. Describe the protection problems that could arise.<br />
b. Suggest a scheme for dealing with each of these protection<br />
problems.</p>
<p>11.9 Consider a file system in which a file can be deleted and its disk space<br />
reclaimed while links to that file still exist. What problems may occur if<br />
a new file is created in the same storage area or with the same absolute<br />
path name? How can these problems be avoided?</p>
<p>11.10 The open-file table is used to maintain information about files that are<br />
currently open. Should the operating system maintain a separate table<br />
for each user or maintain just one table that contains references to files<br />
that are currently being accessed by all users? If the same file is being<br />
accessed by two different programs or users, should there be separate<br />
entries in the open-file table? Explain.</p>
<p>11.11 What are the advantages and disadvantages of providing mandatory<br />
locks instead of advisory locks whose use is left to users’ discretion?</p>
<p>11.12 Provide examples of applications that typically access files according<br />
to the following methods:<br />
• Sequential<br />
• Random</p>
<p>11.13 Some systems automatically open a file when it is referenced for the first<br />
time and close the file when the job terminates. Discuss the advantages<br />
and disadvantages of this scheme compared with the more traditional<br />
one, where the user has to open and close the file explicitly.</p>
<p>11.14 If the operating system knew that a certain application was going<br />
to access file data in a sequential manner, how could it exploit this<br />
information to improve performance?</p>
<p>11.15 Give an example of an application that could benefit from operating system support for random access to indexed files.</p>
<p>11.17 Some systems provide file sharing by maintaining a single copy of a<br />
file. Other systems maintain several copies, one for each of the users<br />
sharing the file. Discuss the relative merits of each approach.</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第12章 大容量存储结构</title>
    <url>/2020/12/12/OS/%E7%AC%AC12%E7%AB%A0%20%E5%A4%A7%E5%AE%B9%E9%87%8F%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="大容量存储结构"><a class="markdownIt-Anchor" href="#大容量存储结构"></a> 大容量存储结构</h2>
<h3 id="121-大容量存储结构概述"><a class="markdownIt-Anchor" href="#121-大容量存储结构概述"></a> 12.1 大容量存储结构概述</h3>
<a id="more"></a>
<h3 id="1211-磁盘"><a class="markdownIt-Anchor" href="#1211-磁盘"></a> 12.1.1 磁盘</h3>
<p><strong>传输速率(transfer rate)</strong></p>
<p>是在驱动器和计算机之间的数据流的速率</p>
<p><strong>定位时间(positioning time)</strong>：<strong>寻道时间(seek time)</strong>+<strong>旋转延迟(rotational latency)</strong></p>
<p><strong>寻道时间</strong>：移动磁臂到所要柱面的所需时间</p>
<p><strong>旋转延迟</strong>：旋转磁臂到所要扇区的所需时间**(旋转延迟为一圈时间/2)**</p>
<ul>
<li>磁盘是可移动的</li>
<li>磁盘驱动器通过I/O总线连到计算机</li>
</ul>
<p>盘片、转轴、柱面、磁道、扇区、磁臂、读写磁头、机械臂杆</p>
<p><img src="https://i.loli.net/2021/06/17/PhGp27YuCS1WiqI.png" alt="24.png" /></p>
<p>计算机中的主机控制器使用总线与每个磁盘控制器通信</p>
<h3 id="122-磁盘结构"><a class="markdownIt-Anchor" href="#122-磁盘结构"></a> 12.2 磁盘结构</h3>
<p>现代磁盘驱动器可以看作**逻辑块(logical block)**的一维数组，逻辑块是最小的传输单元</p>
<ul>
<li>
<p>一维<strong>逻辑块</strong>数组依次映射到磁盘扇区</p>
<ul>
<li>扇区0是最外面柱面的第一个磁道的第一个扇区</li>
<li>先按磁道内扇区顺序，再按柱面内磁道顺序，再按从外到内的柱面顺序</li>
</ul>
</li>
<li>
<p>实际上，由于两个原因，映射较为困难</p>
<ul>
<li>缺陷扇区(defective sectors)</li>
<li>磁道的扇区数不是常量</li>
</ul>
</li>
</ul>
<h3 id="124-磁盘调度"><a class="markdownIt-Anchor" href="#124-磁盘调度"></a> 12.4 磁盘调度</h3>
<p><strong>磁盘带宽(disk bandwidth)</strong></p>
<p>是传输字节的总数，除以从服务请求开始到最后传递结束时的总时间</p>
<h4 id="1241-fcfs调度"><a class="markdownIt-Anchor" href="#1241-fcfs调度"></a> 12.4.1 FCFS调度</h4>
<p><img src="https://i.loli.net/2021/06/17/AnuvQzN8adGyFUM.png" alt="25.png" /></p>
<h4 id="1242-sstfshortest-seek-time-first调度"><a class="markdownIt-Anchor" href="#1242-sstfshortest-seek-time-first调度"></a> 12.4.2 SSTF(shortest-seek-time-first)调度</h4>
<p>SSTF算法选择处理距离当前磁头位置的最短寻道时间的请求</p>
<p>它会导致一些请求的饥饿</p>
<p><img src="https://i.loli.net/2021/06/17/E7IxziqfbUl8Syt.png" alt="26.png" /></p>
<h4 id="1243-scan调度电梯算法"><a class="markdownIt-Anchor" href="#1243-scan调度电梯算法"></a> 12.4.3 SCAN调度/电梯算法</h4>
<p>磁臂从磁盘的一端开始，向另一端移动；当到达磁盘的另一端时，移动方向反转</p>
<p><img src="https://i.loli.net/2021/06/17/7WLxy2HoKlBNAd9.png" alt="27.png" /></p>
<h4 id="1244-c-scan调度"><a class="markdownIt-Anchor" href="#1244-c-scan调度"></a> 12.4.4 C-SCAN调度</h4>
<p>磁臂从磁盘一端开始向另一端移动；当磁头到达另一端时，立即返回到磁盘的开头</p>
<p><img src="https://i.loli.net/2021/06/17/nwKu43HqEms8NyR.png" alt="28.png" /></p>
<h4 id="1245-c-look调度"><a class="markdownIt-Anchor" href="#1245-c-look调度"></a> 12.4.5 C-LOOK调度</h4>
<p>磁臂只需移动到一个方向的最远请求为止</p>
<p><img src="https://i.loli.net/2021/06/17/jVrvYc4WySl7DkL.png" alt="29.png" /></p>
<h4 id="1246-磁盘调度算法的选择"><a class="markdownIt-Anchor" href="#1246-磁盘调度算法的选择"></a> 12.4.6 磁盘调度算法的选择</h4>
<ul>
<li>
<p>SSTF较为常见</p>
</li>
<li>
<p>对于磁盘负荷较大的系统，SCAN和C-SCAN表现更好，因为它们不太可能造成饥饿</p>
</li>
<li>
<p>磁盘调度算法应该作为OS的一个单独模块，SSTF或LOOK是默认算法的合理选择</p>
</li>
<li>
<p>性能取决于</p>
<ul>
<li>文件分配方式(连续/分散)</li>
<li>目录和索引块的位置(柱面间距离)</li>
</ul>
</li>
</ul>
<h3 id="12-磁盘缓存"><a class="markdownIt-Anchor" href="#12-磁盘缓存"></a> 12.? 磁盘缓存</h3>
<ul>
<li>
<p>磁盘缓存是内存中磁盘扇区的缓冲区</p>
<ul>
<li>包含磁盘上某些扇区的副本</li>
</ul>
</li>
<li>
<p>当针对特定扇区发出I / O请求时</p>
<ul>
<li>检查以确定该扇区是否在磁盘缓存中</li>
</ul>
</li>
<li>
<p>存在许多填充缓存的方法</p>
</li>
</ul>
<p><strong>单缓存</strong></p>
<p><img src="https://i.loli.net/2021/06/17/lH7W5G8QfBDYA6S.png" alt="30.png" /></p>
<p><img src="https://i.loli.net/2021/06/17/WNbDrgIvi3cPjKV.png" alt="31.png" /></p>
<h3 id="125-磁盘管理"><a class="markdownIt-Anchor" href="#125-磁盘管理"></a> 12.5 磁盘管理</h3>
<h4 id="1251-磁盘格式化"><a class="markdownIt-Anchor" href="#1251-磁盘格式化"></a> 12.5.1 磁盘格式化</h4>
<p><strong>低级(low-level)格式化/物理(physical)格式化</strong></p>
<p>将磁盘划分为磁盘控制器可以读取和写入的扇区</p>
<hr />
<p>在可以使用磁盘存储文件之前，OS仍需要将自己的数据结构记录在磁盘上</p>
<ul>
<li>
<p>将磁盘分为由柱面组成的多个分区</p>
</li>
<li>
<p>**逻辑格式化(logical formatting)**或创建文件系统</p>
<p>将初始的文件系统数据结构存储到磁盘上</p>
</li>
</ul>
<hr />
<p>为了提高效率，大多数操作系统将块组合在一起变成更大的块，称为簇</p>
<ul>
<li>磁盘I/O按块完成</li>
<li>文件I/O按簇完成</li>
</ul>
<p>有效确保了I/O具有更多的顺序访问和更少的随机访问的特点</p>
<h4 id="1252-引导块"><a class="markdownIt-Anchor" href="#1252-引导块"></a> 12.5.2 引导块</h4>
<ul>
<li>
<p>**自举(bootstrap)<strong>程序处在</strong>只读存储器(Read-Only Memory, ROM)**中</p>
</li>
<li>
<p>自居程序的作用是从磁盘上调入完整的引导程序</p>
</li>
<li>
<p><strong>引导分区(boot partition)</strong>：包含OS和设备驱动程序</p>
</li>
<li>
<p><strong>(Master Boot Record)MBR</strong>：引导代码存放在磁盘的第一个扇区</p>
</li>
</ul>
<p>引导首先运行驻留在ROM中的代码，指示系统从<strong>MBR</strong>中读取引导代码。通过<strong>MBR</strong>中的分区表找到<strong>引导分区</strong>，读取分区的第一个扇区，称为<strong>引导扇区</strong></p>
<p><img src="https://i.loli.net/2021/06/17/mAZopGb4t3XO8f6.png" alt="32.png" /></p>
<h4 id="1253-坏块disk-failure"><a class="markdownIt-Anchor" href="#1253-坏块disk-failure"></a> 12.5.3 坏块(Disk Failure)</h4>
<p><strong>坏块解决策略</strong></p>
<ol>
<li>
<p>手动处理</p>
<p>发现坏块标记为不可用</p>
</li>
<li>
<p><strong>扇区备用(sector sparing)</strong></p>
<p>低级格式化将一些块放在一边作为备用，控制器可以采用备用块来逻辑地替代坏块(每次读取坏块转换成控制器的替代扇区地址)</p>
</li>
<li>
<p><strong>扇区滑动(sector slipping)</strong></p>
<ul>
<li>逻辑块17变坏</li>
<li>第一个可用的备用块在202之后</li>
<li>202→203, 201→202, …, 17→18</li>
</ul>
</li>
</ol>
<h3 id="126-交换空间管理"><a class="markdownIt-Anchor" href="#126-交换空间管理"></a> 12.6 交换空间管理</h3>
<h4 id="交换空间"><a class="markdownIt-Anchor" href="#交换空间"></a> 交换空间</h4>
<p>虚拟内存采用磁盘空间作为内存的扩展</p>
<ul>
<li>交换空间可以位于普通文件系统之上</li>
<li>可以是一个单独的磁盘分区</li>
</ul>
<h3 id="127-raid-结构"><a class="markdownIt-Anchor" href="#127-raid-结构"></a> 12.7 RAID 结构</h3>
<p><strong>磁盘冗余阵列(RAID)</strong>：多个磁盘驱动器通过冗余提供可靠性，更高的数据传输率</p>
<h4 id="1273-raid级别"><a class="markdownIt-Anchor" href="#1273-raid级别"></a> 12.7.3 RAID级别</h4>
<p>RAID共被分为六个级别</p>
<p><img src="https://i.loli.net/2021/06/17/1dWraZblq3geD7c.png" alt="33.png" /></p>
<h5 id="raid-0-磁盘分条disk-striping"><a class="markdownIt-Anchor" href="#raid-0-磁盘分条disk-striping"></a> RAID-0 磁盘分条(disk striping)</h5>
<p><img src="https://i.loli.net/2021/06/17/BzgMy5LEmDCKrGR.png" alt="34.png" /></p>
<ul>
<li>并行数据块访问提供更大的磁盘带宽</li>
</ul>
<h5 id="raid-1-磁盘镜像"><a class="markdownIt-Anchor" href="#raid-1-磁盘镜像"></a> RAID-1 磁盘镜像</h5>
<p>简单复制</p>
<p><img src="https://i.loli.net/2021/06/17/Kv9ulp3Jx2Ij56c.png" alt="35.png" /></p>
<ul>
<li>
<p>可靠性指数倍增长</p>
</li>
<li>
<p>读取性能现性增长</p>
</li>
</ul>
<h5 id="raid-4-块级分条block-level-striping-专用奇偶校验parity"><a class="markdownIt-Anchor" href="#raid-4-块级分条block-level-striping-专用奇偶校验parity"></a> RAID-4 块级分条(block-level striping) +  专用奇偶校验(parity)</h5>
<p><img src="https://i.loli.net/2021/06/17/hesRWLO4SjXiGf7.png" alt="36.png" /></p>
<ul>
<li>允许从任何发生故障的磁盘中恢复</li>
</ul>
<h5 id="raid-5-磁盘分条-分布式奇偶校验"><a class="markdownIt-Anchor" href="#raid-5-磁盘分条-分布式奇偶校验"></a> RAID-5 磁盘分条 + 分布式奇偶校验</h5>
<p><img src="https://i.loli.net/2021/06/17/g9WCEfKABReQmhT.png" alt="37.png" /></p>
<h5 id="raid-0-1-1-0"><a class="markdownIt-Anchor" href="#raid-0-1-1-0"></a> RAID 0 + 1	/ 1 + 0</h5>
<img src="https://i.loli.net/2021/06/17/G82i6rTUQqtljAD.png" alt="38.png"  />
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>10.1 Is disk scheduling, other than FCFS scheduling, useful in a single-user<br />
environment? Explain your answer.</p>
<p>10.2 Explain why SSTF scheduling tends to favor middle cylinders over the<br />
innermost and outermost cylinders.</p>
<p>10.3 Why is rotational latency usually not considered in disk scheduling?<br />
How would you modify SSTF, SCAN, and C-SCAN to include latency<br />
optimization?</p>
<p>10.4 Why is it important to balance file-system I/O among the disks and<br />
controllers on a system in a multitasking environment?</p>
<p>10.9 None of the disk-scheduling disciplines, except FCFS, is truly fair<br />
(starvation may occur).<br />
a. Explain why this assertion is true.<br />
b. Describe a way to modify algorithms such as SCAN to ensure<br />
fairness.<br />
c. Explain why fairness is an important goal in a time-sharing<br />
system.<br />
d. Give three or more examples of circumstances in which it is<br />
important that the operating system be unfair in serving I/O<br />
requests.</p>
<p>10.11 Suppose that a disk drive has 5,000 cylinders, numbered 0 to 4,999. The drive is currently serving a request at cylinder 2,150, and the previous request was at cylinder 1,805. The queue of pending requests, in FIFO order, is: 2,069, 1,212, 2,296, 2,800, 544, 1,618, 356, 1,523, 4,965, 3681<br />
Starting from the current head position, what is the total distance (in<br />
cylinders) that the disk arm moves to satisfy all the pending requests<br />
for each of the following disk-scheduling algorithms?<br />
a. FCFS<br />
b. SSTF<br />
c. SCAN<br />
d. LOOK<br />
e. C-SCAN<br />
f. C-LOOK</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第11章 文件系统实现</title>
    <url>/2020/12/05/OS/%E7%AC%AC11%E7%AB%A0%20%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="文件系统实现"><a class="markdownIt-Anchor" href="#文件系统实现"></a> 文件系统实现</h2>
<h3 id="111-文件系统结构"><a class="markdownIt-Anchor" href="#111-文件系统结构"></a> 11.1 文件系统结构</h3>
<a id="more"></a>
<p><strong>分层文件系统</strong></p>
<p><img src="https://i.loli.net/2021/06/17/rslg7tjBNFiCbvn.png" alt="14.png" /></p>
<h3 id="112-文件系统实现"><a class="markdownIt-Anchor" href="#112-文件系统实现"></a> 11.2 文件系统实现</h3>
<h4 id="1121概述"><a class="markdownIt-Anchor" href="#1121概述"></a> 11.2.1概述</h4>
<h5 id="在磁盘上"><a class="markdownIt-Anchor" href="#在磁盘上"></a> 在磁盘上</h5>
<ul>
<li>
<p><strong>引导控制块(Boot control block)</strong>：包含系统从该卷引导OS所需的信息</p>
<ul>
<li>如果为空，则磁盘不包含OS</li>
</ul>
</li>
<li>
<p><strong>卷控制块</strong>：包含卷（或分区）的详细信息</p>
</li>
<li>
<p><strong>目录结构</strong>用于组织文件</p>
</li>
<li>
<p>每个文件的<strong>FCB</strong>包含该文件的许多详细信息</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/WEJyu8fqKBCpoUs.png" alt="15.png" /></p>
<h5 id="在内存中"><a class="markdownIt-Anchor" href="#在内存中"></a> 在内存中</h5>
<p>内存中的信息用于管理文件系统并通过缓存来提高性能，<strong>这些数据在挂载文件系统时被加载，在卸载时被丢弃</strong></p>
<p><strong>结构类型</strong></p>
<ul>
<li>
<p>每个进程的文件打开表</p>
</li>
<li>
<p>整个系统的文件打开表</p>
</li>
<li>
<p>内存中的挂载表</p>
</li>
<li>
<p>内存中的目录结构的缓存</p>
</li>
</ul>
<p><strong>文件系统实现的操作结构</strong></p>
<p><img src="https://i.loli.net/2021/06/17/XMYJHfnkT79yVWp.png" alt="16.png" /></p>
<h4 id="1122-分区与安装"><a class="markdownIt-Anchor" href="#1122-分区与安装"></a> 11.2.2 分区与安装</h4>
<ul>
<li>
<p>引导信息通常是一系列连续的快，可作为映像加载到内存。</p>
</li>
<li>
<p>引导加载程序(boot loader)可以双重引导，允许具有多个FS和OS</p>
</li>
<li>
<p>根分区在启动时安装，其他卷可以在引导时自动安装或手动安装</p>
</li>
</ul>
<h4 id="1123-虚拟文件系统"><a class="markdownIt-Anchor" href="#1123-虚拟文件系统"></a> 11.2.3 虚拟文件系统</h4>
<ul>
<li>
<p>虚拟文件系统（VFS，虚拟文件系统）提供了面向对象的文件系统实现方式</p>
<p>VFS允许将相同的系统调用接口（API）用于不同类型的文件系统</p>
</li>
<li>
<p>该API是针对VFS接口的，而不是任何特定的文件系统的类型</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/65NILXb2mZTqiQn.png" alt="17.png" /></p>
<h3 id="113-目录实现"><a class="markdownIt-Anchor" href="#113-目录实现"></a> 11.3 目录实现</h3>
<h4 id="1131-线性序列"><a class="markdownIt-Anchor" href="#1131-线性序列"></a> 11.3.1 线性序列</h4>
<ul>
<li>易于编程</li>
<li>执行耗时</li>
</ul>
<h4 id="1132-哈希表"><a class="markdownIt-Anchor" href="#1132-哈希表"></a> 11.3.2 哈希表</h4>
<ul>
<li>减少目录搜索时间</li>
<li>产生冲突</li>
</ul>
<h3 id="114-分配方法"><a class="markdownIt-Anchor" href="#114-分配方法"></a> 11.4 分配方法</h3>
<h4 id="1141-连续分配"><a class="markdownIt-Anchor" href="#1141-连续分配"></a> 11.4.1 连续分配</h4>
<ul>
<li>每个文件的目录条目包括起始块的地址和文件所分配区域的长度</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/OsXf9QdTRlW2FiL.png" alt="18.png" /></p>
<p><strong>优点</strong></p>
<ul>
<li>支持随机访问和顺序访问</li>
<li>磁头移动时间短(寻道时间短)，访问速度快</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>外部碎片</li>
<li>需要事先知道文件的大小⇒文件可能无法扩展</li>
</ul>
<p><strong>解决方案：基于扩展的系统</strong></p>
<p>当空间不够时添加另一块连续空间(extent)，然后文件块的位置就记录为：地址、块数、下一扩展的首块的指针</p>
<h4 id="1142-链接linked分配"><a class="markdownIt-Anchor" href="#1142-链接linked分配"></a> 11.4.2 链接(Linked)分配</h4>
<p>每个文件都是磁盘块上的链表，块可能分散在磁盘的任何位置</p>
<h5 id="隐式链接"><a class="markdownIt-Anchor" href="#隐式链接"></a> 隐式链接</h5>
<p>目录包含文件第一块和最后一块的指针</p>
<p>每块都有下一块的一个指针</p>
<p><img src="https://i.loli.net/2021/06/17/kcXeFfhSzrGqACi.png" alt="19.png" /></p>
<p><strong>优点</strong></p>
<ul>
<li>
<p>简单——只需要起始地址</p>
</li>
<li>
<p>不会浪费空间，没有外部碎片</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>
<p>不能随机访问</p>
</li>
<li>
<p>指针需要额外空间</p>
</li>
</ul>
<p><strong>解决方案</strong></p>
<p>将多个块组成<strong>簇(cluster)</strong>，按<strong>簇</strong>分配</p>
<ul>
<li>提高磁盘吞吐量（更少的磁头移动）</li>
<li>但是内部碎片增加：如果一个簇没有完全使用，会浪费更多空间</li>
</ul>
<h5 id="显式链接"><a class="markdownIt-Anchor" href="#显式链接"></a> 显式链接</h5>
<p><strong>文件分配表(File-Allocation Table, FAT)</strong></p>
<p><strong>通过将磁盘中的寻指针操作，替换成缓存过的FAT放入内存中，提高性能</strong></p>
<p>每个卷的开始部分的磁盘用于存储<strong>FAT</strong></p>
<ul>
<li><strong>FAT</strong>的使用与链表相同，目录条目包含文件首块的块号。通过这个块号索引的表条目包含文件的下一块的块号</li>
<li>未使用的块用0作为表条目的值来表示</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/nVJdSH83hRmLxPv.png" alt="20.png" /></p>
<img src="https://i.loli.net/2021/06/17/4WVjd2Tw8DfJ3iv.png" alt="21.png" style="zoom:50%;" />
<h4 id="1143-索引分配"><a class="markdownIt-Anchor" href="#1143-索引分配"></a> 11.4.3 索引分配</h4>
<p>将所有指针放在一起——索引块</p>
<ul>
<li>每个文件都有自己的索引块</li>
<li>每个索引块都是一个磁盘块地址的数组</li>
</ul>
<p><img src="https://i.loli.net/2021/06/17/QpYSZFN6tW9gxHM.png" alt="22.png" /></p>
<p><strong>优点</strong></p>
<ul>
<li>
<p>随机访问</p>
</li>
<li>
<p>动态访问且无外部碎片</p>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>索引块的额外开销</li>
<li>文件大小的限制，索引块只能包含有限个数的指针</li>
</ul>
<p><strong>解决方案</strong></p>
<ol>
<li>
<p>链接方式</p>
<p>最后一个地址为null(对于小文件)，或者另一个索引块的指针(对于大文件)</p>
</li>
<li>
<p>多级索引</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/06/17/jQMPxa1eGy32KWp.png" alt="23.png" /></p>
<ol start="3">
<li>
<p>组合方式</p>
<p>将索引块的前几个指针指向<strong>直接块</strong>，接下来的几个指针指向<strong>间接块</strong>（一级、二级、三级逐级递增），这样的方式可以允许小文件直接访问</p>
</li>
</ol>
<h3 id="115-空闲空间管理"><a class="markdownIt-Anchor" href="#115-空闲空间管理"></a> 11.5 空闲空间管理</h3>
<p>为了跟踪空闲磁盘空间，系统需要维护一个<strong>空闲空间列表(free-space list)</strong></p>
<h4 id="1151-位向量bit-vector"><a class="markdownIt-Anchor" href="#1151-位向量bit-vector"></a> 11.5.1 位向量(bit vector)</h4>
<p>空闲空间列表按<strong>位图</strong>或<strong>位向量</strong>来实现，每块用一个位来表示。1表示空闲，0表示已分配</p>
<p>如2，3，4，5，8, 9, 10, 11是空闲的，则位图为</p>
<p>0011 1100 1111</p>
<p><strong>位图长度</strong></p>
<p>对于n个块，如果基本单位是word，则位图长度=（n + 15）/ 16</p>
<p><strong>第一个空闲块</strong></p>
<ol>
<li>
<p>找到第一个非0字</p>
</li>
<li>
<p>在第一个非0字中找到第一个1位</p>
</li>
<li>
<p>前K个字为0，第一个1位的偏移为L</p>
<p>N = K * 16 + L</p>
</li>
</ol>
<p><strong>特性</strong></p>
<ul>
<li>
<p>简单</p>
</li>
<li>
<p>必须保存在磁盘上</p>
</li>
<li>
<p>位图需要额外空间</p>
<h4 id="1152-链表"><a class="markdownIt-Anchor" href="#1152-链表"></a> 11.5.2 链表</h4>
</li>
</ul>
<p>将所有空闲磁盘块用链表链接起来</p>
<ul>
<li>将指向第一空闲块的指针保存在磁盘特殊位置上，并缓存在内存中</li>
<li>第一块包含下一个空闲磁盘块的指针</li>
</ul>
<p><strong>特性</strong></p>
<ul>
<li>无法轻易获得连续空间</li>
<li>不浪费空间</li>
</ul>
<h4 id="1153-计数"><a class="markdownIt-Anchor" href="#1153-计数"></a> 11.5.3 计数</h4>
<p>前提：通常，多个连续块可能需要同时分配获释放</p>
<ul>
<li>空闲空间列表的每个条目记录第一块的地址和紧跟第一块的连续空闲块的数量n</li>
<li>通常情况下比链表短，counter &gt; 1</li>
</ul>
<h3 id="116-效率与性能"><a class="markdownIt-Anchor" href="#116-效率与性能"></a> 11.6 效率与性能</h3>
<h4 id="1161-效率空间"><a class="markdownIt-Anchor" href="#1161-效率空间"></a> 11.6.1 效率（空间）</h4>
<p>磁盘空间的有效使用在很大程度上取决于磁盘分配和目录算法</p>
<p><strong>各种方法</strong></p>
<ul>
<li>不同的簇大小</li>
<li>保存在文件目录条目内的数据类型</li>
<li>用与访问数据的指针大小：大指针允许更大的文件，但需要使用更多磁盘空间</li>
</ul>
<h4 id="1162-性能时间"><a class="markdownIt-Anchor" href="#1162-性能时间"></a> 11.6.2 性能（时间）</h4>
<ul>
<li>
<p>磁盘缓存——在磁盘控制器上，一旦进入寻道，就从磁头所处的扇区开始将整个磁道读到磁盘缓存</p>
</li>
<li>
<p>缓冲区缓存(<strong>buffer cache</strong>)——假设其中的块会频繁访问</p>
</li>
<li>
<p>随后释放(<strong>free-behind</strong>)和预先读取(<strong>read-ahead</strong>)——一旦请求下一个页面，就从缓冲区删除一个页面；请求的页面和一些之后的页面可以一起读取并缓存</p>
</li>
<li>
<p>通过将一部分内存专用为虚拟磁盘或RAM磁盘来提高PC性能</p>
</li>
</ul>
<h3 id="117-恢复"><a class="markdownIt-Anchor" href="#117-恢复"></a> 11.7 恢复</h3>
<h4 id="1171-一致性检查"><a class="markdownIt-Anchor" href="#1171-一致性检查"></a> 11.7.1 一致性检查</h4>
<p>将目录结构中的数据与磁盘上的数据块进行比较，并尝试解决不一致问题</p>
<h4 id="1172-备份和恢复"><a class="markdownIt-Anchor" href="#1172-备份和恢复"></a> 11.7.2 备份和恢复</h4>
<p>备份：将数据从磁盘备份到另一存储设备</p>
<p>恢复：从备份还原数据来恢复丢失的文件或磁盘</p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>12.2 What problems could occur if a system allowed a file system to be<br />
mounted simultaneously at more than one location?</p>
<p>同一文件会有多个路径，删除一个路径下的文件的同时也会删除其他路径下的该文件。</p>
<p>12.3 Why must the bit map for file allocation be kept on mass storage, rather than in main memory?</p>
<p>这样在系统崩溃时，如果位图在主存中则可用空间列表会丢失，在大容量存储中则不会。</p>
<p>12.4 Consider a system that supports the strategies of contiguous, linked,<br />
and indexed allocation. What criteria should be used in deciding which<br />
strategy is best utilized for a particular file?</p>
<p>如果文件相对较小，则可以用连续的策略；如果文件相对较大，且为顺序访问，则可以用链接的策略；如果文件相对较大，且为随机访问，则可以用索引的策略</p>
<p>12.5 One problem with contiguous allocation is that the user must preallocate enough space for each file. If the file grows to be larger than the<br />
space allocated for it, special actions must be taken. One solution to this<br />
problem is to define a file structure consisting of an initial contiguous<br />
area (of a specified size). If this area is filled, the operating system<br />
automatically defines an overflow area that is linked to the initial<br />
contiguous area. If the overflow area is filled, another overflow area<br />
is allocated. Compare this implementation of a file with the standard<br />
contiguous and linked implementations.</p>
<p>与标准的连续策略来说，这种方法开销更大，因为需要动态分配额外的空间。但与链接策略比较，这种方法开销更小，因为起初就分配好了一些固定的空间。</p>
<p>12.6 How do caches help improve performance? Why do systems not use<br />
more or larger caches if they are so useful?</p>
<p>caches可以让不同速度的设备进行有效率的通信，它将传输速度更慢的设备中的数据缓存在更快的设备中。caches一般较为昂贵，caches的大小增加会增加系统成本。</p>
<p>12.7 Why is it advantageous to the user for an operating system to dynamically allocate its internal tables? What are the penalties to the operating system for doing so?</p>
<p>动态分配内部表在系统使用量增长时可以提供更大的灵活性，避免了用户的使用限制。但是这样的设计会使得内核的结构和代码更为复杂，也更容易出错。而且动态分配表比静态表开销更大。</p>
<p>12.9 Consider a file system that uses a modifed contiguous-allocation<br />
scheme with support for extents. A file is a collection of extents, with<br />
each extent corresponding to a contiguous set of blocks. A key issue in<br />
such systems is the degree of variability in the size of the extents. What<br />
are the advantages and disadvantages of the following schemes?<br />
a. All extents are of the same size, and the size is predetermined.<br />
b. Extents can be of any size and are allocated dynamically.<br />
c. Extents can be of a few fixed sizes, and these sizes are predetermined.</p>
<p>a. 分配方案简单，一个位图或者空闲列表就能解决分配的问题，缺点是会有内部碎片和外部碎片。</p>
<p>b. 优点是没有内部碎片，缺点是分配方案较为复杂，而且可能会有外部碎片生成。</p>
<p>c. 保证了分配的灵活性和较为简单，与a相比内部碎片较少，与b相比外部碎片较少，缺点是仍有内部和外部碎片。</p>
<p>12.10 Contrast the performance of the three techniques for allocating disk<br />
blocks (contiguous, linked, and indexed) for both sequential and<br />
random file access.</p>
<p>连续分配：每个文件占用一组磁盘块，同时支持顺序访问和随机访问，访问速度较快。但是它不能处理内部碎片和外部碎片，同时也难以增加大小。</p>
<p>链接分配：每个文件是一个磁盘块链表，支持顺序访问，但不支持随机访问。这种分配方法没有外部碎片，因为访问要沿指针访问，所以访问速度不如连续分配快。</p>
<p>索引分配：每个文件有自己的索引块。支持随机访问，不支持顺序访问。这种分配方法没有外部碎片。</p>
<p>12.11 What are the advantages of the variant of linked allocation that uses a<br />
FAT to chain together the blocks of a file?</p>
<p>如果需要访问存储在磁盘中的块的时候。我们可以不用再先访问磁盘块，然后一个一个遍历指针，而是可以通过将FAT放入内存中，通过在FAT中检索找到所需的块，再去磁盘中访问，大大提高了性能。</p>
<p>12.12 Consider a system where free space is kept in a free-space list.<br />
a. Suppose that the pointer to the free-space list is lost. Can the<br />
system reconstruct the free-space list? Explain your answer.</p>
<p>可以，可以执行垃圾收集来重建空闲列表。</p>
<p>b. Consider a file system similar to the one used by UNIX with<br />
indexed allocation. How many disk I/O operations might be<br />
required to read the contents of a small local file at /a/b/c?<br />
Assume that none of the disk blocks is currently being cached.</p>
<p>一共4个I/O操作，读目录a、b、c，读c中的文件</p>
<p>c. Suggest a scheme to ensure that the pointer is never lost as a result<br />
of memory failure.</p>
<p>将空闲空间列表的指针存放在磁盘上</p>
<p>12.14 Discuss how performance optimizations for file systems might result<br />
in difficulties in maintaining the consistency of the systems in the event<br />
of computer crashes.</p>
<p>可能出现的主要困难是数据和元数据的延迟更新。系统可以推迟更新，让将来更新相同的数据。但是，如果系统没有提交延迟更新请求就崩溃了，那么文件系统的一致性就会被破坏。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第13章 I/O系统</title>
    <url>/2020/12/19/OS/%E7%AC%AC13%E7%AB%A0%20%20IO%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="io系统"><a class="markdownIt-Anchor" href="#io系统"></a> I/O系统</h2>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<a id="more"></a>
<p>13.1 State three advantages of placing functionality in a device controller,<br />
rather than in the kernel. State three disadvantages.</p>
<p>优点：</p>
<ul>
<li>
<p>bug不会导致系统崩溃</p>
</li>
<li>
<p>内核部分更加简单</p>
</li>
<li>
<p>硬件算法效率更高</p>
</li>
</ul>
<p>缺点：</p>
<ul>
<li>bug不容易修复</li>
<li>很难更新</li>
<li>硬件算法可能无法适配所有软件算法</li>
</ul>
<p>13.3 Why might a system use interrupt-driven I/O to manage a single serial<br />
port and polling I/O to manage a front-end processor, such as a terminal<br />
concentrator?</p>
<p>中断集中器会产生很多的短I/O操作，当I/O频繁且持续时间短时，轮询比中断更高效。如果只有一个端口，I/O请求不频繁，终端更高效。</p>
<p>13.5 How does DMA increase system concurrency? How does it complicate<br />
hardware design?</p>
<p>DMA通过让CPU在工作的同时，通过自己的系统总线和内存总线传输数据，提高了并行性。DMA要放在系统中，而系统也要允许DMA使用总线，使得硬件设计变得复杂。</p>
<p>13.8 When multiple interrupts from different devices appear at about the<br />
same time, a priority scheme could be used to determine the order in<br />
which the interrupts would be serviced. Discuss what issues need to<br />
be considered in assigning priorities to different interrupts.</p>
<p>硬件产生的中断要比软件产生的陷阱引起的中断具有更高的优先级。控制设备的中断应该有更高的优先级。有时间限制的中断应该有更高的优先级。</p>
<p>13.9 What are the advantages and disadvantages of supporting memory mapped<br />
I/O to device control registers?</p>
<p>优点：这种I/O不需要特殊的I/O指令集</p>
<p>缺点：需要保证用户程序不能访问设备控制寄存器</p>
<p>13.11 In most multiprogrammed systems, user programs access memory<br />
through virtual addresses, while the operating system uses raw physical<br />
addresses to access memory. What are the implications of this<br />
design for the initiation of I/O operations by the user program and<br />
their execution by the operating system?</p>
<p>用户程序的I/O操作会请求一片内存空间作为缓存，内核会将数据从用户程序的缓存区拷贝到内核空间中的缓存区。在软件的帮助下，内核在用户程序的虚拟地址空间的上下文中将虚拟地址转换为相应的物理地址来访问用户缓冲区。</p>
<p>13.12 What are the various kinds of performance overhead associated with<br />
servicing an interrupt?</p>
<p>上下文切换的开销、保存和恢复指令的开销</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第1章 导论</title>
    <url>/2020/09/24/OS/%E7%AC%AC1%E7%AB%A0%20%E5%AF%BC%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第1章-导论"><a class="markdownIt-Anchor" href="#第1章-导论"></a> 第1章 导论</h2>
<h3 id="操作系统"><a class="markdownIt-Anchor" href="#操作系统"></a> 操作系统</h3>
<h4 id="什么是操作系统"><a class="markdownIt-Anchor" href="#什么是操作系统"></a> 什么是操作系统</h4>
<a id="more"></a>
<ul>
<li>管理计算机硬件、为应用程序提供基础、作为用户和计算机硬件的中介的程序</li>
<li>管理和分配资源、为了有效和公平的使用资源在冲突请求之间做出决定的资源分配器</li>
<li>控制程序执行，以防止错误和错误使用计算机和控制IO设备操作的控制程序</li>
</ul>
<p><strong>操作系统是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户的程序的集合</strong></p>
<h4 id="多路批处理系统"><a class="markdownIt-Anchor" href="#多路批处理系统"></a> 多路批处理系统</h4>
<ul>
<li>两个/两个或更多作业同时进入主存储器</li>
<li>在宏观操作状态</li>
<li>共享所有系统资源</li>
</ul>
<h4 id="分时系统"><a class="markdownIt-Anchor" href="#分时系统"></a> 分时系统</h4>
<ul>
<li>
<p>多终端单主机</p>
</li>
<li>
<p>提供用户与系统之间的在线通信； 当操作系统完成一个命令的执行时，它不是从读卡器而是从用户的键盘中查找下一个“控制语句”。</p>
</li>
<li>
<p>在线系统必须可供用户访问数据和代码。</p>
</li>
</ul>
<h4 id="专用系统"><a class="markdownIt-Anchor" href="#专用系统"></a> 专用系统</h4>
<p>​	通常在专用应用中用作控制设备</p>
<ul>
<li>严格的时间限制</li>
</ul>
<h4 id="pc-系统"><a class="markdownIt-Anchor" href="#pc-系统"></a> PC 系统</h4>
<ul>
<li>个人独占计算机不需要高级CPU保护技术</li>
</ul>
<h4 id="并行系统"><a class="markdownIt-Anchor" href="#并行系统"></a> 并行系统</h4>
<ul>
<li>紧密耦合系统-处理器共享内存和时钟；通信通常通过共享内存进行</li>
</ul>
<h4 id="分布式系统"><a class="markdownIt-Anchor" href="#分布式系统"></a> 分布式系统</h4>
<ul>
<li>在几个物理处理器之间分配计算。</li>
<li>松耦合系统–每个处理器都有自己的本地内存； 处理器通过各种通信线路（例如高速总线或电话线）相互通信。</li>
</ul>
<h3 id="硬件功能"><a class="markdownIt-Anchor" href="#硬件功能"></a> 硬件功能</h3>
<h4 id="特权指令"><a class="markdownIt-Anchor" href="#特权指令"></a> 特权指令</h4>
<ul>
<li>
<p>访问某些禁止用户程序直接访问的硬件资源的指令</p>
</li>
<li>
<p>直接访问I / O设备（例如磁盘，打印机等）的指令</p>
</li>
<li>
<p>用于操作内存管理状态的指令（页表指针，刷新TLB等）</p>
</li>
<li>
<p>一些特殊状态位的设置指令</p>
</li>
<li>
<p>HLT(停机指令)</p>
</li>
</ul>
<h4 id="处理器状态"><a class="markdownIt-Anchor" href="#处理器状态"></a> 处理器状态</h4>
<ul>
<li>kernel mode / user mode</li>
</ul>
<h5 id="pswprogram-status-word"><a class="markdownIt-Anchor" href="#pswprogram-status-word"></a> PSW(Program Status Word)</h5>
<ul>
<li>用来指示处理器的状态</li>
</ul>
<h4 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h4>
<ul>
<li>CPU执行访管指令、引起访管中断</li>
<li>处理器保存中断点的程序执行上下文环境，CPU切换到管态</li>
<li>中断处理程序开始工作，调用相应的系统服务</li>
<li>中断处理结束后，恢复被中断程序的上下文环境，CPU恢复为目态，回到中断点继续执行</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p><strong>1.1</strong> What are the three main purposes of an operating system?</p>
<ul>
<li>提供一个用户可以运行程序的环境</li>
<li>提高软硬件资源的利用率</li>
<li>作为控制系统
<ul>
<li>监督用户程序的执行，以防止错误和不当使用</li>
<li>操作和控制管理I/O设备</li>
</ul>
</li>
</ul>
<p><strong>1.2</strong> We have stressed the need for an operating system to make efficient use of the computing hardware. When is it appropriate for the operating<br />
system to forsake this principle and to “waste” resources? Why is such a system not really wasteful?</p>
<p>​	    如果用户更注重交互性的话，可以通过放弃这样的原则，浪费一些对于硬件计算的利用，提升用户的体验。这样的系统并不是真的浪费，而是能得到更好的用户反馈，达到为用户服务的目的。</p>
<p><strong>1.3</strong> What is the main difficulty that a programmer must overcome in writing an operating system for a real-time environment?</p>
<p>实时系统需要严格的时间限制，所以最主要的困难就是让操作系统有严格的时间限制。</p>
<p><strong>1.4</strong> Keeping in mind the various definitions of operating system, consider<br />
whether the operating system should include applications such as web<br />
browsers and mail programs. Argue both that it should and that it should not, and support your answers.</p>
<p>不应该有：</p>
<ul>
<li>应用程序是应用程序，而不是操作系统的一部分</li>
<li>在内核中运行的任何性能优势都被安全漏洞所抵消</li>
<li>这会导致操作系统臃肿</li>
</ul>
<p>应该有：</p>
<ul>
<li>它可能会更好地利用内核中的功能，因此比运行在内核之外的应用程序具有性能优势</li>
</ul>
<p><strong>1.5</strong> How does the distinction between kernel mode and user mode function as a rudimentary form of protection (security) system?</p>
<pre><code>	把重要的指令设置为只有Kernel Mode时才可调用，只给User Mode较少的权限，可以提高系统安全性。
</code></pre>
<p><strong>1.6</strong> Which of the following instructions should be privileged?<br />
a. Set value of timer. (Kernel Mode)<br />
b. Read the clock. (User Mode)<br />
c. Clear memory. (Kernel Mode)<br />
d. Issue a trap instruction. (User Mode)<br />
e. Turn off interrupts. (Kernel Mode)<br />
f. Modify entries in device-status table. (Kernel Mode)<br />
g. Switch from user to kernel mode. (User Mode)<br />
h. Access I/O device. (Kernel Mode)</p>
<p><strong>1.7</strong> Some early computers protected the operating system by placing it in a memory partition that could not be modified by either the user job or the operating system itself. Describe two difficulties that you think could arise with such a scheme.</p>
<p>① 操作系统无法更新、出错时也无法修改</p>
<p>② 用户的数据无法存储在被保护的内存中，有安全隐患</p>
<p><strong>1.12</strong> In a multiprogramming and time-sharing environment, several users share the system simultaneously. This situation can result in various security problems.</p>
<p>​		a. What are two such problems?</p>
<p>​			①使用系统资源没有合适的记账</p>
<p>​			②彼此的操作可能会影响彼此的程序或数据</p>
<p>​		b. Can we ensure the same degree of security in a time-shared machine as in a dedicated machine? Explain your answer.</p>
<p>​			不能，一个用户的数据可能被会受另一个用户的影响，而这种影响在根本上是无法解决的，所以安全性得不到像专用机一样的很好的保证。</p>
<p><strong>1.13</strong> The issue of resource utilization shows up in different forms in different types of operating systems. List what resources must be managed carefully in the following settings:</p>
<p>​		a. Mainframe or minicomputer systems</p>
<p>​				CPU， 内存， 外存</p>
<p>​		b. Workstations connected to servers</p>
<p>​				网络， CPU， 内存</p>
<p>​		c. Mobile computers</p>
<pre><code>			功率，用户体验
</code></pre>
<p><strong>1.14</strong> Under what circumstances would a user be better off using a timesharing system than a PC or a single-user workstation?</p>
<ul>
<li>当其他用户很少时，任务大，硬件速度快，分时就有意义了</li>
</ul>
<p><strong>1.19</strong> What is the purpose of interrupts? How does an interrupt differ from a trap? Can traps be generated intentionally by a user program? If so, for what purpose?</p>
<pre><code>	为了在现有任务可能没执行完时执行一个新的任务。陷阱是软件产生的，中断是由硬件产生的。用户可以有意地产生陷阱，用来调用操作系统的例程或者捕获算术错误。
</code></pre>
<p><strong>1.21</strong> Some computer systems do not provide a privileged mode of operation in hardware. Is it possible to construct a secure operating system for these computer systems? Give arguments both that it is and that it is not possible.</p>
<p>可以：</p>
<ul>
<li>
<p>一种方法是为双模处理器（一种具有特权模式的处理器）编写一个模拟器，并在这个模拟器上运行操作系统。</p>
</li>
<li>
<p>执行用安全语言（如Java）编写的用户程序才能工作执行用安全语言（如Java）编写的用户程序才能工作</p>
</li>
</ul>
<p>不可以：</p>
<ul>
<li>如果不牺牲功能性，任由用户程序调用特权指令，会对系统安全构成很大的威胁</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第2章 操作系统结构</title>
    <url>/2020/09/26/OS/%E7%AC%AC2%E7%AB%A0%20%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第2章-操作系统结构"><a class="markdownIt-Anchor" href="#第2章-操作系统结构"></a> 第2章 操作系统结构</h2>
<h3 id="系统组件"><a class="markdownIt-Anchor" href="#系统组件"></a> 系统组件</h3>
<h4 id="进程管理"><a class="markdownIt-Anchor" href="#进程管理"></a> 进程管理</h4>
<a id="more"></a>
<ul>
<li>创建/销毁流程</li>
<li>进程状态转移</li>
</ul>
<h4 id="主存管理"><a class="markdownIt-Anchor" href="#主存管理"></a> 主存管理</h4>
<ul>
<li>CPU和I / O设备共享的快速访问数据的存储库</li>
<li>易失性存储设备</li>
<li>跟踪内存使用情况</li>
<li>确定何时有可用的内存空间来加载哪些进程</li>
<li>分配和释放内存空间</li>
</ul>
<h4 id="io-系统管理"><a class="markdownIt-Anchor" href="#io-系统管理"></a> I/O 系统管理</h4>
<p>由缓冲，缓存和假脱机、通用设备驱动程序接口、特定硬件设备的驱动程序组成</p>
<h4 id="文件管理系统"><a class="markdownIt-Anchor" href="#文件管理系统"></a> 文件管理系统</h4>
<ul>
<li>将文件映射到辅助存储</li>
<li>稳定（非易失性）存储介质上的文件备份（备份）</li>
</ul>
<h4 id="辅存管理"><a class="markdownIt-Anchor" href="#辅存管理"></a> 辅存管理</h4>
<ul>
<li>自由空间管理</li>
<li>存储分配</li>
<li>磁盘调度</li>
</ul>
<h4 id="保护系统"><a class="markdownIt-Anchor" href="#保护系统"></a> 保护系统</h4>
<ul>
<li>用于控制程序，进程或用户对系统和用户资源的访问的机制</li>
</ul>
<h3 id="操作系统服务"><a class="markdownIt-Anchor" href="#操作系统服务"></a> 操作系统服务</h3>
<ul>
<li>接口：UI、CLI、GUI</li>
<li>通信–进程可以在同一台计算机上或通过网络在计算机之间交换信息</li>
<li>错误检测–操作系统需要不断意识到可能的错误</li>
<li>资源分配-当多个用户或多个作业同时运行时，必须为每个用户分配资源</li>
<li>记帐-跟踪哪些用户使用多少计算机资源</li>
<li>保护和安全-存储在多用户或网络计算机系统中的信息的所有者可能希望控制该信息的使用，并发进程不应相互干扰</li>
</ul>
<h3 id="系统调用"><a class="markdownIt-Anchor" href="#系统调用"></a> 系统调用</h3>
<ul>
<li>操作系统提供的程序接口服务，通常由API访问，而不是直接使用系统调用</li>
<li>系统调用接口调用OS内核中的预期系统调用，并返回系统调用的状态和所有返回值</li>
</ul>
<p><img src="https://i.loli.net/2020/09/24/jFiYo6rxSVZsE4P.png" alt="image-20200924102332537.png" /></p>
<h4 id="系统调用参数传递"><a class="markdownIt-Anchor" href="#系统调用参数传递"></a> 系统调用参数传递</h4>
<p>三种用于将参数传递给的方法</p>
<ul>
<li>在寄存器中传递参数</li>
<li>存储在内存的块或表中的参数，块或表的地址通过寄存器来传递</li>
<li>程序将参数放置或推入堆栈，然后操作系统将其弹出堆栈
<ul>
<li>块和堆栈方法不限制要传递的参数的数量或长度</li>
</ul>
</li>
</ul>
<h4 id="系统调用的种类"><a class="markdownIt-Anchor" href="#系统调用的种类"></a> 系统调用的种类</h4>
<ul>
<li>进程控制</li>
<li>文件管理</li>
<li>设备管理</li>
<li>信息维护</li>
<li>通信</li>
<li>保护</li>
</ul>
<h3 id="操作系统设计与实现"><a class="markdownIt-Anchor" href="#操作系统设计与实现"></a> 操作系统设计与实现</h3>
<ul>
<li>设计操作系统的第一个问题是定义目标（target）和规格（spec）requirement（需求）</li>
<li>机制决定如何来做</li>
<li>策略决定做什么</li>
</ul>
<h3 id="操作系统结构"><a class="markdownIt-Anchor" href="#操作系统结构"></a> 操作系统结构</h3>
<h4 id="简单结构"><a class="markdownIt-Anchor" href="#简单结构"></a> 简单结构</h4>
<ul>
<li>没有清晰的体系结构</li>
<li>操作系统功能模块和用户应用程序混杂在一起，在同一个地址空间上运行，模块之间可以相互任意调用</li>
</ul>
<h4 id="单一内核结构monolithic-structure"><a class="markdownIt-Anchor" href="#单一内核结构monolithic-structure"></a> 单一内核结构(Monolithic structure)</h4>
<ul>
<li>用户应用只能通过中断/异常/系统调用的方式使用操作系统提供的服务</li>
<li>用户应用程序之间通过各种IPC(Inter-Process Communication)进行通信</li>
</ul>
<p>缺点：难以实现和维护</p>
<h4 id="模块化设计modular-kernel"><a class="markdownIt-Anchor" href="#模块化设计modular-kernel"></a> 模块化设计(Modular kernel)</h4>
<ul>
<li>模块之间定义了很好的以函数调用的形式提供的结构</li>
<li>在一定程度上提高了操作系统的可维护性</li>
</ul>
<p><img src="https://i.loli.net/2020/09/24/pLN6nMZwfTE4Vzr.png" alt="image-20200924111537520.png" /></p>
<h4 id="层次结构layered-approach"><a class="markdownIt-Anchor" href="#层次结构layered-approach"></a> 层次结构(Layered approach)</h4>
<ul>
<li>为减少OS各模块之间紧密依赖和相互调用的关系，特别是消除循环调用现象，实现有序调用</li>
<li>每个层只能使用较低层提供的操作，并向较高层提供某些操作</li>
<li>每个层都从较高层隐藏某些数据结构，操作和硬件的存在</li>
</ul>
<p>优点：构造和调试简单<br />
缺点：适当定义各层、效率较低</p>
<h4 id="微内核结构microkernel-structure"><a class="markdownIt-Anchor" href="#微内核结构microkernel-structure"></a> 微内核结构(Microkernel Structure)</h4>
<ul>
<li>较小的内核</li>
<li>提供最少的过程和内存管理</li>
</ul>
<p>优点：可扩展性、可移植性、安全性和可靠性</p>
<p>缺点：因系统功能开销增加导致的性能下降</p>
<h4 id="混合内核hybrid-structure"><a class="markdownIt-Anchor" href="#混合内核hybrid-structure"></a> 混合内核(Hybrid structure)</h4>
<ul>
<li>扩大微内核并把一些关键的服务程序和驱动程序重新加入到内核中</li>
<li>其中一层由微内核组成的分层技术</li>
</ul>
<p><img src="https://i.loli.net/2020/09/24/69icoJ4yFnbRVO2.png" alt="image-20200924120019746.png" /></p>
<h3 id="虚拟机"><a class="markdownIt-Anchor" href="#虚拟机"></a> 虚拟机</h3>
<ul>
<li>
<p>虚拟机采用层次结构得出其逻辑结论。</p>
<ul>
<li>它将硬件和OS内核视为全部硬件</li>
<li>虚拟机提供的接口与基础裸机相同</li>
</ul>
</li>
<li>
<p>操作系统产生了多个进程的错觉，每个进程都在具有自己（虚拟）内存的处理器上执行</p>
</li>
<li>
<p>共享物理计算机的资源以创建虚拟机</p>
</li>
<li>
<p>虚拟机管理器将单个计算机接口转换为多个虚拟机，每个虚拟机是原始计算机系统的有效副本，并执行所有处理器指令</p>
</li>
</ul>
<p><img src="https://i.loli.net/2020/09/24/lj3XnAK2VoO8Y6C.png" alt="image-20200924120623789.png" /></p>
<h3 id="概念"><a class="markdownIt-Anchor" href="#概念"></a> 概念</h3>
<ol>
<li>并发</li>
</ol>
<p>并行 vs. 并发:</p>
<ul>
<li>
<p>并行是指两或多个事件在同一时刻发生</p>
</li>
<li>
<p>并发是两或多个事件在同一时间间隔内发生</p>
</li>
</ul>
<ol start="2">
<li>Program vs. Process(进程)</li>
</ol>
<p>Program：静态实体<br />
Process：  动态实体</p>
<ul>
<li>A program in execution.</li>
<li>是系统中能独立运行并作为资源分配的基本单位。</li>
<li>引入线程后，独立运行的单位变为线程。</li>
</ul>
<ol start="3">
<li>共享</li>
</ol>
<ul>
<li>可供内存中多个并发执行的进程共同使用的系统中资源</li>
<li>互斥共享VS. 同时访问
<ul>
<li>互斥共享：一段时间只允许一个进程访问该资源</li>
<li>同时访问：微观上仍是互斥的</li>
<li>临界资源：在一段时间内只允许一个进程访问的资源</li>
</ul>
</li>
</ul>
<ol start="4">
<li>
<p>虚拟</p>
<ul>
<li>虚拟：通过某种技术把一个物理实体变为若干个逻辑上的对应物。</li>
<li>若n是某一物理设备所对应的虚拟的逻辑设备数，则虚拟设备的速度必然是物理设备速度的1/n。</li>
</ul>
</li>
</ol>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p><strong>2.1</strong> What is the purpose of system calls?</p>
<p>​		系统调用是操作系统提供的程序接口服务。系统调用是从user mode进入kernel mode的唯一方法。使用系统调用时,操作系统为正在运行的应用程序提供资源或操作</p>
<p><strong>2.5</strong> What is the purpose of the command interpreter? Why is it usually<br />
separate from the kernel?</p>
<p>​        获取并执行用户指定的下一条命令。命令解释程序会执行相应的系统调用，因此如果不和kernel分离，会有可能改变kernel部分，这是不安全的。</p>
<p><strong>2.8</strong> What is the main advantage of the layered approach to system design?<br />
What are the disadvantages of the layered approach?</p>
<p>​		优点是构造和调试简单，缺点是难以适当定义各层，以及逐层调用效率较低。</p>
<p><strong>2.12</strong> The services and functions provided by an operating system can be<br />
divided into two main categories. Briefly describe the two categories,<br />
and discuss how they differ.</p>
<p>第一组服务用于提供用户功能，提供以下功能：</p>
<ul>
<li>
<p>用户界面</p>
</li>
<li>
<p>程序执行</p>
</li>
<li>
<p>I/O操作</p>
</li>
<li>
<p>文件系统操作</p>
</li>
<li>
<p>通信</p>
</li>
<li>
<p>错误检测</p>
</li>
</ul>
<p>第二组操作系统服务为了确保系统本身运行高效，提供以下功能：</p>
<ul>
<li>资源分配</li>
<li>记账</li>
<li>保护与安全</li>
</ul>
<p><strong>2.13</strong> Describe three general methods for passing parameters to the operating<br />
system.</p>
<ul>
<li>在寄存器中传递参数</li>
<li>存储在内存的块或表中的参数，块或表的地址通过寄存器来传递</li>
<li>程序将参数压入堆栈，并通过操作系统弹出</li>
</ul>
<p><strong>2.16</strong> What are the advantages and disadvantages of using the same systemcall<br />
interface for manipulating both files and devices?</p>
<p>优点：减少接口数量，文件和设备能用一个接口调用，使操作系统更简洁。</p>
<p>缺点：文件和设备的相应操作不能完全对应，如果要将这些操作强行合并，那么其中之一可能要更改操作逻辑，使其与另一个操作类似。为用户调用接口时对接口实施操作的理解带来麻烦，得不偿失。</p>
<p><strong>2.17</strong> Would it be possible for the user to develop a new command interpreter<br />
using the system-call interface provided by the operating system?</p>
<p>​		可以，任何用户都可以创建一个新的命令解释程序。</p>
<p><strong>2.19</strong> Why is the separation of mechanism and policy desirable?</p>
<p>​		机制与策略的分离可以使系统更灵活，更容易修改。系统设计者可以创建不变的机制和根据具体需求改变的策略。</p>
<p><strong>2.21</strong> What is the main advantage of the microkernel approach to system<br />
design? How do user programs and system services interact in a<br />
microkernel architecture? What are the disadvantages of using the<br />
microkernel approach?</p>
<p>​		优点：可扩展性、可移植性、安全性、可靠性。微内核为用户端程序和运行在用户空间中的各种服务提供通信。通信使通过消息传递来提供的，客户程序和系统服务通过内核的消息传递来间接通信。缺点：增加了系统功能开销，导致微内核性能的下降。</p>
<p>​</p>
<p><strong>2.22</strong> What are the advantages of using loadable kernel modules?</p>
<p>​		不需要将新功能的实现添加到内核中，内核提供核心服务，其他服务在内核运行时动态实现，更加灵活。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第3章 进程</title>
    <url>/2020/10/04/OS/%E7%AC%AC3%E7%AB%A0%20%20%E8%BF%9B%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第3章-进程"><a class="markdownIt-Anchor" href="#第3章-进程"></a> 第3章 进程</h2>
<h3 id="多道程序技术"><a class="markdownIt-Anchor" href="#多道程序技术"></a> 多道程序技术</h3>
<h4 id="程序顺序执行时的特征"><a class="markdownIt-Anchor" href="#程序顺序执行时的特征"></a> 程序顺序执行时的特征</h4>
<a id="more"></a>
<ul>
<li>顺序性</li>
<li>封闭性</li>
<li>可再现性</li>
</ul>
<h3 id="进程概念"><a class="markdownIt-Anchor" href="#进程概念"></a> 进程概念</h3>
<ul>
<li>进程 = 程序段 + 数据段 + 进程控制块(PCB)</li>
</ul>
<h4 id="进程状态"><a class="markdownIt-Anchor" href="#进程状态"></a> 进程状态</h4>
<ul>
<li>new</li>
<li>running</li>
<li>waiting/blocked</li>
<li>ready</li>
<li>terminated</li>
</ul>
<h4 id="进程挂起"><a class="markdownIt-Anchor" href="#进程挂起"></a> 进程挂起</h4>
<p><img src="https://i.loli.net/2020/10/03/gEfw2RQKFs3qyx6.png" alt="image-20201003195825977.png" /></p>
<h4 id="进程控制块pcb"><a class="markdownIt-Anchor" href="#进程控制块pcb"></a> 进程控制块(PCB)</h4>
<ul>
<li>是操作系统中的一种关键数据结构</li>
<li>由操作系统进程管理模块维护</li>
<li>常驻内存</li>
</ul>
<p><img src="https://i.loli.net/2020/10/03/v1OCF5mylPsGShQ.png" alt="image-20201003200305684.png" /></p>
<p><img src="https://i.loli.net/2020/10/03/3dhoUWXRJGe1fBm.png" alt="image-20201003200325408.png" /></p>
<h3 id="进程调度"><a class="markdownIt-Anchor" href="#进程调度"></a> 进程调度</h3>
<ul>
<li>ready queue——内存中准备和等待执行</li>
<li>device queue——等待I / O设备的进程集</li>
</ul>
<p><img src="D:%5Cstudy%5C%E5%A4%A7%E4%BA%8C%5C%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%5CNotes%5Cimages%5Cimage-20201003200657117.png" alt="image-20201003200657117" /></p>
<h4 id="调度器"><a class="markdownIt-Anchor" href="#调度器"></a> 调度器</h4>
<ul>
<li>Long-term scheduler选择应将哪些进程带入ready queue</li>
<li>Short-term scheduler选择CPU执行哪个进程
<ul>
<li>从ready queue</li>
<li>频度高</li>
</ul>
</li>
<li>Medium-term scheduler
<ul>
<li>可以降低多道程序运行的度（与Long-term scheduler相反）</li>
</ul>
</li>
</ul>
<h4 id="上下文切换"><a class="markdownIt-Anchor" href="#上下文切换"></a> 上下文切换</h4>
<ul>
<li>当进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文</li>
</ul>
<h3 id="进程操作"><a class="markdownIt-Anchor" href="#进程操作"></a> 进程操作</h3>
<h4 id="进程创建"><a class="markdownIt-Anchor" href="#进程创建"></a> 进程创建</h4>
<ul>
<li>通常，进程是通过进程标识符(pid)标志和管理的</li>
</ul>
<h5 id="资源共享"><a class="markdownIt-Anchor" href="#资源共享"></a> 资源共享</h5>
<p>当一个进程创建子进程时，有三种共享方式:</p>
<ul>
<li>父子共享全部资源</li>
<li>孩子享有部分资源</li>
<li>父子不共享资源</li>
</ul>
<h5 id="运行"><a class="markdownIt-Anchor" href="#运行"></a> 运行</h5>
<ul>
<li>
<p>父子并发执行</p>
</li>
<li>
<p>父进程必须等子进程结束</p>
</li>
<li>
<p>子进程复制父进程的空间</p>
</li>
</ul>
<h3 id="进程间通信ipc"><a class="markdownIt-Anchor" href="#进程间通信ipc"></a> 进程间通信（IPC）</h3>
<p>优点：</p>
<ul>
<li>信息共享：共享文件  VS 几个用户</li>
<li>计算速度提高：1任务  VS 与多个处理元素（例如CPU或I / O通道）并行的几个子任务</li>
<li>模块化</li>
<li>便利：1个用户  VS 几个任务</li>
</ul>
<h4 id="ipc的两个基础模式"><a class="markdownIt-Anchor" href="#ipc的两个基础模式"></a> IPC的两个基础模式</h4>
<h5 id="消息传递模式"><a class="markdownIt-Anchor" href="#消息传递模式"></a> 消息传递模式</h5>
<ul>
<li>可用于交换少量数据，因为无需避免冲突</li>
<li>更容易实施</li>
<li>通过系统调用（例如send（），receive（））交换信息</li>
</ul>
<h5 id="共享内存模式"><a class="markdownIt-Anchor" href="#共享内存模式"></a> 共享内存模式</h5>
<ul>
<li>通过内存访问有更快的内存速度</li>
<li>系统调用仅用于建立共享内存区域</li>
</ul>
<p><img src="https://i.loli.net/2020/10/03/6P7caQsfzDOUySh.png" alt="image-20201003202940281.png" /></p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>3.1 Using the program shown in Figure 3.30, explain what the output will<br />
be at LINE A.</p>
<p><img src="https://i.loli.net/2020/10/04/zX2KsqfngIwNPaO.png" alt="image-20201004120745412.png" /></p>
<p>PARENT: value = 5</p>
<p>因为fork()会创建一个子进程，子进程会复制父进程的代码、全局变量、堆栈等，所以在子进程中对变量的修改影响不到父进程。</p>
<p>3.2 Including the initial parent process, how many processes are created by the program shown in Figure 3.31?</p>
<p><img src="https://i.loli.net/2020/10/04/POQlMDoAxaBeCiS.png" alt="image-20201004114833943.png" /></p>
<p>一共8个，第一个fork()后复制父进程，共有2个进程；第二个fork()后复制前两个进程，共四个进程；依次类推，一共8个。</p>
<p>3.5 When a process creates a new process using the fork() operation, which of the following states is shared between the parent process and the child<br />
process?<br />
a. Stack<br />
b. Heap<br />
c. Shared memory segments</p>
<p>c</p>
<p>3.8 Describe the differences among short-term, medium-term, and long-term scheduling.</p>
<p>短期调度器：从准备队列中选择进程分配到CPU中执行，运行频率高</p>
<p>中期调度器：将部分进程从内存中移出，降低多道程序程度</p>
<p>长期调度器：选择将哪些进程带入准备队列，运行频率低</p>
<p>3.9 Describe the actions taken by a kernel to context-switch between<br />
processes.</p>
<p>kernel保存正在运行的进程的状态到它的PCB中，并加载经调度而要执行的新进程的上下文。</p>
<p>3.11 Explain the role of the init process on UNIX and Linux systems in regard to process termination.</p>
<p>UNIX和Linux将init进程作为孤儿进程的父进程。进程init定期调用wait()，以便收集任何孤儿进程的退出状态，并释放孤儿进程标识符和进程表条目</p>
<p>3.12 Including the initial parent process, how many processes are created by the program shown in Figure 3.32?</p>
<p><img src="https://i.loli.net/2020/10/04/DWY3XBUQ2jLNzoq.png" alt="image-20201004114857480.png" /></p>
<p>一共16个，第一次fork()后复制父进程，共有2个进程；第二次fork()后复制前两个进程，共四个进程；依次类推，共fork()四次，一共16个。</p>
<p>3.13 Explain the circumstances under which which the line of code marked<br />
printf(“LINE J”) in Figure 3.33 will be reached.</p>
<p><img src="https://i.loli.net/2020/10/04/1Q2XhVRf86jxYOe.png" alt="image-20201004195716479.png" /></p>
<p>当execlp()的调用发生错误时</p>
<p>3.14 Using the program in Figure 3.34, identify the values of pid at lines A, B, C, and D. (Assume that the actual pids of the parent and child are 2600<br />
and 2603, respectively.)</p>
<p><img src="https://i.loli.net/2020/10/04/h1afI3uKD5dpNA9.png" alt="image-20201004114933324.png" /></p>
<p>A = 0, B = 2603, C = 2603, D = 2600</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第4章 线程</title>
    <url>/2020/10/10/OS/%E7%AC%AC4%E7%AB%A0%20%E7%BA%BF%E7%A8%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
<ul>
<li>线程是CPU利用的基本单位</li>
</ul>
<a id="more"></a>
<ul>
<li>它包含一个线程ID，一个程序计数器，一个寄存器集和一个堆栈<br />
它与属于同一进程的其他线程，代码部分，数据部分和其他OS资源（例如打开的文件，信号等）共享</li>
</ul>
<img src="https://i.loli.net/2020/10/23/A5bLvzJX6sPEdCO.png" alt="image-20201011095455371.png" style="zoom:50%;" />
<h4 id="进程与线程的比较"><a class="markdownIt-Anchor" href="#进程与线程的比较"></a> 进程与线程的比较</h4>
<ul>
<li>进程是资源分配单位，线程是CPU分配单位</li>
<li>进程拥有一个完整的资源平台，而进程只独享必不可少的资源，如寄存器和栈</li>
<li>线程同样具有就绪、阻塞和执行三种状态，同样具有状态之间的转换关系</li>
<li>线程能减少并发执行的时间和空间开销</li>
<li>线程 = 轻量级进程</li>
</ul>
<h4 id="优点"><a class="markdownIt-Anchor" href="#优点"></a> 优点</h4>
<ul>
<li>
<p>响应度高</p>
</li>
<li>
<p>资源共享</p>
</li>
<li>
<p>经济</p>
</li>
<li>
<p>MP结构的利用</p>
<p>​	并发和并行</p>
</li>
</ul>
<h3 id="多线程模型"><a class="markdownIt-Anchor" href="#多线程模型"></a> 多线程模型</h3>
<h4 id="多对一模型"><a class="markdownIt-Anchor" href="#多对一模型"></a> 多对一模型</h4>
<img src="https://i.loli.net/2020/10/23/Q5hWvgyc41rLVZU.png" alt="image-20201011095958114.png" style="zoom:50%;" />
<h4 id="一对一模型"><a class="markdownIt-Anchor" href="#一对一模型"></a> 一对一模型</h4>
<img src="https://i.loli.net/2020/10/23/sjuRIC3W8iVLYgO.png" alt="image-20201011100009095.png" style="zoom:50%;" />
<h4 id="多对多模型"><a class="markdownIt-Anchor" href="#多对多模型"></a> 多对多模型</h4>
<img src="https://i.loli.net/2020/10/23/QqAYf8TFyhl6c1K.png" alt="image-20201011100019172.png" style="zoom:50%;" />
<h4 id="双层模型"><a class="markdownIt-Anchor" href="#双层模型"></a> 双层模型</h4>
<img src="https://i.loli.net/2020/10/23/T3qniP86VYKZGCe.png" alt="image-20201011100025612.png" style="zoom:50%;" />
<h3 id="线程问题"><a class="markdownIt-Anchor" href="#线程问题"></a> 线程问题</h3>
<ul>
<li>fork（）和exec（）系统调用的语义</li>
<li>fork（）是否仅复制调用线程或所有线程？</li>
</ul>
<h5 id="两种通用解决方法"><a class="markdownIt-Anchor" href="#两种通用解决方法"></a> 两种通用解决方法</h5>
<ul>
<li>Asynchronous （异步）取消立即终止目标线程</li>
<li>Deferred（延迟）取消允许目标线程定期检查是否应取消它</li>
</ul>
<h4 id="线程池"><a class="markdownIt-Anchor" href="#线程池"></a> 线程池</h4>
<ul>
<li>
<p>在它们所在的池中创建许多线程并等待工作</p>
</li>
<li>
<p>使用现有线程处理请求要比创建新线程快一些</p>
</li>
<li>
<p>允许将应用程序中的线程数绑定到池的大小</p>
</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>4.1 Provide two programming examples in which multithreading provides<br />
better performance than a single-threaded solution.</p>
<p>网页浏览和字处理，都需要并发处理多个事件</p>
<p>4.2 What are two differences between user-level threads and kernel-level<br />
threads? Under what circumstances is one type better than the other?</p>
<p>​	kernel-level threads由kernel mode直接支持，而user-level threads不被kernel mode支持。但是kernel-level threads因为会需求更多资源，所以会比user-level threads更慢。一些不需要kernel mode来管理的低级任务，使用user-level threads能加快速度；kernel-level threads更适合需要系统资源的高级任务。</p>
<p>4.3 Describe the actions taken by a kernel to context-switch between kernel-level threads.</p>
<p>​	记录当前线程的CPU寄存器值并加载调度线程的CPU寄存器值</p>
<p>4.4 What resources are used when a thread is created? How do they differ<br />
from those used when a process is created?</p>
<p>1）一组用来在上下文切换时记录状态的寄存器</p>
<p>2)一个堆栈</p>
<p>3)各种运行时库和动态链接库使用的线程专用存储</p>
<p>当进程被创建时，内存分配用于程序指令和数据以及线程存储</p>
<p>4.5 Assume that an operating system maps user-level threads to the kernel<br />
using the many-to-many model and that the mapping is done through<br />
LWPs. Furthermore, the system allows developers to create real-time<br />
threads for use in real-time systems. Is it necessary to bind a real-time<br />
thread to an LWP? Explain.</p>
<p>​		是的，把实时线程绑定到LWP很有必要，这样可以确保线程在调度好之后就能以最小的延迟时间运行</p>
<p>4.6 Provide two programming examples in which multithreading does not<br />
provide better performance than a single-threaded solution.</p>
<ul>
<li>任何顺序执行的程序</li>
<li>监控自己工作空间的程序如open files和C-shell</li>
</ul>
<p>4.7 Under what circumstances does a multithreaded solution using multiple<br />
kernel threads provide better performance than a single-threaded<br />
solution on a single-processor system?</p>
<p>​		在程序经常发生页面错误、或需要经常等待其他系统事件时，用多kernel threads的多线程解决方案比用单处理器的单线程解决方案好</p>
<p>4.8 Which of the following components of program state are shared across<br />
threads in a multithreaded process?<br />
a. Register values<br />
b. Heap memory<br />
c. Global variables<br />
d. Stack memory</p>
<p>b, c</p>
<p>4.9 Can a multithreaded solution using multiple user-level threads achieve<br />
better performance on a multiprocessor system than on a single processor<br />
system? Explain.</p>
<p>​		因为user-level threads没有kernel mode的支持，在多处理器系统上使用多 user-level threads没有收益，所以不能</p>
<p>4.11 Is it possible to have concurrency but not parallelism? Explain.</p>
<p>​	可以，进程的执行就可以只是并发，没有并行。</p>
<p>4.15 Consider the following code segment:<br />
pid t pid;<br />
pid = fork();<br />
if (pid == 0) { /* child process */<br />
fork();<br />
thread create( . . .);<br />
}<br />
fork();<br />
a. How many unique processes are created?</p>
<p>​	5</p>
<p>b. How many unique threads are created?</p>
<p>​	2</p>
<p>4.16 As described in Section 4.7.2, Linux does not distinguish between<br />
processes and threads. Instead, Linux treats both in the same way,<br />
allowing a task to be more akin to a process or a thread depending on the<br />
set of flags passed to the clone() system call. However, other operating<br />
systems, such as Windows, treat processes and threads differently.<br />
Typically, such systems use a notation in which the data structure for<br />
a process contains pointers to the separate threads belonging to the<br />
process. Contrast these two approaches for modeling processes and<br />
threads within the kernel.</p>
<p>Pros:</p>
<ul>
<li>Linux认为这很相似，因此可以很容易地减少属于操作系统的代码。</li>
<li>Linux操作系统中存在的调度程序不需要特殊的代码即可测试与每个进程耦合的线程。</li>
<li>在调度期间，它将不同的线程和进程视为单个任务。</li>
</ul>
<p>Cons:</p>
<ul>
<li>这种能力使Linux操作系统更难直接施加进程范围的资源限制。</li>
<li>需要额外的步骤来识别每个进程属于适当的线程以及执行相关任务的复杂性。</li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第5章 进程同步</title>
    <url>/2020/10/17/OS/%E7%AC%AC5%E7%AB%A0%20%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="进程同步"><a class="markdownIt-Anchor" href="#进程同步"></a> 进程同步</h2>
<h3 id="临界区问题"><a class="markdownIt-Anchor" href="#临界区问题"></a> 临界区问题</h3>
<h4 id="竞争状态race-condition"><a class="markdownIt-Anchor" href="#竞争状态race-condition"></a> 竞争状态(race condition)</h4>
<a id="more"></a>
<p>​	多个进程同时访问和操作相同的数据，执行的结果取决于访问发生的特定顺序。所以确保一次只能处理一个进程。</p>
<h4 id="临界区条件"><a class="markdownIt-Anchor" href="#临界区条件"></a> 临界区条件</h4>
<ul>
<li>互斥</li>
<li>空闲让进</li>
<li>有限等待</li>
</ul>
<h3 id="互斥访问"><a class="markdownIt-Anchor" href="#互斥访问"></a> 互斥访问</h3>
<ul>
<li>
<p>加锁标志位法</p>
</li>
<li>
<p>强制轮流法</p>
</li>
<li>
<p>标记法</p>
</li>
</ul>
<h4 id="基于繁忙等待的互斥"><a class="markdownIt-Anchor" href="#基于繁忙等待的互斥"></a> 基于繁忙等待的互斥</h4>
<p>​		当一个进程要进入其关键部分时，首先要检查是否允许其进入。 如果允许，它将直接进入； 如果不允许，它将循环等待直到允许其进入</p>
<p>​	缺点：</p>
<ul>
<li>
<p>浪费CPU时间</p>
</li>
<li>
<p>可能会导致意外结果（如一个低优先级进程位于临界区中，这时有一个高优先级进展也试图进入临界区）</p>
</li>
</ul>
<h3 id="硬件中断实现的互斥"><a class="markdownIt-Anchor" href="#硬件中断实现的互斥"></a> 硬件中断实现的互斥</h3>
<p>缺点：</p>
<ul>
<li>禁用中断后，无法停止该过程</li>
<li>可能导致其他进程处于饥饿</li>
<li>关键部分可能很长，无法确定响应时间</li>
<li>它适用于单个处理器，在多处理器计算机上不起作用，其他CPU仍可以进入关键区域</li>
</ul>
<h3 id="高度抽象方法"><a class="markdownIt-Anchor" href="#高度抽象方法"></a> 高度抽象方法</h3>
<h4 id="锁"><a class="markdownIt-Anchor" href="#锁"></a> 锁</h4>
<img src="https://i.loli.net/2020/10/23/5jMQEYrJeCsbAmS.png" alt="image-20201014155240628.png" style="zoom: 67%;" />
<h4 id="没有busy-waiting的lock"><a class="markdownIt-Anchor" href="#没有busy-waiting的lock"></a> 没有busy waiting的lock</h4>
<ul>
<li>增添等待队列</li>
</ul>
<p>优点：</p>
<ul>
<li>适用于单个处理器或共享主内存的多个处理器上的任意数量的进程同步</li>
<li>简单容易证明</li>
<li>支持多临界区</li>
</ul>
<p>缺点：</p>
<ul>
<li>繁忙的等待消耗处理器时间</li>
<li>可能导致饥饿</li>
<li>死锁：低优先级进程占据临界区； 高优先级进程请求访问临界区并等待</li>
</ul>
<h3 id="信号量"><a class="markdownIt-Anchor" href="#信号量"></a> 信号量</h3>
<ul>
<li>计数信号量、二进制信号量</li>
</ul>
<p><img src="https://i.loli.net/2020/10/23/Z2K7Qk1eizsB5wG.png" alt="image-20201014171835419.png" /></p>
<h3 id="经典同步问题"><a class="markdownIt-Anchor" href="#经典同步问题"></a> 经典同步问题</h3>
<h4 id="生产者-消费者问题"><a class="markdownIt-Anchor" href="#生产者-消费者问题"></a> 生产者-消费者问题</h4>
<p><img src="https://i.loli.net/2020/10/23/bDAv6X1jiEcrZJ5.png" alt="image-20201014172023506.png" /></p>
<h4 id="读者-写者问题"><a class="markdownIt-Anchor" href="#读者-写者问题"></a> 读者-写者问题</h4>
<p><img src="https://i.loli.net/2020/10/23/tGgLweIFjc4hNdP.png" alt="image-20201014172033292.png" /></p>
<h4 id="哲学家就餐问题"><a class="markdownIt-Anchor" href="#哲学家就餐问题"></a> 哲学家就餐问题</h4>
<p>奇数先左后右，偶数先右后左<br />
<img src="https://i.loli.net/2020/10/23/sFUrkxnV82SwEzy.png" alt="image-20201014172137641.png" /></p>
<h3 id="管程"><a class="markdownIt-Anchor" href="#管程"></a> 管程</h3>
<p><img src="https://i.loli.net/2020/10/23/w8cKbxayOFGP6v5.png" alt="image-20201014172415297.png" /></p>
<h4 id="条件变量"><a class="markdownIt-Anchor" href="#条件变量"></a> 条件变量</h4>
<p>条件变量是管程上的等待机制</p>
<h4 id="两种条件变量操作"><a class="markdownIt-Anchor" href="#两种条件变量操作"></a> 两种条件变量操作</h4>
<p>Wait():</p>
<ul>
<li>将自己阻塞再等待队列中</li>
<li>唤醒一个等待线程</li>
</ul>
<p>Signal():</p>
<ul>
<li>唤醒等待队列中的线程</li>
<li>如果等待队列为空，则相当于一个空操作</li>
</ul>
<p><img src="https://i.loli.net/2020/10/23/ruMh6GvxJZ2bsXN.png" alt="image-20201014174245226.png" /></p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>5.3 What is the meaning of the term busy waiting? What other kinds of<br />
waiting are there in an operating system? Can busy waiting be avoided<br />
altogether? Explain your answer.</p>
<p>繁忙等待表示进程在占用CPU的情况下不停地循环来等待执行，进程还可以放弃CPU转入进程等待队列，等待被唤醒。可以避免繁忙等待，可以将其转入进程等待队列等待被唤醒。</p>
<p>5.5 Show that, if the wait() and signal() semaphore operations are not<br />
executed atomically, then mutual exclusion may be violated.</p>
<p>当一个信号量为1时，如果wait()不是原子地执行，成功执行了两次wait()操作，导致信号量总共减少2，就会导致违反互斥。</p>
<p>5.6 Illustrate how a binary semaphore can be used to implement mutual<br />
exclusion among n processes.</p>
<p>在每个进程的entry section调用wait(mutex)，exit section调用signal(mutex)</p>
<p>5.10 Explain why implementing synchronization primitives by disabling<br />
interrupts is not appropriate in a single-processor system if the synchronization<br />
primitives are to be used in user-level programs.</p>
<p>因为如果当执行一个进程时，有更高优先级的进程也需要执行时，由于同步机制，kernel无法进行调度，更高优先级的进程只能等待。同时，低优先级进程占据临界区， 高优先级进程请求访问临界区并等待会造成死锁发生。当进程离开临界区时会有许多等待进程，这种情况下可能造成饥饿。</p>
<p>5.11 Explain why interrupts are not appropriate for implementing synchronization<br />
primitives in multiprocessor systems.</p>
<p>中断只会阻止其他在中断发生的处理器上的进程执行，因为其他处理器执行的操作不受限，仍可进入该进程的临界区，不能保证互斥访问</p>
<p>5.12 The Linux kernel has a policy that a process cannot hold a spinlock while<br />
attempting to acquire a semaphore. Explain why this policy is in place.</p>
<p>为了防止饥饿和死锁。当低优先级进程拥有自旋锁，而高优先级进程请求访问临界区并等待时，可能会发生死锁。进程拥有自旋锁，一直占用CPU资源，可能导致其他进程得不到资源，造成饥饿。</p>
<p>5.13 Describe two kernel data structures in which race conditions are possible.<br />
Be sure to include a description of how a race condition can occur.</p>
<p>stack和queue，当一个进程对stack执行pop()操作时，另一个进程对stack执行了push()操作，那么此进程pop()出的并不是想要得到的结果。queue类似，当一个进程对queue执行pop()操作，而另一个进程对queue抢先执行了一次pop()，那么此进程pop()出的并不是想要得到的结果。</p>
<p>5.23 Show how to implement the wait() and signal() semaphore operations<br />
in multiprocessor environments using the test and set() instruction. The solution should exhibit minimal busy waiting.</p>
<p>给信号量新增一个计数器和队列，利用等待队列来降低繁忙等待。代码如下：</p>
<p>typedef struct {</p>
<p>​	int value;</p>
<p>​	WaitQueue q;	// 一个等待队列</p>
<p>} Semaphore;</p>
<p>int lock = 0;</p>
<p>wait(Semaphore* S) {</p>
<p>​	while(test_and_set(&amp;lock)) {</p>
<p>​		S-&gt;value–;</p>
<p>​		if(S-&gt;value &lt; 0)</p>
<p>​			block();</p>
<p>​	}</p>
<p>}</p>
<p>signal(semaphore* S) {</p>
<p>​	lock = 0;</p>
<p>​	S-&gt;value++;</p>
<p>​	if(S-&gt;value &lt;= 0)</p>
<p>​		wakeup(P);					// 把进程改为就绪状态，插入就绪队列</p>
<p>}</p>
<p>5.25 Demonstrate that monitors and semaphores are equivalent insofar<br />
as they can be used to implement solutions to the same types of<br />
synchronization problems.</p>
<p>在使用信号量处理同步问题时，进程在进入临界区前获取系统资源，无资源则挂起进入等待队列。退出临界区后释放资源，如果释放后有可用资源，则唤醒等待队列中的一个进程。这样的管理方式与管程类似，只需将管程的条件变量设为判断是否有可用资源，则会与信号量拥有类似的实现结构和方式，它们在处理同步问题上是等效的。</p>
<p>5.26 Design an algorithm for a bounded-buffer monitor in which the buffers<br />
(portions) are embedded within the monitor itself.</p>
<p>设计一个结构体buffer,里面有数据存储区，读写标识符，计数器以及两个条件变量。</p>
<p>利用条件变量来实现进程对共享内存的互斥访问，</p>
<p>伪代码如下：</p>
<p>struct bound-buffer {</p>
<p>​	int size = 32;</p>
<p>​	char buffer[32];</p>
<p>​	int writepos, readpos;</p>
<p>​	int cnt;</p>
<p>​	condition notfull, notempty;</p>
<p>} buffer;</p>
<p>int mutex;</p>
<p>void producer(int data) {</p>
<p>​	wait(mutex);</p>
<p>​	if(cnt == size)</p>
<p>​		cond_wait(notfull);</p>
<p>​	buffer[writepos] = data;</p>
<p>​	writepos = (writepos + 1) % size;</p>
<p>​	cond_signal(notempty);</p>
<p>​	signal(mutex);</p>
<p>}</p>
<p>void comsumer() {</p>
<p>​	wait(mutex);</p>
<p>​	if(cnt == 0)</p>
<p>​		cond_wait(not empty);</p>
<p>​	int data = buffer[readpos];</p>
<p>​	readpos = (readpos + 1) % size;</p>
<p>​	cond_signal(notfull);</p>
<p>​	signal(mutex);</p>
<p>}</p>
<p>5.32 A file is to be shared among different processes, each of which has<br />
a unique number. The file can be accessed simultaneously by several<br />
processes, subject to the following constraint: the sum of all unique<br />
numbers associated with all the processes currently accessing the file<br />
must be less than n. Write a monitor to coordinate access to the file.</p>
<p>在管程中设计一个计数器，并设计操作，在进入进程的临界区前，增加检查计数器加当前id是否小于总和n，如果小于n，则将其累加进计数器中，如果大于n，则进行繁忙等待。在退出临界区后中让计数器减去当前id，并唤醒其他进程。</p>
<p>5.37 Assume that a finite number of resources of a single resource type must be managed. Processes may ask for a number of these resources and will return them once finished. As an example, many commercial software packages provide a given number of licenses, indicating the number of applications that may run concurrently. When the application is started, the license count is decremented. When the application is terminated, the license count is incremented. If all licenses are in use, requests to start the application are denied. Such requests will only be granted when an existing license holder terminates the application and a license is returned. The following program segment is used to manage a finite number of instances of an available resource. The maximum number of resources and the number of available resources are declared as follows:<img src="https://i.loli.net/2020/10/23/opk8WXmlThMJdPC.png" alt="image-20201014144721685.png" /></p>
<p>The preceding program segment produces a race condition. Do the<br />
following:<br />
a. Identify the data involved in the race condition.</p>
<p>available_resources</p>
<p>b. Identify the location (or locations) in the code where the race<br />
condition occurs.</p>
<p>在语句 available_resources -= count和语句available_resources += count处，假设available_resources初值为1，第一个进程调用decrease_count()，在执行到else时发生中断，此时available_resources为1。第二个进程调用decrease_count()并执行完毕，假设count值为1，available_resources执行完为0。切换上下文回第一个进程继续执行，假设count为1，available_resources会得到负数的结果，也就意味着越界了。</p>
<p>c. Using a semaphore or mutex lock, fix the race condition. It is<br />
permissible to modify the decrease count() function so that the<br />
calling process is blocked until sufficient resources are available.</p>
<p>利用互斥锁实现，伪代码如下：</p>
<p>int mutex = 1;</p>
<p>int decrease_count(int count) {</p>
<p>​	if(available_resources &lt; count)</p>
<p>​		return -1;</p>
<p>​	else {</p>
<p>​		wait(mutex);</p>
<p>​		available_resources -= count;</p>
<p>​		signal(mutex);</p>
<p>​		return 0;</p>
<p>​	}</p>
<p>}</p>
<p>int increase_count(int count) {</p>
<p>​	wait(mutex);</p>
<p>​	available_resources += count;</p>
<p>​	signal(mutex);</p>
<p>​	return 0;</p>
<p>}</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第6章 CPU调度</title>
    <url>/2020/10/27/OS/%E7%AC%AC6%E7%AB%A0%20CPU%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="cpu调度"><a class="markdownIt-Anchor" href="#cpu调度"></a> CPU调度</h2>
<h3 id="61-cpu调度"><a class="markdownIt-Anchor" href="#61-cpu调度"></a> 6.1 CPU调度</h3>
<h4 id="cpu调度程序short-term-scheduler"><a class="markdownIt-Anchor" href="#cpu调度程序short-term-scheduler"></a> CPU调度程序(Short-term Scheduler)</h4>
<a id="more"></a>
<p>从内存中选择一个能够执行的进程，并为其分配CPU</p>
<h4 id="调度程序"><a class="markdownIt-Anchor" href="#调度程序"></a> 调度程序</h4>
<p>将CPU控制交给由短期调度程序选择的进程</p>
<ul>
<li>切换上下文</li>
<li>切换用户模式</li>
<li>跳转到用户程序的合适位置，以便重新启动程序</li>
</ul>
<p>调度延迟：调度程序停止一个进程而启动另一个所需的时间</p>
<h3 id="62-调度准则"><a class="markdownIt-Anchor" href="#62-调度准则"></a> 6.2 调度准则</h3>
<ul>
<li>CPU利用率</li>
<li>吞吐率：在时间单元内进程完成的数量</li>
<li>周转时间：从进程提交到进程完成的时间段，包括等待进入内存、在就绪队列中等待、在CPU上执行和I/O执行</li>
<li>等待时间：在就绪队列中等待所花时间之和</li>
<li>响应时间：从提交请求到产生第一响应的时间</li>
</ul>
<h3 id="63-调度算法"><a class="markdownIt-Anchor" href="#63-调度算法"></a> 6.3 调度算法</h3>
<h4 id="先到先服务调度fcfs"><a class="markdownIt-Anchor" href="#先到先服务调度fcfs"></a> 先到先服务调度(FCFS)</h4>
<p>Example:</p>
<ul>
<li>one CPU-bound process</li>
<li>many I/O-bound process</li>
</ul>
<h4 id="最短作业优先调度sjf"><a class="markdownIt-Anchor" href="#最短作业优先调度sjf"></a> 最短作业优先调度(SJF)</h4>
<h5 id="非抢占"><a class="markdownIt-Anchor" href="#非抢占"></a> 非抢占</h5>
<p>一旦CPU被分配给进程，则在CPU执行完前不能抢占</p>
<h5 id="抢占"><a class="markdownIt-Anchor" href="#抢占"></a> 抢占</h5>
<h4 id="最短剩余时间有限srtf"><a class="markdownIt-Anchor" href="#最短剩余时间有限srtf"></a> 最短剩余时间有限(SRTF)</h4>
<p><img src="https://i.loli.net/2020/11/01/wsDmx8lp2aCIghL.png" alt="image-20201101135007962.png" /></p>
<p>Average waiting time: ((16 - 7) + (7 - 4 - 2) + (5 - 1 - 4) + (11 - 4 - 5)) / 4 = 3</p>
<h4 id="优先级调度"><a class="markdownIt-Anchor" href="#优先级调度"></a> 优先级调度</h4>
<p>问题：饥饿</p>
<p>策略：老化增加优先级</p>
<h4 id="时间片轮转rr"><a class="markdownIt-Anchor" href="#时间片轮转rr"></a> 时间片轮转(RR)</h4>
<h4 id="多级队列调度"><a class="markdownIt-Anchor" href="#多级队列调度"></a> 多级队列调度</h4>
<p>将就绪队列分成多个单独队列，每个队列有自己的调度算法</p>
<ul>
<li>固定优先级</li>
<li>划分时间片</li>
</ul>
<h4 id="多级反馈队列调度"><a class="markdownIt-Anchor" href="#多级反馈队列调度"></a> 多级反馈队列调度</h4>
<p>Three queues:</p>
<ul>
<li>Q0 –RR with time quantum 8 milliseconds</li>
<li>Q1 –RR time quantum 16 milliseconds</li>
<li>Q2 –FCFS</li>
</ul>
<img src="https://i.loli.net/2020/11/01/jmMDxZ6p2KiXRTJ.png" alt="image-20201101143850159.png" style="zoom: 67%;" />
<h3 id="64-线程调度"><a class="markdownIt-Anchor" href="#64-线程调度"></a> 6.4 线程调度</h3>
<h4 id="进程竞争范围pcs"><a class="markdownIt-Anchor" href="#进程竞争范围pcs"></a> 进程竞争范围(PCS)</h4>
<p>PCS发生在同一进程的线程之间，实现多对一和多对多模型的系统线程库会将线程调度到可用LWP上</p>
<h4 id="系统竞争范围scs"><a class="markdownIt-Anchor" href="#系统竞争范围scs"></a> 系统竞争范围(SCS)</h4>
<p>SCS用来决定哪个内核级线程调度到处理器上，发生在系统内的所有线程之间，采用一对一模型的系统，只采用SCS调度</p>
<h3 id="65-多处理器调度"><a class="markdownIt-Anchor" href="#65-多处理器调度"></a> 6.5 多处理器调度</h3>
<h4 id="对称多处理器调度smp"><a class="markdownIt-Anchor" href="#对称多处理器调度smp"></a> 对称多处理器调度(SMP)</h4>
<ul>
<li>每个处理器自我调度</li>
</ul>
<h4 id="静态进程分配"><a class="markdownIt-Anchor" href="#静态进程分配"></a> 静态进程分配</h4>
<ul>
<li>每个处理器有自己的就绪队列</li>
<li>处理器可能负载不均</li>
</ul>
<h4 id="动态进程分配"><a class="markdownIt-Anchor" href="#动态进程分配"></a> 动态进程分配</h4>
<ul>
<li>进程可被分配到任何空闲的处理器上执行</li>
<li>所有处理器共享一个就绪队列</li>
<li>高调度开销</li>
<li>负载均衡</li>
</ul>
<h3 id="66-实时cpu调度"><a class="markdownIt-Anchor" href="#66-实时cpu调度"></a> 6.6 实时CPU调度</h3>
<p>正确性取决于操作系统的时间和功能</p>
<h4 id="单调速率调度rate-monotonic"><a class="markdownIt-Anchor" href="#单调速率调度rate-monotonic"></a> 单调速率调度（rate-monotonic）</h4>
<ul>
<li>优先级与周期成反比</li>
</ul>
<h4 id="最早截至期限优先edf"><a class="markdownIt-Anchor" href="#最早截至期限优先edf"></a> 最早截至期限优先(EDF)</h4>
<ul>
<li>优先级与deadline成正比</li>
</ul>
<h3 id="67-算法评估"><a class="markdownIt-Anchor" href="#67-算法评估"></a> 6.7 算法评估</h3>
<h4 id="确定性模型"><a class="markdownIt-Anchor" href="#确定性模型"></a> 确定性模型</h4>
<p>采用特定的预先确定的符合，计算在给定负荷下每个算法的性能</p>
<h4 id="排队模型"><a class="markdownIt-Anchor" href="#排队模型"></a> 排队模型</h4>
<p>根据CPU和I/O的执行分布和进程到达系统的时间分布简单估计，得到数学公式</p>
<h5 id="排队网络分析"><a class="markdownIt-Anchor" href="#排队网络分析"></a> 排队网络分析</h5>
<p>计算机系统：一个服务器网络，每个服务器都有一个等待进程队列</p>
<p>CPU: 就绪队列</p>
<p>I/O:设备队列(等价于等待队列)</p>
<h4 id="仿真模拟"><a class="markdownIt-Anchor" href="#仿真模拟"></a> 仿真/模拟</h4>
<p>通过随机数生成器，根据概率分布生成进程、CPU执行、到达时间、离开时间等</p>
<h5 id="跟踪磁带trace-tape"><a class="markdownIt-Anchor" href="#跟踪磁带trace-tape"></a> 跟踪磁带(trace tape)</h5>
<p>通过监视真实系统并记录事件发生顺序，使用这个顺序以便驱动仿真，在针对完全相同的实际输入的情况下，比较两种算法</p>
<img src="https://i.loli.net/2020/11/01/pGkBhc5VAQg8bSN.png" alt="image-20201101150423518.png" style="zoom:80%;" />
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>6.1 A CPU-scheduling algorithm determines an order for the execution<br />
of its scheduled processes. Given n processes to be scheduled on one<br />
processor, how many different schedules are possible? Give a formula<br />
in terms of n.</p>
<p>n!</p>
<p>6.2 Explain the difference between preemptive and nonpreemptive scheduling.</p>
<p>非抢占调度在一个进程CPU执行完之前不能分配CPU给另一个进程，抢占调度可以在一个进程CPU执行时中断其执行，并将CPU分配给其他进程。抢占调度因为要频繁切换上下文，相对于非抢占调度来说会产生额外开销。</p>
<p>6.3 Suppose that the following processes arrive for execution at the times<br />
indicated. Each process will run for the amount of time listed. In<br />
answering the questions, use nonpreemptive scheduling, and base all<br />
decisions on the information you have at the time the decision must be<br />
made.</p>
<img src="https://i.loli.net/2020/11/01/GyR62QmFh4xs3C7.png" alt="image-20201101150923649.png" style="zoom:80%;" />
<p>a. What is the average turnaround time for these processes with the<br />
FCFS scheduling algorithm?</p>
<p>执行顺序为P1、P2、P3</p>
<p>(8 + 12 - 0.4 + 13 - 1) / 3 = 10.53</p>
<p>b. What is the average turnaround time for these processes with the<br />
SJF scheduling algorithm?</p>
<p>因为调度为非抢占的，所以执行顺序为P1、P3、P2</p>
<p>(8 + 9 - 1 + 13 - 0.4) / 3 = 9.53</p>
<p>c. The SJF algorithm is supposed to improve performance, but notice<br />
that we chose to run process P1 at time 0 because we did not know<br />
that two shorter processes would arrive soon. Compute what the<br />
average turnaround time will be if the CPU is left idle for the first<br />
1 unit and then SJF scheduling is used. Remember that processes<br />
P1 and P2 are waiting during this idle time, so their waiting time<br />
may increase. This algorithm could be called future-knowledge<br />
scheduling.</p>
<p>执行顺序为P3、P2、P1</p>
<p>(2 - 1 + 6 - 0.4 + 14 ) / 3 = 6.87</p>
<p>6.4 What advantage is there in having different time-quantum sizes at<br />
different levels of a multilevel queueing system?</p>
<p>设定合适的时间片长度，可以减少上下文切换，从而减少额外开销。如I/O密集型程序可以设置较小的时间片长度，CPU密集型程序可以设置较长的时间片长度</p>
<p>6.5 Many CPU-scheduling algorithms are parameterized. For example, the<br />
RR algorithm requires a parameter to indicate the time slice. Multilevel<br />
feedback queues require parameters to define the number of queues, the<br />
scheduling algorithm for each queue, the criteria used to move processes<br />
between queues, and so on.<br />
These algorithms are thus really sets of algorithms (for example, the<br />
set of RR algorithms for all time slices, and so on). One set of algorithms<br />
may include another (for example, the FCFS algorithm is the RR algorithm<br />
with an infinite time quantum). What (if any) relation holds between the<br />
following pairs of algorithm sets?<br />
a. Priority and SJF</p>
<p>最短执行时间的进程拥有最高优先级</p>
<p>b. Multilevel feedback queues and FCFS</p>
<p>最低层次的多级反馈队列使用的是FCFS调度</p>
<p>c. Priority and FCFS</p>
<p>最先到达的进程拥有最高优先级</p>
<p>d. RR and SJF</p>
<p>没有关系</p>
<p>6.6 Suppose that a scheduling algorithm (at the level of short-term CPU<br />
scheduling) favors those processes that have used the least processor<br />
time in the recent past. Why will this algorithm favor I/O-bound<br />
programs and yet not permanently starve CPU-bound programs?</p>
<p>I/O密集型程序具有大量短CPU执行，使用更少的处理器时间，所以这个调度算法支持I/O密集型程序。因为I/O密集型程序CPU执行时间较短，需要等待I/O操作，CPU密集型程序有机会执行，所以不会被饿死。</p>
<p>6.7 Distinguish between PCS and SCS scheduling.</p>
<p>PCS调度发生在同一进程的线程间，实现多对一和多对多模型的系统线程库会调度线程到可用LWP上。SCS调度会决定决定哪个内核级线程调度到处理器上，发生在系统的所有线程之间，采用一对一模型的系统只采用SCS调度。</p>
<p>6.9 The traditional UNIX scheduler enforces an inverse relationship between priority numbers and priorities: the higher the number, the lower the priority. The scheduler recalculates process priorities once per second<br />
using the following function:<br />
Priority = (recent CPU usage / 2) + base<br />
where base = 60 and recent CPU usage refers to a value indicating how<br />
often a process has used the CPU since priorities were last recalculated.<br />
Assume that recent CPU usage is 40 for process P1, 18 for process P2,<br />
and 10 for process P3. What will be the new priorities for these three<br />
processes when priorities are recalculated? Based on this information,<br />
does the traditional UNIX scheduler raise or lower the relative priority<br />
of a CPU-bound process?</p>
<p>三个进程重新计算后的优先级分别为80、69、65，三个进程的优先级数都增加，即优先级均下降，所以传统的UNIX调度会降低CPU密集型进程的优先级</p>
<p>6.10 Why is it important for the scheduler to distinguish I/O-bound programs from CPU-bound programs?</p>
<p>I/O密集型程序具有大量短CPU执行，而CPU密集型程序具有少量长CPU执行，如果所有进程都是I/O密集型程序，那么就绪队列几乎为空，如果所有进程都是CPU密集型的，那么I/O等待队列几乎为空，设备没有得到使用。为了保持系统的平衡，因此需要区分I/O密集型程序和CPU密集型程序，并合理组合两种程序。</p>
<p>I/O密集型程序具有大量短CPU执行，而CPU密集型程序具有少量长CPU执行，如果所有进程都是I/O密集型程序，那么就绪队列几乎为空，如果所有进程都是CPU密集型的，那么I/O等待队列几乎为空，设备没有得到使用。为了保持系统的平衡，调度器应该给予I/O密集型程序更高优先级，可以更好的利用电脑资源。</p>
<p>6.11 Discuss how the following pairs of scheduling criteria conflict in certain settings.<br />
a. CPU utilization and response time</p>
<p>需要最大化CPU使用率和最小化响应时间。为了最大化CPU使用率需要减少上下文切换以减少CPU的空转，而为了最小化响应时间，需要更频繁的进行上下文切换来输出结果给用户。</p>
<p>b. Average turnaround time and maximum waiting time</p>
<p>需要减少平均周转时间和最大等待时间。为了最小化平均周转时间如采用SJF调度算法，会使得最长执行时间的进程的拥有最大等待时间，并且该时间会很大,甚至造成饥饿。为了最小化最大等待时间，如采用FCFS确保每个进程都能在有限时间内完成，这样的话平均周转时间又会上升。</p>
<p>c. I/O device utilization and CPU utilization</p>
<p>需要最大化I/O设备利用率和最大化CPU利用率。多执行CPU密集型进程可以最大化CPU利用率，多执行I/O密集型进程可以最大化I/O设备利用率。但是如果都执行I/O密集型进程，就绪队列几乎为空，造成CPU调度程序没有什么事可做。如果都执行CPU密集型进程，I/O等待队列几乎为空，造成设备浪费，系统会不平衡。因此需要合理组合I/O密集型进程和CPU密集型进程，也就不能同时最大化I/O设备利用率和CPU利用率。</p>
<p>6.14 Consider the exponential average formula used to predict the length of the next CPU burst. What are the implications of assigning the following<br />
values to the parameters used by the algorithm?<br />
a. α = 0 and τ<sub>0</sub>= 100 milliseconds</p>
<p>T<sub>n+1</sub> = T<sub>0</sub> = 100 ms</p>
<p>最近历史没有影响，过去历史为全部影响因素</p>
<p>b. α = 0.99 and τ<sub>0</sub> = 10 milliseconds</p>
<p>最近历史为主要影响因素，过去历史几乎没有影响</p>
<p>6.15 A variation of the round-robin scheduler is the regressive round-robin<br />
scheduler. This scheduler assigns each process a time quantum and a<br />
priority. The initial value of a time quantum is 50 milliseconds. However,<br />
every time a process has been allocated the CPU and uses its entire time<br />
quantum (does not block for I/O), 10 milliseconds is added to its time<br />
quantum, and its priority level is boosted. (The time quantum for a<br />
process can be increased to a maximum of 100 milliseconds.) When a<br />
process blocks before using its entire time quantum, its time quantum is<br />
reduced by 5 milliseconds, but its priority remains the same. What type<br />
of process (CPU-bound or I/O-bound) does the regressive round-robin<br />
scheduler favor? Explain.</p>
<p>支持CPU密集型进程。I/O密集型进程会因等待I/O阻塞而减少时间片时间，而CPU密集型只有较少的I/O操作，并且在一个时间片执行完后，当前进程会增加时间片长度和优先级。在所有进程都执行完一个时间片长度后，CPU密集型的进程会拥有更高的优先级以及更多的时间片长度，因此该调度支持CPU密集型进程。</p>
<p>6.16 Consider the following set of processes, with the length of the CPU burst given in milliseconds:</p>
<img src="https://i.loli.net/2020/11/01/u6eKBLXo3rQbGfg.png" alt="image-20201101151326074.png" style="zoom:80%;" />
<p>The processes are assumed to have arrived in the order P1, P2, P3, P4, P5,<br />
all at time 0.<br />
a. Draw four Gantt charts that illustrate the execution of these<br />
processes using the following scheduling algorithms: FCFS, SJF,<br />
nonpreemptive priority (a larger priority number implies a higher<br />
priority), and RR (quantum = 2).</p>
<p>FCFS:</p>
<table>
<thead>
<tr>
<th>P1</th>
<th>P2</th>
<th>P3</th>
<th>P4</th>
<th>P5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>3</td>
<td>11</td>
<td>15     20</td>
</tr>
</tbody>
</table>
<p>SJF:</p>
<table>
<thead>
<tr>
<th>P2</th>
<th>P1</th>
<th>P4</th>
<th>P5</th>
<th>P3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>1</td>
<td>3</td>
<td>7</td>
<td>12    20</td>
</tr>
</tbody>
</table>
<p>priority:</p>
<table>
<thead>
<tr>
<th>P3</th>
<th>P5</th>
<th>P1</th>
<th>P4</th>
<th>P2</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>8</td>
<td>13</td>
<td>15</td>
<td>19    20</td>
</tr>
</tbody>
</table>
<p>RR:</p>
<table>
<thead>
<tr>
<th>P1</th>
<th>P2</th>
<th>P3</th>
<th>P4</th>
<th>P5</th>
<th>P3</th>
<th>P4</th>
<th>P5</th>
<th>P3</th>
<th>P5</th>
<th>P3</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>2</td>
<td>3</td>
<td>5</td>
<td>7</td>
<td>9</td>
<td>11</td>
<td>13</td>
<td>15</td>
<td>17</td>
<td>18 20</td>
</tr>
</tbody>
</table>
<p>b. What is the turnaround time of each process for each of the<br />
scheduling algorithms in part a?</p>
<p>FCFS:	P1: 2	P2: 3	P3: 11	P4: 15	P5: 20</p>
<p>SJF:	P1:3	P2:1	P3:20	P4:7	P5:12</p>
<p>prority:	P1:15	P2:20	P3:8	P4:19	P5:13</p>
<p>RR:	P1:2	P2:3	P3:20	P4:13	P5:18</p>
<p>c. What is the waiting time of each process for each of these scheduling<br />
algorithms?</p>
<p>FCFS:	P1: 0	P2: 2	P3: 3	P4: 11	P5: 15</p>
<p>SJF:	P1:1	P2:0	P3:12	P4:3	P5:7</p>
<p>prority:	P1:13	P2:19	P3:0	P4:15	P5:8</p>
<p>RR:	P1:0	P2:2	P3:12	P4:9	P5:13</p>
<p>d. Which of the algorithms results in the minimum average waiting<br />
time (over all processes)?</p>
<p>FCFS:	(0 + 2 + 3 + 11 + 15) / 5 = 6.2</p>
<p>SJF:	(1 + 0 + 12 + 3 + 7) / 5 = 4.6</p>
<p>proirity:	(13 + 19 + 0 + 15 + 8) / 5 = 11</p>
<p>RR:	(0 + 2 + 12 + 9 + 13) / 5 = 7.2</p>
<p>SJF平均等待时间最短</p>
<p>6.17 The following processes are being scheduled using a preemptive, roundrobin scheduling algorithm. Each process is assigned a numerical<br />
priority, with a higher number indicating a higher relative priority.<br />
In addition to the processes listed below, the system also has an idle<br />
task (which consumes no CPU resources and is identified as Pidle ). This<br />
task has priority 0 and is scheduled whenever the system has no other<br />
available processes to run. The length of a time quantum is 10 units.<br />
If a process is preempted by a higher-priority process, the preempted<br />
process is placed at the end of the queue.</p>
<img src="https://i.loli.net/2020/11/01/I3JahXlD2usxM6S.png" alt="image-20201101151404994.png" style="zoom:80%;" />
<p>a. Show the scheduling order of the processes using a Gantt chart.</p>
<table>
<thead>
<tr>
<th>P1</th>
<th>P1</th>
<th>Pidle</th>
<th>P2</th>
<th>P3</th>
<th>P2</th>
<th>P3</th>
<th>P4</th>
<th>P4</th>
<th>P2</th>
<th>P3</th>
<th>Pidle</th>
<th>P5</th>
<th>P6</th>
<th>P5</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>10</td>
<td>20</td>
<td>25</td>
<td>35</td>
<td>45</td>
<td>55</td>
<td>60</td>
<td>70</td>
<td>75</td>
<td>80</td>
<td>90</td>
<td>100</td>
<td>105</td>
<td>115   120</td>
</tr>
</tbody>
</table>
<p>b. What is the turnaround time for each process?</p>
<p>P1: 20	P2: 80 - 25 = 55	P3: 90 - 30 = 60	P4: 75 - 60 = 15	P5: 120 - 100 = 20	P6: 115 - 105 = 10</p>
<p>c. What is the waiting time for each process?</p>
<p>P1: 0	P2: 55 - 25 = 30	P3: 60 - 25 = 35	P4: 15 - 15 = 0	P5: 20 - 10 = 10	P6: 10 - 10 = 0</p>
<p>d. What is the CPU utilization rate?</p>
<p>Pidle = 15</p>
<p>(120 - 15) / 120 = 87.5%</p>
<p>6.19 Which of the following scheduling algorithms could result in starvation?<br />
a. First-come, first-served<br />
b. Shortest job first<br />
c. Round robin<br />
d. Priority</p>
<p>b、d</p>
<p>6.20 Consider a variant of the RR scheduling algorithm in which the entries<br />
in the ready queue are pointers to the PCBs.<br />
a. What would be the effect of putting two pointers to the same<br />
process in the ready queue?</p>
<p>这个进程在一轮中会执行两个时间片长度</p>
<p>b. What would be two major advantages and two disadvantages of<br />
this scheme?</p>
<p>优点：可以提高某个进程的优先级，将多个指针指向它让它来执行多次。不用改变原有调度算法，还是基于RR算法的应用。</p>
<p>缺点：优先级较低的进程可能会长时间得不到执行，因为这种策略在极端的情况下效果等同于优先级队列。需要在进程到达前提前知道进程的优先级，会有额外的系统开销。</p>
<p>c. How would you modify the basic RR algorithm to achieve the same<br />
effect without the duplicate pointers?</p>
<p>给更高优先级的进程划分更大的时间片，或者给更高优先级的进程划分多个时间片</p>
<p>6.21 Consider a system running ten I/O-bound tasks and one CPU-bound<br />
task. Assume that the I/O-bound tasks issue an I/O operation once for<br />
every millisecond of CPU computing and that each I/O operation takes<br />
10 milliseconds to complete. Also assume that the context-switching<br />
overhead is 0.1 millisecond and that all processes are long-running tasks.<br />
Describe the CPU utilization for a round-robin scheduler when:<br />
a. The time quantum is 1 millisecond</p>
<p>当时间片为1时，无论哪个进程都会执行1s然后上下文切换，CPU利用率为 1 / (1 + 0.1) ≈ 91%</p>
<p>b. The time quantum is 10 milliseconds</p>
<p>当时间片为10时，I/O密集型任务会在执行1毫秒CPU计算后进行一次上下文切换，一共10个I/O任务，共10*(1 + 0.1) = 11 ms, CPU密集型任务会在执行完10ms后进行一次上下文切换，共10 + 0.1 = 10.1ms，所以CPU利用率为 20 / (11 + 10.1) ≈ 94.8%</p>
<p>6.24 Explain the differences in how much the following scheduling algorithms discriminate in favor of short processes:<br />
a. FCFS</p>
<p>在长进程到达后的短进程会有较长的等待时间，依据这个特性来区别短进程</p>
<p>b. RR</p>
<p>所有的进程都有相同的时间片，短进程因为执行时间较短会先执行完毕离开队列，依据这个特性来区别短进程</p>
<p>c. Multilevel feedback queues</p>
<p>短进程执行时间较短，在第一级队列大多就执行完毕离开队列，依据这个特性来区别短进程</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第7章 死锁</title>
    <url>/2020/10/28/OS/%E7%AC%AC7%E7%AB%A0%20%E6%AD%BB%E9%94%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="死锁"><a class="markdownIt-Anchor" href="#死锁"></a> 死锁</h2>
<h3 id="71-死锁特性"><a class="markdownIt-Anchor" href="#71-死锁特性"></a> 7.1 死锁特性</h3>
<a id="more"></a>
<ul>
<li>
<p>互斥(mutual exclusion)</p>
</li>
<li>
<p>占有并等待(hold and wait)</p>
<p>拥有至少一个资源的进程正在等待获取其他进程所拥有的其他资源</p>
</li>
<li>
<p>非抢占(no preemption)</p>
<p>资源只能由拥有该资源的进程在该进程完成其任务后自动释放</p>
</li>
<li>
<p>循环等待(circular wait)</p>
</li>
</ul>
<h4 id="资源分配图"><a class="markdownIt-Anchor" href="#资源分配图"></a> 资源分配图</h4>
<p>圆：进程、块：资源、点：资源个数</p>
<ul>
<li>无环无死锁</li>
<li>有环
<ul>
<li>每个资源资源单实例，死锁</li>
<li>资源多实例，不一定死锁</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2020/10/23/PcMDzK3UERHY4v6.png" alt="image-20201023185203185.png" style="zoom: 50%;" />
<img src="https://i.loli.net/2020/10/23/MQLqlfzcsx756Fr.png" alt="image-20201023185400598.png" style="zoom:50%;" />
<h3 id="72-死锁处理方法"><a class="markdownIt-Anchor" href="#72-死锁处理方法"></a> 7.2 死锁处理方法</h3>
<ul>
<li>采用某个协议来预防或避免死锁，确保系统将永远不会进入死锁状态
<ul>
<li>死锁预防</li>
<li>死锁避免</li>
</ul>
</li>
<li>允许系统进入死锁状态，检测它，然后恢复
<ul>
<li>死锁检测和死锁恢复</li>
</ul>
</li>
<li>完全忽略这个问题，并假设系统永远都不会出现死锁</li>
</ul>
<img src="https://i.loli.net/2020/10/23/dyCJ9xOQK6ke3Bc.png" alt="image-20201023185736801.png" style="zoom:80%;" />
<h3 id="73-死锁预防"><a class="markdownIt-Anchor" href="#73-死锁预防"></a> 7.3 死锁预防</h3>
<p>​	破坏死锁特性</p>
<h4 id="互斥"><a class="markdownIt-Anchor" href="#互斥"></a> 互斥</h4>
<p>​	基本不可行</p>
<h4 id="占有并等待"><a class="markdownIt-Anchor" href="#占有并等待"></a> 占有并等待</h4>
<p>​	保证当进程申请一个资源时，不能占有其他资源</p>
<ul>
<li>在进程开始执行前申请获得所有资源</li>
<li>进程在结束时申请资源</li>
</ul>
<h5 id="缺点"><a class="markdownIt-Anchor" href="#缺点"></a> 缺点：</h5>
<ul>
<li>资源利用率低</li>
<li>可能发生饥饿</li>
</ul>
<h4 id="非抢占"><a class="markdownIt-Anchor" href="#非抢占"></a> 非抢占</h4>
<p>​	当一个进程处于等待时，如果其他进程申请其拥有资源，那么该进程的部分资源可以被抢占</p>
<h4 id="循环等待"><a class="markdownIt-Anchor" href="#循环等待"></a> 循环等待</h4>
<p>对所有的资源进行完全排序，而且要求每个进程按递增顺序来申请资源</p>
<h3 id="74-死锁避免"><a class="markdownIt-Anchor" href="#74-死锁避免"></a> 7.4 死锁避免</h3>
<h4 id="安全状态"><a class="markdownIt-Anchor" href="#安全状态"></a> 安全状态</h4>
<p>如果系统能按一定顺序为每个进程分配资源，仍然避免死锁，那么系统就是安全的。只有存在一个安全序列，系统才处于安全状态</p>
<h4 id="资源分配图算法"><a class="markdownIt-Anchor" href="#资源分配图算法"></a> 资源分配图算法</h4>
<p>如果每种资源类型只有一个实例，那么可以用资源分配图算法来避免死锁</p>
<ul>
<li>
<p>需求边</p>
<p>进程Pi可能在将来某个时候申请资源Pj，用虚线表示</p>
</li>
<li>
<p>申请边</p>
</li>
<li>
<p>分配边</p>
</li>
</ul>
<img src="https://i.loli.net/2020/10/23/1fvWgDVsTjUr9aC.png" alt="image-20201023194122927.png" style="zoom:50%;" />
<h4 id="银行家算法"><a class="markdownIt-Anchor" href="#银行家算法"></a> 银行家算法</h4>
<p>对于每种资源有多个实例</p>
<ul>
<li>
<p>每个进程必须提前声明每种类型资源实例的最大数量</p>
</li>
<li>
<p>当用户申请资源时，系统应确定这些资源的分配是否会使系统处于安全状态，如果会，就分配资源；否则，进程应等待其他进程释放资源</p>
</li>
<li>
<p>当进程获取所有资源时，必须在有限时间内返回它们</p>
</li>
</ul>
<h5 id="数据结构"><a class="markdownIt-Anchor" href="#数据结构"></a> 数据结构</h5>
<ul>
<li>Available: 长度为m的向量，表示每种资源的可用实例数量</li>
<li>Max: n × m矩阵，定义每个进程的最大需求</li>
<li>Allocation: n × m矩阵，定义每个进程现在分配的每种资源类型的实例数量</li>
<li>Need: n × m矩阵，表示每个进程还需要的剩余资源， Need = Max - Allocation</li>
</ul>
<h5 id="安全算法"><a class="markdownIt-Anchor" href="#安全算法"></a> 安全算法</h5>
<ol>
<li>
<p>令Work和Finish分别为长度m和n的向量，初始化Work = Available、Finish[i] = false</p>
</li>
<li>
<p>Finish[i] == false</p>
<p>Need_i ≤ Work</p>
<p>如果没有这样的i，跳转到第4步</p>
</li>
<li>
<p>Work = Work + Allocation_i</p>
<p>Finish[i] = true</p>
<p>返回第2步</p>
</li>
<li>
<p>如果对所有i, Finish[i] == true，系统处于安全状态</p>
</li>
</ol>
<h5 id="资源请求算法"><a class="markdownIt-Anchor" href="#资源请求算法"></a> 资源请求算法</h5>
<ol>
<li>
<p>Request_i ≤ Need_i</p>
</li>
<li>
<p>Request_i ≤ Available</p>
</li>
<li>
<p>Available -= Request_i</p>
<p>Allocation += Request_i</p>
<p>Need_i -= Request_i</p>
<p>如果新的资源分配状态是安全的，那么交易完成且进程Pi可分配到需要的资源；如果新状态不安全，则Pi应等待并恢复到原来的资源分配状态</p>
</li>
</ol>
<img src="https://i.loli.net/2020/10/23/tNGFWoT8PyiO4kC.png" alt="image-20201023195806388.png" style="zoom:80%;" />
<p><img src="https://i.loli.net/2020/10/23/pmA7rF9loONXk2H.png" alt="image-20201023195541997.png" /></p>
<h3 id="75-死锁检测"><a class="markdownIt-Anchor" href="#75-死锁检测"></a> 7.5 死锁检测</h3>
<h4 id="单个实例"><a class="markdownIt-Anchor" href="#单个实例"></a> 单个实例</h4>
<p>将资源分配图中的资源类型节点去除，合并适当边，得到等待(wait-for)图</p>
<h4 id="多个实例"><a class="markdownIt-Anchor" href="#多个实例"></a> 多个实例</h4>
<p>银行家算法</p>
<h3 id="76-死锁恢复"><a class="markdownIt-Anchor" href="#76-死锁恢复"></a> 7.6 死锁恢复</h3>
<h4 id="进程终止"><a class="markdownIt-Anchor" href="#进程终止"></a> 进程终止</h4>
<ul>
<li>终止所有死锁进程</li>
<li>一次终止一个进程，直到消除死循环为止</li>
<li>最小代价(minimum cost): 按最小代价终止进程
<ul>
<li>优先级</li>
<li>计算时间</li>
<li>使用资源数量</li>
</ul>
</li>
</ul>
<h4 id="资源抢占"><a class="markdownIt-Anchor" href="#资源抢占"></a> 资源抢占</h4>
<ul>
<li>
<p>选择牺牲进程</p>
<p>最小代价</p>
</li>
<li>
<p>回滚</p>
<p>被抢占资源的进程回滚到安全状态，通常为重新执行该进程</p>
</li>
<li>
<p>饥饿</p>
<p>确保一个进程只能有限次数被选为牺牲进程，在代价因素中加上回滚次数</p>
</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>7.3 Consider the following snapshot of a system:<br />
Allocation Max Available<br />
<img src="https://i.loli.net/2020/10/23/qEJPmWyaANTzn54.png" alt="image-20201023200753433.png" style="zoom:80%;" /><br />
Answer the following questions using the banker’s algorithm:<br />
a. What is the content of the matrix Need?</p>
<p>P0: (0, 0, 0, 0), P1:(0, 7, 5, 0), P2:(1, 0, 0, 2), P3:(0, 0, 2, 0), P4:(0, 6, 4, 2)</p>
<p>b. Is the system in a safe state?</p>
<p>处于安全状态，P1或P3申请资源后会满足需求，然后释放资源，P3释放后的可用资源能满足剩下任意进程的资源需求</p>
<p>c. If a request from process P1 arrives for (0,4,2,0), can the request be<br />
granted immediately?</p>
<p>可以，P1申请资源后可用资源为(1, 1, 0, 0)，序列&lt;P0, P2, P3, P1, P4&gt;满足安全要求</p>
<p>7.6 Consider a computer system that runs 5,000 jobs per month and has no<br />
deadlock-prevention or deadlock-avoidance scheme. Deadlocks occur about twice per month, and the operator must terminate and rerun about ten jobs per deadlock. Each job is worth about two dollars (in CPU time), and the jobs terminated tend to be about half done when they are aborted.<br />
A systems programmer has estimated that a deadlock-avoidance<br />
algorithm (like the banker’s algorithm) could be installed in the system<br />
with an increase of about 10 percent in the average execution time per<br />
job. Since the machine currently has 30 percent idle time, all 5,000 jobs<br />
per month could still be run, although turnaround time would increase<br />
by about 20 percent on average.<br />
a. What are the arguments for installing the deadlock-avoidance<br />
algorithm?<br />
b. What are the arguments against installing the deadlock-avoidance<br />
algorithm?</p>
<p>同意：可以避免死锁的发生，并且由于有空闲时间，5000个作业仍能每月完成，没有太大影响</p>
<p>不同意：每月死锁发生次数不多，仅为2次，增加死锁避免方法产生的开销不如每月处理死锁产生的开销少</p>
<p>7.7 Can a system detect that some of its processes are starving? If you answer<br />
“yes,” explain how it can. If you answer “no,” explain how the system<br />
can deal with the starvation problem.</p>
<p>可以检测饥饿，先设置一个时间T用来判断进程是否为饥饿状态，当进程申请资源时，设置一个计时器开始计时，当时间超过T时，进程就被认为处于饥饿状态。</p>
<p>7.8 Consider the following resource-allocation policy. Requests for and<br />
releases of resources are allowed at any time. If a request for resources<br />
cannot be satisfied because the resources are not available, thenwe check<br />
any processes that are blocked waiting for resources. If a blocked process<br />
has the desired resources, then these resources are taken away from it<br />
and are given to the requesting process. The vector of resources for which<br />
the blocked process is waiting is increased to include the resources that<br />
were taken away.<br />
For example, a system has three resource types, and the vector<br />
Available is initialized to (4,2,2). If process P0 asks for (2,2,1), it gets<br />
them. If P1 asks for (1,0,1), it gets them. Then, if P0 asks for (0,0,1), it<br />
is blocked (resource not available). If P2 now asks for (2,0,0), it gets the<br />
available one (1,0,0), as well as one that was allocated to P0 (since P0 is<br />
blocked). P0’s Allocation vector goes down to (1,2,1), and its Need vector<br />
goes up to (1,0,1).<br />
a. Can deadlock occur? If you answer “yes,” give an example. If you<br />
answer “no,” specify which necessary condition cannot occur.<br />
b. Can indefinite blocking occur? Explain your answer.</p>
<p>a. 死锁不会发生，因为非抢占的特性被打破了，进程间可以抢占资源</p>
<p>b. 是的，如果一个进程需要多个常用资源，会经常被抢占资源，可能必须永久等待，即发生饥饿</p>
<p>7.10 Is it possible to have a deadlock involving only one single-threaded<br />
process? Explain your answer.</p>
<p>不可能，单线程进程中的线程顺序执行，不会发生死锁</p>
<p>7.17 Consider a system consisting of four resources of the same type that are<br />
shared by three processes, each of which needs at most two resources.<br />
Show that the system is deadlock free.</p>
<p>因为一个进程最多需要2个资源，让每个进程都处于占有并等待的状态，也就是每个进程都占有1个资源，请求1个资源。此时剩余1个资源，无论分配给哪个进程，都能满足需求，然后释放资源，满足另外的进程的请求。所以死锁不会发生。</p>
<p>7.19 Consider the version of the dining-philosophers problem in which the<br />
chopsticks are placed at the center of the table and any two of them<br />
can be used by a philosopher. Assume that requests for chopsticks are<br />
made one at a time. Describe a simple rule for determining whether a<br />
particular request can be satisfied without causing deadlock given the<br />
current allocation of chopsticks to philosophers.</p>
<p>当左边或右边的哲学家有筷子时，不能拿起筷子</p>
<p>7.21 We can obtain the banker’s algorithm for a single resource type from<br />
the general banker’s algorithm simply by reducing the dimensionality<br />
of the various arrays by 1. Show through an example that we cannot<br />
implement the multiple-resource-type banker’s scheme by applying the<br />
single-resource-type scheme to each resource type individually.</p>
<p>​	3 3</p>
<p>​		Allocation	Max	Availiable</p>
<p>​		A, B			 A, B	 A, B</p>
<p>p1    0, 0    		2, 2	 3, 3</p>
<p>p2    0, 0			1, 2</p>
<p>p3    0, 0     		2, 1</p>
<p>单资源分配时对于A、B来说&lt;p1, p2, p3&gt;都是安全序列，单双资源分配时&lt;P1, P2, P3&gt;不是安全序列，所以多资源分配时不能分别使单资源分配策略</p>
<p>7.22 Consider the following snapshot of a system:</p>
<img src="https://i.loli.net/2020/10/23/sKboN2awOEIUeXl.png" alt="image-20201023201000292.png" style="zoom:80%;" />
<p>Using the banker’s algorithm, determine whether or not each of the<br />
following states is unsafe. If the state is safe, illustrate the order in which<br />
the processes may complete. Otherwise, illustrate why the state is unsafe.<br />
a. Available = (0, 3, 0, 1)<br />
b. Available = (1, 0, 0, 2)</p>
<p>P0、P1、P2、P3、P4的需求矩阵为:</p>
<p>​		A B C D</p>
<p>P0	2 1 0 3</p>
<p>P1	1 0 0 1</p>
<p>P2	0 2 0 0</p>
<p>P3	4 1 0 2</p>
<p>P5	2 1 1 3</p>
<p>a. 不安全，进程P2, P1, P3可以完成，但剩余资源满足不了其他进程的请求</p>
<p>b. 安全，&lt;P1, P2, P0, P3, P4&gt;是一个安全序列，因此状态是安全的</p>
<p>7.23 Consider the following snapshot of a system:</p>
<img src="https://i.loli.net/2020/10/23/hXAgjS4rQqbF32E.png" alt="image-20201023201019048.png" style="zoom:80%;" />
<p>Answer the following questions using the banker’s algorithm:<br />
a. Illustrate that the system is in a safe state by demonstrating an<br />
order in which the processes may complete.<br />
b. If a request from process P1 arrives for (1, 1, 0, 0), can the request<br />
be granted immediately?<br />
c. If a request from process P4 arrives for (0, 0, 2, 0), can the request<br />
be granted immediately?</p>
<p>Need	A B C D 	Available</p>
<p>P0		2 2 1 1		3 3 2 1</p>
<p>P1		2 1 3 1</p>
<p>P2		0 2 1 3</p>
<p>P3		0 1 1 2		5 3 2 2</p>
<p>P4		2 2 3 2</p>
<p>a. &lt;P0, P3, P1, P2, P4&gt; 安全序列前两个为P0、P3,后面的P1、P2、P4可以随机排序</p>
<p>b. 可以，P1请求i(1, 1, 0, 0)后仍存在安全序列&lt;P0, P3, P1, P2, P4&gt;</p>
<p>C. 不行，P4请求(0, 0, 2, 0)后不存在安全序列</p>
<p>7.25 A single-lane bridge connects the two Vermont villages of North<br />
Tunbridge and South Tunbridge. Farmers in the two villages use this<br />
bridge to deliver their produce to the neighboring town. The bridge<br />
can become deadlocked if a northbound and a southbound farmer get<br />
on the bridge at the same time. (Vermont farmers are stubborn and are<br />
unable to back up.) Using semaphores and/or mutex locks, design an<br />
algorithm in pseudocode that prevents deadlock. Initially, do not be<br />
concerned about starvation (the situation in which northbound farmers<br />
prevent southbound farmers from using the bridge, or vice versa).</p>
<p>使用互斥信号量mutex，当有农夫上桥时将信号量mutex设为0, 下桥时设为1，当农夫想要上桥时需要等待信号量mutex = 1。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第8章 内存管理</title>
    <url>/2020/11/15/OS/%E7%AC%AC8%E7%AB%A0%20%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="内存管理"><a class="markdownIt-Anchor" href="#内存管理"></a> 内存管理</h2>
<h3 id="81-背景"><a class="markdownIt-Anchor" href="#81-背景"></a> 8.1 背景</h3>
<ul>
<li>CPU可以直接访问的通用存储只有内存和处理器内置的寄存器</li>
</ul>
<a id="more"></a>
<h4 id="811-内存保护"><a class="markdownIt-Anchor" href="#811-内存保护"></a> 8.1.1 内存保护</h4>
<ul>
<li><strong>Base register</strong> + <strong>Limit register</strong></li>
</ul>
<img src="https://i.loli.net/2020/11/15/cQfmXAuEvWOD6Ir.png" alt="image-20201112195903075.png" style="zoom:80%;" />
<img src="https://i.loli.net/2020/11/15/CMwhnZslgrbp2S3.png" alt="image-20201114163901044.png" style="zoom:80%;" />
<h4 id="812-地址绑定"><a class="markdownIt-Anchor" href="#812-地址绑定"></a> 8.1.2 地址绑定</h4>
<ul>
<li>将符号地址(<strong>Symbolic address</strong>)绑定到可重定位的地址(<strong>relocatable address</strong>)</li>
<li>将可重定位的地址(<strong>Relocatable address</strong>)绑定到绝对地址(<strong>absolute address</strong>)</li>
</ul>
<h5 id="编译时"><a class="markdownIt-Anchor" href="#编译时"></a> 编译时</h5>
<ul>
<li>如果在编译时可知，那么就生成绝对代码</li>
<li>地址发生变化需要重编译</li>
</ul>
<h5 id="加载时"><a class="markdownIt-Anchor" href="#加载时"></a> 加载时</h5>
<ul>
<li>生成可重定位代码</li>
</ul>
<h5 id="执行时"><a class="markdownIt-Anchor" href="#执行时"></a> 执行时</h5>
<ul>
<li>绑定延迟到执行时，需要硬件支持</li>
</ul>
<h4 id="813-逻辑地址空间与物理地址空间"><a class="markdownIt-Anchor" href="#813-逻辑地址空间与物理地址空间"></a> 8.1.3 逻辑地址空间与物理地址空间</h4>
<ul>
<li>
<p>CPU生成的地址通常称为逻辑地址，而内存单元看到的地址通常称为物理地址</p>
</li>
<li>
<p>编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。执行时的地址绑定方案生成不同的逻辑地址和物理地址</p>
</li>
</ul>
<h5 id="内存管理单元mmu"><a class="markdownIt-Anchor" href="#内存管理单元mmu"></a> 内存管理单元(MMU)</h5>
<ul>
<li>从虚拟地址到物理地址的运行时映射的硬件设备</li>
<li>用户进程所生成的地址在送交内存之前，需要加上重定位寄存器(<strong>relocation register</strong>)的值</li>
</ul>
<img src="https://i.loli.net/2020/11/15/tSg9znxZ4shLUEf.png" alt="image-20201112201932270.png" style="zoom:80%;" />
<h4 id="814-动态加载"><a class="markdownIt-Anchor" href="#814-动态加载"></a> 8.1.4 动态加载</h4>
<ul>
<li>
<p>依据局部性原理(principle of locality of reference)</p>
</li>
<li>
<p>加载之前：可重定位代码</p>
</li>
<li>
<p>检查程序是否加载，如果没有，可重定位链接程序(<strong>dynamic linking loader</strong>)会加载所需的程序到内存，并更新程序的地址表以反映这一变化，然后控制传递给新加载的程序</p>
</li>
</ul>
<h4 id="815-动态链接"><a class="markdownIt-Anchor" href="#815-动态链接"></a> 8.1.5 动态链接</h4>
<h5 id="装入时动态链接load-time-dynamic-linking"><a class="markdownIt-Anchor" href="#装入时动态链接load-time-dynamic-linking"></a> 装入时动态链接(Load-time dynamic linking)</h5>
<p>根据外部调用和引用，加载程序找到所需的对象模块和库，并将它们加载到内存中</p>
<h5 id="运行时动态链接dynamic-linking"><a class="markdownIt-Anchor" href="#运行时动态链接dynamic-linking"></a> 运行时动态链接(Dynamic Linking)</h5>
<ul>
<li>每个库程序的引用都有一个存根</li>
<li>存根是一小段代码，用来指出如何定位适当的内存驻留库程序</li>
<li>存根先检查所需程序是否在内存中，并将其加入</li>
<li>存根用程序地址替换自身，并执行程序</li>
</ul>
<p>Advantage: 加载时间短、存储空间少</p>
<h3 id="82-交换"><a class="markdownIt-Anchor" href="#82-交换"></a> 8.2 交换</h3>
<ul>
<li>备份存储大部分是快速磁盘，提供对这些存储器映像的直接访问</li>
</ul>
<h3 id="83-连续内存分配contiguous-memory-allocation"><a class="markdownIt-Anchor" href="#83-连续内存分配contiguous-memory-allocation"></a> 8.3 连续内存分配(Contiguous Memory Allocation)</h3>
<h4 id="831-单一连续"><a class="markdownIt-Anchor" href="#831-单一连续"></a> 8.3.1 单一连续</h4>
<ul>
<li>内存分为两个区域：一个用于驻留OS，一个用于用户进程</li>
</ul>
<img src="https://i.loli.net/2020/11/15/CMwhnZslgrbp2S3.png" alt="image-20201114163901044.png" style="zoom:80%;" />
<h4 id="832-多分区分配"><a class="markdownIt-Anchor" href="#832-多分区分配"></a> 8.3.2 多分区分配</h4>
<p>多个用户进程同时驻留在内存中</p>
<ul>
<li>用户分区分为n个</li>
<li>每个分区可能只包含一个进程
<ol>
<li>当分区空闲时，选择输入队列中的进程并将其加载到空闲分区</li>
<li>进程终止时，释放内存</li>
</ol>
</li>
<li>分区数量决定<strong>多道程序度</strong></li>
</ul>
<h5 id="固定分区"><a class="markdownIt-Anchor" href="#固定分区"></a> 固定分区</h5>
<ul>
<li>将内存分为多个固定大小的分区</li>
</ul>
<p>缺点：内存利用率低，内部碎片大</p>
<h5 id="动态分区"><a class="markdownIt-Anchor" href="#动态分区"></a> 动态分区</h5>
<ul>
<li>起初，所有的内存为一个大洞</li>
<li>根据需求分配内存给进程</li>
<li>释放内存时合并孔</li>
</ul>
<p>OS管理：</p>
<ol>
<li>分区分配</li>
<li>可用分区
<ul>
<li>分区表</li>
<li>分区list</li>
</ul>
</li>
</ol>
<h5 id="动态分配问题"><a class="markdownIt-Anchor" href="#动态分配问题"></a> 动态分配问题</h5>
<p>First-fit:第一个足够大的孔</p>
<p>Next-fit:第二个足够大的孔</p>
<p>Best-fit:最小的足够大的孔</p>
<p>Worst-fit:最大的足够大的孔</p>
<p>优点：随着进程的换入换出，分区的数量，大小和位置都会动态变化；它十分灵活，可以提高内存利用率，避免由固定分区的不适当分区大小引起的内部碎片</p>
<p>缺点：随着分配的进行，可用分区分散在内存中；尽管进行了回收，内存仍被分成越来越多的碎片，形成大量的外部碎片(存储被分成了大量的小孔)</p>
<h4 id="833-碎片fragmentation"><a class="markdownIt-Anchor" href="#833-碎片fragmentation"></a> 8.3.3 碎片(Fragmentation)</h4>
<p><strong>内部碎片</strong></p>
<p>进程所分配的内存比所需的大，这两个数字之差为内部碎片，这部分内存在分区内部，但不能用</p>
<p><strong>外部碎片</strong></p>
<p>总的可用内存之和可以满足请求但并不连续(存储被分成了大量的小孔)</p>
<h5 id="紧缩"><a class="markdownIt-Anchor" href="#紧缩"></a> 紧缩</h5>
<ul>
<li>移动内存内容，将所有空闲空间合并成一整块</li>
<li>只有重定位是动态的，并在运行时进行，才可采用紧缩</li>
</ul>
<h3 id="84-分段segmentation"><a class="markdownIt-Anchor" href="#84-分段segmentation"></a> 8.4 分段(Segmentation)</h3>
<h4 id="841-分段策略"><a class="markdownIt-Anchor" href="#841-分段策略"></a> 8.4.1 分段策略</h4>
<ul>
<li>
<p>支持用户视图的内存管理方案</p>
</li>
<li>
<p>逻辑地址空间由一组段构成</p>
</li>
<li>
<p>每个段有名称和长度</p>
<p>​	&lt;段号，偏移&gt;</p>
</li>
</ul>
<h4 id="842-分段硬件"><a class="markdownIt-Anchor" href="#842-分段硬件"></a> 8.4.2 分段硬件</h4>
<h5 id="段表"><a class="markdownIt-Anchor" href="#段表"></a> 段表</h5>
<ul>
<li>映射用户定义的二维地址到一维物理地址</li>
<li><strong>段基地址</strong>：段在内存中的开始物理地址</li>
<li><strong>段界限</strong>：该段的长度</li>
</ul>
<img src="https://i.loli.net/2020/11/15/UFlkGqPcpMDLsAz.png" alt="image-20201115124939794.png" style="zoom:80%;" />
<h5 id="基本段表硬件"><a class="markdownIt-Anchor" href="#基本段表硬件"></a> 基本段表硬件</h5>
<ul>
<li>
<p><strong>段表基址寄存器(STBR)</strong></p>
</li>
<li>
<p><strong>段表长度寄存器(STLR)</strong></p>
<p><strong>s</strong> is legal if <strong>s &lt; STLR</strong></p>
</li>
</ul>
<img src="https://i.loli.net/2020/11/15/cHzwNihYZmtkI1s.png" alt="image-20201115125245923.png" style="zoom:80%;" />
<h3 id="85-分页"><a class="markdownIt-Anchor" href="#85-分页"></a> 8.5 分页</h3>
<ul>
<li><strong>帧/物理页框</strong>：将物理内存分为固定大小的块</li>
<li><strong>页</strong>：将逻辑内存分为同样大小的块</li>
</ul>
<h4 id="851-分页策略"><a class="markdownIt-Anchor" href="#851-分页策略"></a> 8.5.1 分页策略</h4>
<ul>
<li><strong>页码(p)</strong>：页表的索引</li>
<li><strong>页偏移(d)</strong>：与基地址相加得到物理地址</li>
</ul>
<h5 id="页表"><a class="markdownIt-Anchor" href="#页表"></a> 页表</h5>
<p>页码作为页表的索引，页表包含每页所在物理内存的基地址</p>
<h5 id="页"><a class="markdownIt-Anchor" href="#页"></a> 页</h5>
<img src="https://i.loli.net/2020/11/15/AHrROUKzdGZXlax.png" alt="image-20201114202647441.png" style="zoom:80%;" />
<h5 id="帧表"><a class="markdownIt-Anchor" href="#帧表"></a> 帧表</h5>
<p>由于操作系统管理物理内存，它需要知道物理内存的分配细节：哪些帧已分配、哪些帧可用、总共有多少帧……</p>
<h4 id="852-硬件支持"><a class="markdownIt-Anchor" href="#852-硬件支持"></a> 8.5.2 硬件支持</h4>
<h5 id="基本页表硬件"><a class="markdownIt-Anchor" href="#基本页表硬件"></a> 基本页表硬件</h5>
<ul>
<li>
<p>页表存放在主存中</p>
</li>
<li>
<p><strong>页表基址寄存器(PTBR)</strong></p>
</li>
<li>
<p><strong>页表长度寄存器(PTLR)</strong></p>
</li>
</ul>
<img src="https://i.loli.net/2020/11/15/D6ZKAXI73eMCkrw.png" alt="image-20201115103614025.png" style="zoom:80%;" />
<p><strong>Effective memory-Access (EAT, 有效访问时间)</strong></p>
<ul>
<li>访问一个字节需要两次内存访问(一次用于页表，一次用于字节)</li>
</ul>
<h5 id="转换表缓冲区translation-look-aside-buffer-tlb"><a class="markdownIt-Anchor" href="#转换表缓冲区translation-look-aside-buffer-tlb"></a> 转换表缓冲区(Translation Look-aside Buffer, TLB)</h5>
<p>关联的高速内存</p>
<ul>
<li>
<p>每个条目由键和值组成</p>
</li>
<li>
<p>同时与所有的键进行比较(高速)</p>
</li>
<li>
<p>代价昂贵，通常存储8~2048条目</p>
</li>
</ul>
<p><strong>TLB miss</strong></p>
<p>如果页码在TLB中，则取得帧码；如果页码不在TLB中，则需访问页表，并将页码和帧码添加到TLB</p>
<img src="https://i.loli.net/2020/11/15/mhqbwU7ivBYASes.png" alt="image-20201115101834743.png" style="zoom:80%;" />
<p><strong>命中率</strong></p>
<p>TLB中找到页码的次数的百分比</p>
<img src="https://i.loli.net/2020/11/15/urOWgJ79HkL1Bab.png" alt="image-20201115102615443.png" style="zoom:80%;" />
<h4 id="853-保护"><a class="markdownIt-Anchor" href="#853-保护"></a> 8.5.3 保护</h4>
<ul>
<li>通过检查保护位来验证有没有进行正确操作</li>
</ul>
<p><strong>有效-无效位</strong></p>
<p>有效表示相关页在进程的逻辑地址空间内，无效表示相关页不在进程的逻辑地址空间内</p>
<h4 id="854-共享页"><a class="markdownIt-Anchor" href="#854-共享页"></a> 8.5.4 共享页</h4>
<ul>
<li>
<p><strong>可重入代码</strong>是不能自我修改的代码，它在执行期间不会改变，所有进程中的共享代码逻辑地址必须相同</p>
</li>
<li>
<p>每个进程都有自己的寄存器副本和数据</p>
</li>
</ul>
<img src="https://i.loli.net/2020/11/15/nXDgjBMcYWLew67.png" alt="image-20201115121128880.png" style="zoom:80%;" />
<h3 id="86-页表结构"><a class="markdownIt-Anchor" href="#86-页表结构"></a> 8.6 页表结构</h3>
<h4 id="861-分层页表"><a class="markdownIt-Anchor" href="#861-分层页表"></a> 8.6.1 分层页表</h4>
<img src="https://i.loli.net/2020/11/15/GWvS6yKgdrMkO5Z.png" alt="image-20201115121813907.png" style="zoom:80%;" />
<h4 id="862-哈希页表"><a class="markdownIt-Anchor" href="#862-哈希页表"></a> 8.6.2 哈希页表</h4>
<p>处理大于32位地址空间的常用方法是使用哈希页表</p>
<ul>
<li>哈希页表的每一个条目都包含一个链表</li>
<li>每个元素由三个字段组成：
<ul>
<li>虚拟页码</li>
<li>映射的帧码</li>
<li>指向链表内下一元素的指针</li>
</ul>
</li>
</ul>
<p><strong>Algorithm</strong></p>
<p>虚拟地址的虚拟页码哈希到哈希表，用虚拟页码与链表内的元素的字段逐一比较。如果匹配，则相应帧码形成物理地址</p>
<img src="https://i.loli.net/2020/11/15/YbXlUROckj9Bv4q.png" alt="image-20201115122659927.png" style="zoom:80%;" />
<h4 id="863-倒置页表inverted-page-tables"><a class="markdownIt-Anchor" href="#863-倒置页表inverted-page-tables"></a> 8.6.3 倒置页表(Inverted Page Tables)</h4>
<ul>
<li>对于每个真正的内存页或帧，倒置页表才有一个条目</li>
<li>每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息</li>
</ul>
<p><strong>Advantage</strong></p>
<ul>
<li>整个系统只有一个页表</li>
<li>减少存储页表所需的内存</li>
</ul>
<p><strong>Disadvantage</strong></p>
<ul>
<li>发生页面引用时增加了搜索表所需的时间</li>
<li>可以使用哈希表将搜索限制为一个或最多几个页表条目</li>
</ul>
<img src="https://i.loli.net/2020/11/15/B3962dygNMVTEhJ.png" alt="image-20201115123142089.png" style="zoom:80%;" />
<h3 id="87-分页与分段的区别"><a class="markdownIt-Anchor" href="#87-分页与分段的区别"></a> 8.7 分页与分段的区别</h3>
<h4 id="动机和目的"><a class="markdownIt-Anchor" href="#动机和目的"></a> 动机和目的</h4>
<ul>
<li>分页：<strong>面向系统、物理上离散、减少外部和内部碎片、提高内存利用率</strong>；页是信息的物理单元</li>
<li>分段：<strong>面向用户，逻辑上离散，满足用户需求</strong>；段是具有相对完整含义的信息的逻辑单元</li>
</ul>
<h4 id="大小"><a class="markdownIt-Anchor" href="#大小"></a> 大小</h4>
<ul>
<li>分页：大小固定，由硬件决定</li>
<li>分段：大小不固定，由程序和编译时决定</li>
</ul>
<h4 id="维度"><a class="markdownIt-Anchor" href="#维度"></a> 维度</h4>
<ul>
<li>分页：一维</li>
<li>分段：二维</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p>8.1 Name two differences between logical and physical addresses.</p>
<p>逻辑地址由CPU生成，物理地址由MMU生成。逻辑地址对用户是可视的，物理地址对用户是不可视的。逻辑地址通过MMU转化成物理地址。</p>
<p>8.2 Consider a system in which a program can be separated into two<br />
parts: code and data. The CPU knows whether it wants an instruction<br />
(instruction fetch) or data (data fetch or store). Therefore, two base–<br />
limit register pairs are provided: one for instructions and one for data.<br />
The instruction base–limit register pair is automatically read-only, so<br />
programs can be shared among different users. Discuss the advantages<br />
and disadvantages of this scheme.</p>
<p>可以共享公共代码。因为指令的寄存器对只读，所以代码为可重入代码，可以保存一个编辑器的副本，每个用户的页表映射到编辑器的同一物理副本，减少内存使用。同时由于只读，可以保证代码不会被修改。缺点是代码和数据需要分开，每个进程需要有自己的私有数据，并存储到不同的物理地址。</p>
<p>8.3 Why are page sizes always powers of 2?</p>
<p>对于m位的CPU来说，分页将地址分为页码m-n位和页偏移n位，每一位都代表着2个幂，其中页大小为2^n ，页的逻辑地址空间为2^(m-n)，所以页大小总为2的幂</p>
<p>8.4 Consider a logical address space of 64 pages of 1,024 words each, mapped<br />
onto a physical memory of 32 frames.<br />
a. How many bits are there in the logical address?</p>
<p>2^6 * 2^10 = 2^16</p>
<p>b. How many bits are there in the physical address?</p>
<p>2^5 * 2^10 = 2^15</p>
<p>8.5 What is the effect of allowing two entries in a page table to point to the<br />
same page frame in memory? Explain how this effect could be used to<br />
decrease the amount of time needed to copy a large amount of memory<br />
from one place to another. What effect would updating some byte on the<br />
one page have on the other page?</p>
<p>可以共享代码和数据。当需要重复多次执行代码时，每个进程使用相同的公共代码，页表映射到同一物理地址，不需要每次都复制内存，减少内存的使用。但如果对一个页中的代码进行修改，其余使用这份共享代码的页也会受到影响。</p>
<p>8.6 Describe a mechanism by which one segment could belong to the address<br />
space of two different processes.</p>
<p>两个进程的段表中的条目指向同一物理地址。两个进程中的共享段的段号要相同。</p>
<p>8.7 Sharing segments among processes without requiring that they have the<br />
same segment number is possible in a dynamically linked segmentation<br />
system.<br />
a. Define a system that allows static linking and sharing of segments<br />
without requiring that the segment numbers be the same.<br />
b. Describe a paging scheme that allows pages to be shared without<br />
requiring that the page numbers be the same.</p>
<p>这两个问题都简化为一个程序可以引用自己的代码和数据，却不知道该段或页面<br />
与地址关联的数字。 MULTICS通过以下方式解决了这个问题：每个进程将四个寄存器关联起来。一个寄存器具有当前程序段的地址，另一个寄存器具有堆栈的基地址，另一个寄存器具有全局数据的基地址，依此类推。这个想法是所有引用都必须通过映射到当前段或页码的寄存器进行间接访问。通过更改这些寄存器，可以在没有相同页码或段号的情况下针对不同的进程执行相同的代码。</p>
<p>8.9 Explain the difference between internal and external fragmentation.</p>
<p>进程所分配的内存比所需的大，这两个数字之差为内部碎片，这部分内存在分区内部，但不能用。外部碎片是存储被分成了大量的小孔，总的总的可用内存之和可以满足请求但并不连续。</p>
<p>8.12 Most systems allow a program to allocate more memory to its address<br />
space during execution. Allocation of data in the heap segments of<br />
programs is an example of such allocated memory. What is required<br />
to support dynamic memory allocation in the following schemes?<br />
a. Contiguous memory allocation<br />
b. Pure segmentation<br />
c. Pure paging</p>
<p>a. 可能需要整个程序重定位</p>
<p>b. 可能需要段重定位</p>
<p>c. 可以增加分配新页面，而无需重新定位程序的地址空间</p>
<p>paging物理上是不连续的</p>
<p>8.13 Compare the memory organization schemes of contiguous memory<br />
allocation, pure segmentation, and pure paging with respect to the<br />
following issues:<br />
a. External fragmentation<br />
b. Internal fragmentation<br />
c. Ability to share code across processes</p>
<p>a. contiguous memory 、pure segmentation有外部碎片的问题，当旧进程结束，新进程加入时，由于进程长度不一，会产生小孔，重复多次会产生大量的小孔，形成外部碎片。而pure paging没有这种情况。</p>
<p>b. contiguous memory、pure segmentation没有内部碎片的问题，pure paging由于分配的内存可能大于所需内存，会产生内部碎片</p>
<p>c. contiguous memory不允许共享代码，pure segmentation和pure paging可以有共享代码，只需保证代码是可重入代码，进程中的共享代码逻辑地址相同。</p>
<p>8.14 On a system with paging, a process cannot access memory that it does<br />
not own. Why? How could the operating system allow access to other<br />
memory? Why should it or should it not?</p>
<p>PTLR和PTBR会限制进程只访问页表中的条目。如果操作系统允许非进程内存条目进入进程页表，它将提供对其他内存的访问。</p>
<p>8.17 Compare paging with segmentation with respect to how much memory<br />
the address translation structures require to convert virtual addresses to<br />
physical addresses.</p>
<p>分页需要的内存量更多</p>
<p>分页每页需要一个条目，每个条目存储一个页面映射的物理地址</p>
<p>分段只需要两个寄存器，一个寄存器管理段基址，一个寄存器管理段长</p>
<p>8.19 Program binaries in many systems are typically structured as follows.<br />
Code is stored starting with a small, fixed virtual address, such as 0. The<br />
code segment is followed by the data segment that is used for storing<br />
the program variables. When the program starts executing, the stack is<br />
allocated at the other end of the virtual address space and is allowed<br />
to grow toward lower virtual addresses. What is the significance of this<br />
structure for the following schemes?<br />
a. Contiguous memory allocation<br />
b. Pure segmentation<br />
c. Pure paging</p>
<p>a. b. 可以重定位程序位置来分配新内存，c. 可以新增页</p>
<p>8.20 Assuming a 1-KB page size, what are the page numbers and offsets for<br />
the following address references (provided as decimal numbers):<br />
a. 3085</p>
<p>p: 3	d: 13</p>
<p>b. 42095</p>
<p>p: 41	d: 111</p>
<p>c. 215201</p>
<p>p: 210	d: 161</p>
<p>d. 650000</p>
<p>p: 634	d: 784</p>
<p>e. 2000001</p>
<p>p: 1953	d: 129</p>
<p>8.22 What is the maximum amount of physical memory?</p>
<p>取决于系统硬件</p>
<p>8.23 Consider a logical address space of 256 pages with a 4-KB page size,<br />
mapped onto a physical memory of 64 frames.<br />
a. How many bits are required in the logical address?</p>
<p>20</p>
<p>b. How many bits are required in the physical address?<br />
18</p>
<p>8.24 Consider a computer system with a 32-bit logical address and 4-KB page<br />
size. The system supports up to 512 MB of physical memory. How many<br />
entries are there in each of the following?</p>
<p>2^29 / 2^12 = 2^17</p>
<p>8.25 Consider a paging system with the page table stored in memory.<br />
a. If a memory reference takes 50 nanoseconds, how long does a<br />
paged memory reference take?</p>
<p>100 ns</p>
<p>b. If we add TLBs, and 75 percent of all page-table references are found<br />
in the TLBs, what is the effective memory reference time? (Assume<br />
that finding a page-table entry in the TLBs takes 2 nanoseconds, if<br />
the entry is present.)</p>
<p>EAT = 0.75 * (52) + 0.25 * (102) = 64.5ns</p>
<p>8.26 Why are segmentation and paging sometimes combined into one<br />
scheme?</p>
<p>当页表变得非常大时，分段式分页很有用。可以将未使用的页表的大连续部分折叠为一个页表地址为零的单个段表条目。 通过分页段，我们减少了因外部碎片而造成的内存浪费，并简化了分配。</p>
<p>8.27 Explain why sharing a reentrant module is easier when segmentation is<br />
used than when pure paging is used.</p>
<p>由于分段是基于内存的逻辑划分而不是物理划分，因此任何大小的分段都只能与每个用户的分段表中的一项共享。 使用分页时，页面表中必须为每个共享页面共享一个公共条目。</p>
<p>8.28 Consider the following segment table:<br />
<img src="https://i.loli.net/2020/11/15/qOJ7iy2cUBjpkV1.png" alt="image-20201115131458354.png" style="zoom:80%;" /><br />
What are the physical addresses for the following logical addresses?<br />
a. 0,430<br />
b. 1,10<br />
c. 2,500<br />
d. 3,400<br />
e. 4,112</p>
<p>a. 649</p>
<p>b. 2310</p>
<p>c. illegal</p>
<p>d. 1727</p>
<p>e. illegal</p>
<p>8.29 What is the purpose of paging the page tables?</p>
<p>当页表太大，较难管理时，需要对页表进行分页</p>
<p>8.31 Compare the segmented paging scheme with the hashed page table<br />
scheme for handling large address spaces. Under what circumstances is<br />
one scheme preferable to the other?</p>
<p>当程序仅占据其大型虚拟地址空间的一小部分时，由于其较小的大小，因此可能首选哈希页表。 但是，哈希页面表的缺点是由于将多个页面映射到同一哈希页面表项中的冲突而引起的问题。 如果许多页面映射到同一个条目，则遍历与该哈希表条目相对应的列表可能会产生大量开销； 这样的开销在分段式分页方案中是最小的，在分页式分页方案中，每个页表项仅维护有关一个页面的信息。</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第9章 虚拟内存管理</title>
    <url>/2020/11/22/OS/%E7%AC%AC9%E7%AB%A0%20%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="虚拟内存管理"><a class="markdownIt-Anchor" href="#虚拟内存管理"></a> 虚拟内存管理</h2>
<h3 id="91-背景"><a class="markdownIt-Anchor" href="#91-背景"></a> 9.1 背景</h3>
<h4 id="virtual-memory"><a class="markdownIt-Anchor" href="#virtual-memory"></a> Virtual Memory</h4>
<a id="more"></a>
<p>是指具有请求调页功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统</p>
<p><strong>虚拟内存</strong> = <strong>物理内存</strong> + <strong>磁盘</strong></p>
<ul>
<li>
<p>多次性</p>
<p>一个作业被分成多次装入内存运行</p>
</li>
<li>
<p>对换性</p>
<p>允许在进程运行的过程中，(部分)换入换出</p>
</li>
<li>
<p>虚拟性</p>
<p>逻辑上的扩充</p>
</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p>进程共享内存和文件</p>
</li>
<li>
<p>加速进程创建</p>
</li>
<li>
<p>程序员不用关系内存限制</p>
</li>
<li>
<p>可以同时运行更多程序</p>
</li>
<li>
<p>更少的I/O需求，程序运行更快</p>
</li>
</ul>
<h3 id="92-请求调页demand-paging"><a class="markdownIt-Anchor" href="#92-请求调页demand-paging"></a> 9.2 请求调页(Demand Paging)</h3>
<h4 id="921-基本概念"><a class="markdownIt-Anchor" href="#921-基本概念"></a> 9.2.1 基本概念</h4>
<h5 id="swapper-vs-pager"><a class="markdownIt-Anchor" href="#swapper-vs-pager"></a> Swapper VS. Pager</h5>
<ul>
<li>交换器操纵整个进程</li>
<li>处理单个页面的swapper是pager</li>
</ul>
<p><strong>惰性交换器(Lazy swapper)</strong></p>
<p>除非需要某个页面，否则从不将它交换到内存中</p>
<h5 id="修改页表机制有效无效位"><a class="markdownIt-Anchor" href="#修改页表机制有效无效位"></a> 修改页表机制(有效无效位)</h5>
<p>v	⇒	in-memory &amp; logical</p>
<p>i 	⇒	not-in-memory 或者有效但只在磁盘上</p>
<h5 id="page-fault"><a class="markdownIt-Anchor" href="#page-fault"></a> Page Fault</h5>
<p>请求调页的关键要求是在缺页错误后重新启动任何指令的能力。当发生<strong>page fault</strong>时，<strong>保存被中断的进程状态</strong>，在完全相同的位置和状态下，重新启动进程。如果在获取指令时出现了缺页错误，那么再次获取指令</p>
<h5 id="page-fault-handling"><a class="markdownIt-Anchor" href="#page-fault-handling"></a> Page Fault Handling</h5>
<ol>
<li>检查进程的内部表(通常与PCB一起保存)，确定该引用是有效的还是无效的</li>
<li>如果引用无效，那么终止进程，如果引用有效但尚未调入页面，则调入</li>
<li>找到一个空闲帧</li>
<li>调度一个磁盘操作，以将所需页面读到刚分配的帧</li>
<li>修改进程的内部表和页表，设置v</li>
<li>重新启动被缺页错误中断的指令</li>
</ol>
<img src="https://i.loli.net/2020/11/22/WYz1rBUaP2gjTwm.png" alt="image-20201122150607589.png" style="zoom:80%;" />
<h5 id="address-translation"><a class="markdownIt-Anchor" href="#address-translation"></a> Address translation</h5>
<p>Address translation hardware + page fault handling</p>
<img src="https://i.loli.net/2020/11/22/9UVHJMWhopwvRSk.png" alt="image-20201122152004936.png" style="zoom:80%;" />
<h4 id="922-请求调页的性能"><a class="markdownIt-Anchor" href="#922-请求调页的性能"></a> 9.2.2 请求调页的性能</h4>
<h5 id="eat"><a class="markdownIt-Anchor" href="#eat"></a> EAT</h5>
<p>p = <strong>Page Fault Rate</strong>(0 ≤ p ≤ 1.0)</p>
<p><strong>EAT</strong> = (1 - p) × memory access + p × page fault time</p>
<p>缺页错误时间 = 缺页错误开销 + 换出页面(optional) + 读入页面 + 重启进程</p>
<ul>
<li>程序执行局部化可以降低<strong>page fault rate</strong></li>
</ul>
<h5 id="交换空间"><a class="markdownIt-Anchor" href="#交换空间"></a> 交换空间</h5>
<p>前提：交换空间的文件系统更快</p>
<ol>
<li>
<p>系统可以在进程启动时将<strong>整个文件映像复制到交换空间中</strong>，然后从交换空间执行请求调页，从而获得更好的分页吞吐量</p>
</li>
<li>
<p>开始时从文件系统进行请求调页，但在<strong>置换页面时将页面写入交换空间</strong>。这种方法确保<strong>只从文件系统读取所需的页面</strong>，后续调页都是从交换空间完成的</p>
</li>
</ol>
<h3 id="93-写时复制copy-on-write"><a class="markdownIt-Anchor" href="#93-写时复制copy-on-write"></a> 9.3 写时复制(Copy-on-Write)</h3>
<p>​		允许父进程和子进程最初共享内存中的相同页面。如果任一进程修改了共享页面，则将创建共享页面的副本，因为仅复制修改过的页面，所以COW更有效地创建进程。</p>
<p>​		假设子进程试图修改包含部分堆栈的页面，并且设置为写时复制。操作系统会创建这个页面的副本，将其映射到子进程的地址空间。然后，子进程会修改复制的页面，而不是属于父进程的页面</p>
<p>​		操作系统为这类请求提供了一个空闲的页面池**(page pool)<strong>，空闲页面从页面池中分配。分配这些页面的技术称为</strong>按需填零(zero-fill-on-demand)**技术，页面在分配前先填零，清除以前的内容</p>
<h3 id="94-页面置换"><a class="markdownIt-Anchor" href="#94-页面置换"></a> 9.4 页面置换</h3>
<p><strong>over-allocation</strong>:为了增加多道程序，可能会导致过度分配，没有空闲帧，所有的内存都在使用</p>
<ul>
<li>页面置换是请求调页的基础，它完成了逻辑内存和物理内存之间的分离</li>
</ul>
<p>算法评估：针对特定内存引用串，运行某个置换算法，并计算缺页错误的数量</p>
<ul>
<li>页面错误数量取决于进程分配的帧的数量</li>
</ul>
<h4 id="941-基本页面置换"><a class="markdownIt-Anchor" href="#941-基本页面置换"></a> 9.4.1 基本页面置换</h4>
<ol>
<li>
<p>找到所需页面的磁盘位置</p>
</li>
<li>
<p>找到空闲帧</p>
<p>a. 如果有空闲帧，使用它</p>
<p>b. 如果没有空闲帧，使用页面置换算法来选择一个牺牲帧**(victim frame)**</p>
<p>c. 将牺牲帧的内容写到磁盘上，修改对应的页表和帧表</p>
</li>
<li>
<p>将所需页面读入(新的)空闲帧，修改页表和帧表</p>
</li>
<li>
<p>从发生缺页错误位置，继续用户进程</p>
</li>
</ol>
<img src="https://i.loli.net/2020/11/22/zQCIvYSElZ9ULh7.png" alt="image-20201122161446738.png" style="zoom:80%;" />
<p>​		稍后，<strong>对该页面的引用将导致缺页错误</strong>。那时，页面将被调回到内存</p>
<h5 id="修改位modify-bit-脏位dirty-bit"><a class="markdownIt-Anchor" href="#修改位modify-bit-脏位dirty-bit"></a> 修改位(modify bit) / 脏位(dirty bit)</h5>
<p>​		当要选择一个页面进行置换时，就检查它的修改位。如果该位已被设置，那么该页面从磁盘读入以后已被修改。在这种情况下，应将页面写入磁盘。然而，如果修改位未被设置，那么该页面从磁盘读入以后还未被修改。在这种情况下，我们不需要将内存页面写到磁盘因为它已经存在。</p>
<h4 id="942-fifo页面置换"><a class="markdownIt-Anchor" href="#942-fifo页面置换"></a> 9.4.2 FIFO页面置换</h4>
<p>选择最旧的页面进行置换</p>
<img src="https://i.loli.net/2020/11/22/DF7e8rzQcBnqytN.png" alt="image-20201122164853072.png" style="zoom:80%;" />
<h5 id="beladys-anomaly贝莱迪异常现象"><a class="markdownIt-Anchor" href="#beladys-anomaly贝莱迪异常现象"></a> Belady’s anomaly(贝莱迪异常现象)</h5>
<img src="https://i.loli.net/2020/11/22/lXT8cdpJ9myknaM.png" alt="image-20201122165117164.png" style="zoom:80%;" />
<h4 id="943-最优页面置换"><a class="markdownIt-Anchor" href="#943-最优页面置换"></a> 9.4.3 最优页面置换</h4>
<ul>
<li>置换最长时间不会使用的页面</li>
</ul>
<p>然而，因为需要引用串的未来知识，难以实现，最优算法主要用于比较研究</p>
<h4 id="944-lru页面置换"><a class="markdownIt-Anchor" href="#944-lru页面置换"></a> 9.4.4 LRU页面置换</h4>
<p><strong>最近最少使用算法(Least-Recent-Used algorithm)</strong></p>
<ul>
<li>LRU置换将每个页面与它的上次使用的时间关联起来。当需要置换页面时，LRU选择最长时间没有使用的页面。</li>
</ul>
<h5 id="计数器实现"><a class="markdownIt-Anchor" href="#计数器实现"></a> 计数器实现</h5>
<ul>
<li>
<p>每个页表条目关联一个使用时间域，并为CPU添加一个逻辑时钟</p>
</li>
<li>
<p>每当进行页面引用时，复制时钟寄存器的内容到页表条目的使用时间域中</p>
<p>​	(每次内存访问都要写到内存)</p>
</li>
<li>
<p>当需要页面置换时，搜索页表，选择具有最小时间的页面</p>
</li>
</ul>
<h5 id="堆栈实现"><a class="markdownIt-Anchor" href="#堆栈实现"></a> 堆栈实现</h5>
<p>使用具有首指针和尾指针的双向链表实现</p>
<ul>
<li>
<p>每当页面被引用时，就从堆栈中移除并放在顶部</p>
<p>​	(可能每次需要改变6个指针)</p>
</li>
<li>
<p>更新有点费时，但置换不用搜索</p>
</li>
</ul>
<p>栈底页面就是LRU页面</p>
<img src="https://i.loli.net/2020/11/22/cBsnDGN6TljQf1M.png" alt="image-20201122172558599.png" style="zoom:80%;" />
<h4 id="945-近似lru页面置换"><a class="markdownIt-Anchor" href="#945-近似lru页面置换"></a> 9.4.5 近似LRU页面置换</h4>
<p><strong>引用位</strong></p>
<p><strong>每当引用一个页面时，它的页面引用位就被硬件置位</strong></p>
<ul>
<li>
<p>最初所有<strong>reference bit</strong>由OS清0</p>
</li>
<li>
<p>当页面被引用时，<strong>reference bit</strong>置1</p>
</li>
<li>
<p>置换<strong>reference bit</strong>是0的页面</p>
</li>
</ul>
<h5 id="9451-额外引用位算法additional-reference-bits"><a class="markdownIt-Anchor" href="#9451-额外引用位算法additional-reference-bits"></a> 9.4.5.1 额外引用位算法(Additional-Reference-Bits)</h5>
<ul>
<li>为内存中的页表的每个页面保留一个8位的字节</li>
<li>定时器中断定期地将控制传到OS</li>
<li>OS将每个页面引用位移到其8位字节的高位，将其他位右移1位</li>
<li><strong>具有最小编号的页面是LRU页面</strong>，可以被替换</li>
</ul>
<h5 id="9452-第二次机会算法second-chance-algorithm"><a class="markdownIt-Anchor" href="#9452-第二次机会算法second-chance-algorithm"></a> 9.4.5.2 第二次机会算法(Second-Chance Algorithm)</h5>
<ul>
<li>按FIFO算法选择一个页面</li>
<li>如果<strong>reference bit</strong>为0， 置换</li>
<li>如果<strong>reference bit</strong>为1
<ul>
<li>设置<strong>reference bit</strong>为0</li>
<li>保留页面</li>
<li>按相同规则替换下一页面（按时钟顺序）</li>
</ul>
</li>
</ul>
<img src="https://i.loli.net/2020/11/22/gRG7Qbvmx3IAjHB.png" alt="image-20201122180447872.png" style="zoom:80%;" />
<h5 id="9453-增强型第二次机会算法"><a class="markdownIt-Anchor" href="#9453-增强型第二次机会算法"></a> 9.4.5.3 增强型第二次机会算法</h5>
<p><strong>reference bit</strong> + <strong>modify bit</strong></p>
<ul>
<li>
<p>四种类型</p>
<ul>
<li>(0, 0)—最近没有使用且没有修改的页面，<strong>最佳的页面置换</strong></li>
<li>(0, 1)—最近没有使用但修改过的页面，需要置换前将页面写出到磁盘</li>
<li>(1, 0)—最近使用过但没有修改的页面，可能很快再次使用</li>
<li>(1, 1)—最近使用过且修改过，需要置换前将页面写出到</li>
</ul>
</li>
<li>
<p><strong>如果扫描到(0, 1)，则换为(0, 0)</strong></p>
</li>
</ul>
<img src="https://i.loli.net/2020/11/22/RZliLOWQUuxJCh3.png" alt="image-20201122185018106.png" style="zoom:80%;" />
<img src="https://i.loli.net/2020/11/22/pk6hQ48Fm27wyzd.png" alt="image-20201122181130772.png" style="zoom:80%;" />
<h3 id="946-基于计数的页面置换counting-algorithms"><a class="markdownIt-Anchor" href="#946-基于计数的页面置换counting-algorithms"></a> 9.4.6 基于计数的页面置换(Counting Algorithms)</h3>
<p>为每个页面的引用次数保存一个计数器</p>
<h5 id="9461-最不经常使用least-frequently-used-lfu"><a class="markdownIt-Anchor" href="#9461-最不经常使用least-frequently-used-lfu"></a> 9.4.6.1 最不经常使用(Least-Frequently Used, LFU)</h5>
<ul>
<li>置换具有最小计数的页面</li>
</ul>
<p>问题：一个页面最初大量使用但随后不用时，会出现问题</p>
<p>解决方案：定期地将计数右移1位，以衰减平均使用计数</p>
<img src="https://i.loli.net/2020/11/22/2Q4TtpqJk6U1fjM.png" alt="image-20201122185744389.png" style="zoom:80%;" />
<h5 id="9462-最经常使用most-frequently-used-mfu"><a class="markdownIt-Anchor" href="#9462-最经常使用most-frequently-used-mfu"></a> 9.4.6.2 最经常使用(Most-Frequently Used, MFU)</h5>
<p>具有最小计数的页面可能刚刚被引入并且尚未使用</p>
<ul>
<li>置换具有最大计数的页面</li>
</ul>
<h3 id="95-帧分配"><a class="markdownIt-Anchor" href="#95-帧分配"></a> 9.5 帧分配</h3>
<h4 id="951-帧的最小数"><a class="markdownIt-Anchor" href="#951-帧的最小数"></a> 9.5.1 帧的最小数</h4>
<p>每个进程需要最小数量的帧</p>
<h4 id="952-分配算法"><a class="markdownIt-Anchor" href="#952-分配算法"></a> 9.5.2 分配算法</h4>
<h5 id="fixed-allocation"><a class="markdownIt-Anchor" href="#fixed-allocation"></a> Fixed Allocation</h5>
<p><strong>平均分配(Equal Allocation)</strong></p>
<p>n个进程m个帧</p>
<p>每个进程获得 m / n 帧</p>
<p><strong>比例分配(Proportional Allocation)</strong></p>
<p>根据进程大小进行分配可用内存</p>
<p>a<sub>i</sub> =	s<sub>i</sub> / S	×	m</p>
<h5 id="priority-allocation"><a class="markdownIt-Anchor" href="#priority-allocation"></a> Priority Allocation</h5>
<p>根据进程的优先级分配内存</p>
<h4 id="953-全局分配与局部分配"><a class="markdownIt-Anchor" href="#953-全局分配与局部分配"></a> 9.5.3 全局分配与局部分配</h4>
<h5 id="全局置换global-replacement"><a class="markdownIt-Anchor" href="#全局置换global-replacement"></a> 全局置换(Global Replacement)</h5>
<p>进程从所有帧的集合中选择一个置换帧，<strong>而不管该帧是否已分配给其他进程</strong></p>
<p>问题：进程无法控制其自身的页面错误率</p>
<h5 id="局部置换local-replacement"><a class="markdownIt-Anchor" href="#局部置换local-replacement"></a> 局部置换(Local Replacement)</h5>
<p>每个进程只从它自己分配的帧中进行选择</p>
<p>问题：不能使用其他进程的较少使用的内存页面</p>
<h3 id="96-系统抖动thrashing"><a class="markdownIt-Anchor" href="#96-系统抖动thrashing"></a> 9.6 系统抖动(Thrashing)</h3>
<h4 id="961-系统抖动的原因"><a class="markdownIt-Anchor" href="#961-系统抖动的原因"></a> 9.6.1 系统抖动的原因</h4>
<p>​		如果一个进程没有需要支持活动使用页面的帧数，那么它会很快产生缺页错误。此时，必须置换某个页面。然后循环产生缺页错误。</p>
<p>​		这种高度的页面调度活动称为抖动。如果<strong>一个进程的调页时间多于它的执行时间</strong>，那么这个进程就在抖动。</p>
<ul>
<li>缺页错误进程使用调页设备将页面换进换出，为调页设备排队，就绪队列清空，CPU利用率低</li>
<li>OS增加多道程序度</li>
<li>新进程试图获取帧来启动，导致更多的缺页错误和更长的调页设备队列</li>
</ul>
<p>​</p>
<p>​	不合理的多道程序度造成系统抖动</p>
<img src="https://i.loli.net/2020/11/22/261DXNW5fUZM7ow.png" alt="image-20201122193339588.png" style="zoom:80%;" />
<h5 id="局部性模型locality-model"><a class="markdownIt-Anchor" href="#局部性模型locality-model"></a> 局部性模型(Locality model)</h5>
<p>随着进程执行，它从一个局部移向另一个局部。局部性是最近使用页面的一个集合。局部可能会重叠</p>
<h4 id="962-工作集模型working-set-model"><a class="markdownIt-Anchor" href="#962-工作集模型working-set-model"></a> 9.6.2 工作集模型(Working-Set Model)</h4>
<p>工作集模型基于局部性假设</p>
<p><strong>Δ ≡ 工作集窗口(Working-set Window)</strong>，检查最近Δ个页面引用，这<strong>最近Δ个页面引用的页面集合称为工作集(Working-set)</strong>，如果页面不再使用，它在最后一次引用的Δ时间单位后，会从工作集中删除。</p>
<img src="https://i.loli.net/2020/11/22/bwOcqWldX9GKZe7.png" alt="image-20201122201545219.png" style="zoom:80%;" />
<h5 id="working-set-sizewss"><a class="markdownIt-Anchor" href="#working-set-sizewss"></a> Working set size(WSS)</h5>
<p><strong>WSS<sub>i</sub></strong>(working set of Process P<sub>i</sub>) = <strong>最近Δ个页面引用的数量</strong></p>
<p><strong>D</strong> 	=	<strong>Σ WSS<sub>i</sub></strong>	≡ 	<strong>总需求</strong></p>
<p>如果总需求大于可用帧的总数**(D &gt; m) ⇒ 发生抖动**</p>
<h5 id="策略"><a class="markdownIt-Anchor" href="#策略"></a> 策略</h5>
<p>如果工作集大小的总和超过可用帧的总数，OS会<strong>选择一个进程挂起</strong>，该进程的页面被写出，并且其帧可分配给其他进程</p>
<h5 id="跟踪工作集"><a class="markdownIt-Anchor" href="#跟踪工作集"></a> 跟踪工作集</h5>
<p><strong>定期时钟中断(fixed interval timer)</strong> + <strong>引用位(reference bit)</strong></p>
<p>例：Δ = 10,000</p>
<ul>
<li>
<p>每5000个引用引起定时器中断</p>
</li>
<li>
<p>每页有两个内存的位</p>
</li>
<li>
<p>当发生定时器中断时，复制并清除所有页面的引用位</p>
</li>
<li>
<p>如果内存中两位有一位是1，那么页面在工作集中</p>
</li>
</ul>
<p>通过增加历史位的数量和中断的频率可以降低不确定性，10位和每1000个引用引起定时器中断</p>
<h4 id="963-缺页错误频率page-fault-frequency-pff"><a class="markdownIt-Anchor" href="#963-缺页错误频率page-fault-frequency-pff"></a> 9.6.3 缺页错误频率(Page-Fault Frequency, PFF)</h4>
<p>设置可接受的缺页错误率</p>
<img src="https://i.loli.net/2020/11/22/EcLrQIpHWiv2tJm.png" alt="image-20201122205056446.png" style="zoom:80%;" />
<h3 id="98-分配内核内存"><a class="markdownIt-Anchor" href="#98-分配内核内存"></a> 9.8 分配内核内存</h3>
<p>通常从空闲内存池中分配内核内存</p>
<ul>
<li>内核需要为不同大小的数据结构请求内存</li>
<li>有些内核内存需要常驻在连续物理内存中</li>
</ul>
<h4 id="981-伙伴系统buddy-system"><a class="markdownIt-Anchor" href="#981-伙伴系统buddy-system"></a> 9.8.1 伙伴系统(Buddy System)</h4>
<p>从物理连续的大小固定的段商进行分配</p>
<p>内存分配采用2的幂分配器</p>
<img src="https://i.loli.net/2020/11/22/LR4h859ojrg1ZxF.png" alt="image-20201122231351936.png" style="zoom:80%;" />
<h4 id="982-slab分配器slab-allocator"><a class="markdownIt-Anchor" href="#982-slab分配器slab-allocator"></a> 9.8.2 slab分配器(Slab Allocator)</h4>
<ul>
<li>
<p>每个slab由一个或多个物理连续的页面组成</p>
</li>
<li>
<p>每个cache由一个或多个slab组成</p>
</li>
<li>
<p>每个内核数据结构都有一个cache</p>
</li>
<li>
<p>每个cache含有内核数据结构的对象实例</p>
</li>
</ul>
<ol>
<li>
<p>在创建cache时，将若干标记为free的对象分配到cache</p>
</li>
<li>
<p>从cache上分配的对象标记为used</p>
</li>
<li>
<p>slab分配器首先在部分为空的slab中用空闲对象来满足请求，如果不存在，则从空的slab中分配空闲对象</p>
<p>slab三状态：</p>
<ul>
<li>full: slab的所有对象标记为可用</li>
<li>empty: slab上的所有对象标记为空闲</li>
<li>partial: slab上的对象有的标记为使用，有的标记为空闲</li>
</ul>
</li>
<li>
<p>如果没有空的slab，则从连续物理页面分配新的slab</p>
</li>
</ol>
<img src="https://i.loli.net/2020/11/22/mqZVHBSFfJL7i6Q.png" alt="image-20201122232820522.png" style="zoom:80%;" />
<p>优点：没有碎片，可以快速满足内存请求</p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
  </entry>
  <entry>
    <title>第2章 Unity脚本开发</title>
    <url>/2021/04/09/Unity/%E7%AC%AC2%E7%AB%A0%20Unity%E8%84%9A%E6%9C%AC%E5%BC%80%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="unity脚本开发"><a class="markdownIt-Anchor" href="#unity脚本开发"></a> Unity脚本开发</h2>
<h3 id="21-脚本的创建与运行"><a class="markdownIt-Anchor" href="#21-脚本的创建与运行"></a> 2.1 脚本的创建与运行</h3>
<a id="more"></a>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">	public int age;</span><br><span class="line">	public string name;</span><br><span class="line">&#x2F;&#x2F; Start is called before the first frame update</span><br><span class="line">    void Start()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Start&quot;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; Update is called once per frame</span><br><span class="line">    void Update()</span><br><span class="line">    &#123;</span><br><span class="line">        Debug.Log(&quot;Update&quot;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h4 id="211-脚本注意事项"><a class="markdownIt-Anchor" href="#211-脚本注意事项"></a> 2.1.1 脚本注意事项</h4>
<ul>
<li>脚本文件名称与类名必须相同</li>
<li>初始化信息不能写到脚本构造函数中，而应定义在Unity的事件函数Start中</li>
<li>游戏对象中的脚本可以在属性窗口修改属性，public字段直接可以当属性用</li>
<li>脚本只能依附于游戏对象或者其他脚本调用才会运行，一个脚本可以赋值给多个游戏对象</li>
<li>脚本运行过程中，脚本的参数修改不被保存</li>
</ul>
<h3 id="22-脚本的生命周期"><a class="markdownIt-Anchor" href="#22-脚本的生命周期"></a> 2.2 脚本的生命周期</h3>
<p>脚本的生命周期，就是所挂载到的游戏物体的生命周期</p>
<h4 id="221-常用生命周期事件"><a class="markdownIt-Anchor" href="#221-常用生命周期事件"></a> 2.2.1 常用生命周期事件</h4>
<p><img src="https://i.loli.net/2021/04/19/uSVtFyqsZgd3A9T.png" alt="1.png" /></p>
<h3 id="23-向量"><a class="markdownIt-Anchor" href="#23-向量"></a> 2.3 向量</h3>
<h4 id="231-二维向量vector2"><a class="markdownIt-Anchor" href="#231-二维向量vector2"></a> 2.3.1 二维向量(Vector2)</h4>
<p><strong>静态属性</strong></p>
<ul>
<li>down(0, -1)、up、left(1, 0)、right、one(1, 1)、zero</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>magnitude——长度</li>
<li>normalized——单位化</li>
</ul>
<p><strong>公共方法</strong></p>
<ul>
<li>Normalize——对向量进行单位化</li>
</ul>
<p><strong>静态方法</strong></p>
<ul>
<li>
<p>Distance——两个向量间的距离</p>
</li>
<li>
<p>Angle——两个向量间的角度</p>
</li>
</ul>
<h4 id="232-三维向量vector3"><a class="markdownIt-Anchor" href="#232-三维向量vector3"></a> 2.3.2 三维向量(Vector3)</h4>
<p><strong>静态属性</strong></p>
<ul>
<li>back、forward(0, 0, 1)</li>
</ul>
<p><strong>属性</strong></p>
<ul>
<li>magnitude</li>
<li>normalized</li>
</ul>
<p><strong>静态方法</strong></p>
<ul>
<li>
<p>Cross(叉乘)</p>
</li>
<li>
<p>Dot(点乘)</p>
</li>
<li>
<p>Lerp(线性插值运算)</p>
</li>
<li>
<p>MoveTowards(匀速运动)</p>
</li>
<li>
<p>Slerp(球形插值运算) 角度+长度</p>
</li>
</ul>
<h3 id="24-输入按键控制"><a class="markdownIt-Anchor" href="#24-输入按键控制"></a> 2.4 输入按键控制</h3>
<h4 id="241-获取按键方法"><a class="markdownIt-Anchor" href="#241-获取按键方法"></a> 2.4.1 获取按键方法</h4>
<ul>
<li>Input.GetKey(); 				// 持续检测</li>
<li>Input.GetKeyDown();       // 一次</li>
<li>Input.GetKeyUp();            // 一次</li>
</ul>
<p>返回 ：键码，保存了物理键盘按键“索引码”。</p>
<h4 id="242-获取鼠标事件"><a class="markdownIt-Anchor" href="#242-获取鼠标事件"></a> 2.4.2 获取鼠标事件</h4>
<ul>
<li>
<p>Input.GetMouseButton ();			// 持续监测</p>
</li>
<li>
<p>Input.GetMouseButtonDown ();  // 一次</p>
</li>
<li>
<p>Input.GetMouseButtonUp ();       // 一次</p>
<p>0	→	左键<br />
1	→	右键<br />
2	→	中 键</p>
</li>
</ul>
<h4 id="243-获取按钮输入"><a class="markdownIt-Anchor" href="#243-获取按钮输入"></a> 2.4.3 获取按钮输入</h4>
<p>自定义的虚拟按钮</p>
<p>Edit	→	Project Setting	→	Input Manager</p>
<ul>
<li>
<p>Input.GetButton (“Jump”);</p>
</li>
<li>
<p>Input.GetButtonDown (“Jump”);</p>
</li>
<li>
<p>Input.GetButtonUp (“Jump”);</p>
</li>
</ul>
<h4 id="244-获取虚拟轴的值"><a class="markdownIt-Anchor" href="#244-获取虚拟轴的值"></a> 2.4.4 获取虚拟轴的值</h4>
<p>Edit	→	Project Setting	→	Input Manager</p>
<ul>
<li>Input.GetAxis ();			// 返回-1到1之间的浮点数，有渐变效果</li>
<li>Input.GetAxisRaw ();     // 没有渐变效果，只能返回-1，0，1三个值</li>
</ul>
<h4 id="245-鼠标按键行为"><a class="markdownIt-Anchor" href="#245-鼠标按键行为"></a> 2.4.5 鼠标按键行为</h4>
<ul>
<li>
<p>OnMouseDrag()：当鼠标拖动</p>
</li>
<li>
<p>OnMouseDown()：当鼠标按下</p>
</li>
<li>
<p>OnMouseUp()：当鼠标抬起</p>
</li>
<li>
<p>OnMouseEnter()：当鼠标进入</p>
</li>
<li>
<p>OnMouseExit()：当鼠标退出</p>
</li>
<li>
<p>OnMouseOver()：当鼠标经过</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void OnMouseEnter() &#123;</span><br><span class="line">	gameObject.GetComponent&lt;MeshRenderer&gt;().material.color 				&#x3D; Color.red;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>获取鼠标行为和获取鼠标按键的区别</strong></p>
<ul>
<li>获取鼠标按键针对鼠标左中右键，而获取鼠标行为不针对</li>
<li>获取鼠标按键是一个方法，返回bool类型，而获取鼠标行为是一个时间函数，跟Start和Update同级别</li>
</ul>
<h3 id="25-时间控制"><a class="markdownIt-Anchor" href="#25-时间控制"></a> 2.5 时间控制</h3>
<p><img src="https://i.loli.net/2021/04/19/BupDtxYKqvAX9I5.png" alt="2.png" /></p>
<h4 id="251-应用示例"><a class="markdownIt-Anchor" href="#251-应用示例"></a> 2.5.1 应用示例</h4>
<p><strong>Time.deltaTime</strong></p>
<ul>
<li>
<p>计时器：实现每隔多少秒做什么事情</p>
</li>
<li>
<p>控制物体匀速移动或旋转</p>
<p>每秒移动多少米</p>
<p>每秒旋转多少度</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 每秒移动speed米</span><br><span class="line">transform.Translate(Vector3.right* Time.deltaTime * speed);</span><br></pre></td></tr></table></figure>
<p><strong>Time.timeScale</strong></p>
<ul>
<li>
<p>时间流逝的快慢</p>
<p>1：时间 正常<br />
2：表示时间流逝加快，是正常的 2 倍<br />
0：时间停止，游戏暂停</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if(Input.GetKeyDown(KeyCode.Q)) &#123;</span><br><span class="line">	Time.timeScale &#x3D; 10;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if(Input.GetKeyDown(KeyCode.P)) &#123;</span><br><span class="line">	Time.timeScale &#x3D; 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="26-游戏物体的实例化和销毁"><a class="markdownIt-Anchor" href="#26-游戏物体的实例化和销毁"></a> 2.6 游戏物体的实例化和销毁</h3>
<h4 id="261-预制体"><a class="markdownIt-Anchor" href="#261-预制体"></a> 2.6.1 预制体</h4>
<p><strong>|预制体|</strong>：Prefab，预先准备好的物体 可以被重复使用，是 Unity 中很 重要的资源 类型</p>
<p><strong>创建</strong></p>
<p>手动创建：从 Hierachy 面板用鼠标拖动游戏物体到 Asserts 资源文件<br />
夹中</p>
<p>脚本动态创建：<br />
Instantiate(Prefabs, transform.position transform.rotation )</p>
<p><strong>基本操作</strong></p>
<ul>
<li>
<p>Select 查找 Hierachy 面板 中预制体实例对象在 Asserts 资源中的位置</p>
</li>
<li>
<p>Revert ：丢弃对当前预制体实例对象所做的修改，重置到跟预制体原型一致的状态</p>
</li>
<li>
<p>Apply ：将对当前预制体实例对象所做的修改应用到其他预制体实例对象上</p>
</li>
</ul>
<p><strong>特点</strong></p>
<ul>
<li>
<p>所有的 Prefab 实例都是 Prefab 原型的 克隆，通过脚本实例化生<br />
成的对象会有 Clone 的标记</p>
</li>
<li>
<p>只要 Prefab 原型发生改变，所有的 Prefab 实例都会发生变化</p>
</li>
</ul>
<h4 id="262-创建游戏物体"><a class="markdownIt-Anchor" href="#262-创建游戏物体"></a> 2.6.2 创建游戏物体</h4>
<ul>
<li>
<p>GameObject go = new GameObject (“Go&quot;);</p>
</li>
<li>
<p>GameObject.CreatePrimitive(PrimitiveType.Cube);</p>
</li>
<li>
<p>通过 Instantiate 方法实例化创建游戏对象</p>
<ul>
<li>克隆预制体(prefab)</li>
<li>克隆普通的游戏对象</li>
</ul>
<p>Instantiate(Prefabs, transform.position , transform.rotation);</p>
</li>
</ul>
<h4 id="263-游戏物体的销毁"><a class="markdownIt-Anchor" href="#263-游戏物体的销毁"></a> 2.6.3 游戏物体的销毁</h4>
<ul>
<li>
<p>GameObject.Destroy(Object);</p>
</li>
<li>
<p>GameObject.Destroy(Object, float);    // 延迟销毁</p>
</li>
</ul>
<p>销毁游戏物体时将销毁该物体所有的组件和子物体。</p>
<h3 id="27-游戏物体的访问和控制"><a class="markdownIt-Anchor" href="#27-游戏物体的访问和控制"></a> 2.7 游戏物体的访问和控制</h3>
<h4 id="271-查找游戏物体的方法"><a class="markdownIt-Anchor" href="#271-查找游戏物体的方法"></a> 2.7.1 查找游戏物体的方法</h4>
<ol>
<li>GameObject.Find(“Cube”);     // 根据游戏物体的名称全局查找)</li>
<li>transform.Find(“G1/G11”);    // 在当前对象的子物体中查找，参数必须指明具体的查找路径</li>
<li>GameObject.Find(“Cube”).transform.GetChild(0));     // 通过父物体查找子物体</li>
<li>通过 tag 标签查找：</li>
</ol>
<ul>
<li>GameObject.FindWithTag(“Player”);     // 查找一个物体</li>
<li>GameObject.FindGameObjectWithTag(“Player&quot;);     // 查找一个物体</li>
<li>GameObject.FindGameObjectsWithTag(“Player&quot;);     // 查找一批物体</li>
</ul>
<p><strong>若游戏物体未激活时(禁用)，方法 1 和 4 将查找不到，方法 2 和 3 可以查找到</strong></p>
<h4 id="272-禁用和启用游戏物体"><a class="markdownIt-Anchor" href="#272-禁用和启用游戏物体"></a> 2.7.2 禁用和启用游戏物体</h4>
<ul>
<li>gameObject.SetActive(true/false);</li>
</ul>
<p><strong>访问游戏物体的激活状态</strong></p>
<ul>
<li>gameObject.activeSelf				// 取决于自身是否被禁用</li>
<li>gameObject.activeInHierarchy  // 物体自身及所有祖先物体是否被禁用</li>
</ul>
<h3 id="28-组件的访问和控制"><a class="markdownIt-Anchor" href="#28-组件的访问和控制"></a> 2.8 组件的访问和控制</h3>
<h4 id="281-获取组件"><a class="markdownIt-Anchor" href="#281-获取组件"></a> 2.8.1 获取组件</h4>
<ul>
<li>
<p>获取当前游戏对象上的组件</p>
<p>GetComponent&lt;BoxCollider&gt;();</p>
</li>
<li>
<p>获取其他游戏对象的组件(先定义public gameObject)</p>
<p>other.GetComponent&lt;Transform&gt;();</p>
</li>
<li>
<p>获取所有子物体的某种组件</p>
<p>GetComponentsInChildren&lt;Collider&gt;();</p>
</li>
<li>
<p>获取所有父物体的某种组件</p>
<p>GetComponentsInParent&lt;Collider &gt;();</p>
</li>
</ul>
<h4 id="282-组件的添加和删除"><a class="markdownIt-Anchor" href="#282-组件的添加和删除"></a> 2.8.2 组件的添加和删除</h4>
<ul>
<li>
<p>启用当前游戏物体上的某个组件</p>
<p>GetComponent&lt;BoxCollider &gt;().enabled = true</p>
</li>
<li>
<p>启用其他游戏物体上的某个组件(先定义public gameObject)</p>
<p>other.GetComponent&lt;BoxCollider &gt;().enabled = true</p>
</li>
</ul>
<h3 id="29-游戏物体的移动和旋转"><a class="markdownIt-Anchor" href="#29-游戏物体的移动和旋转"></a> 2.9 游戏物体的移动和旋转</h3>
<h4 id="291-物体移动方法"><a class="markdownIt-Anchor" href="#291-物体移动方法"></a> 2.9.1 物体移动方法</h4>
<ul>
<li>
<p>transform.Translate();</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform.Translate(Vector3.right * Time.deltaTime * 2, Space.World);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Vector3.Lerp(), 先快后慢;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform.position &#x3D; Vector3.Lerp(transform.position, target, Time.deltaTime);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>Vector3.MoveToward(), 匀速;</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">transform.position &#x3D; Vector3.MoveTowards(transform.position, target, Time.deltaTime);</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p><strong>控制物体移动</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">float h &#x3D; Input.GetAxis(&quot;Horizontal&quot;);</span><br><span class="line">float v &#x3D; Input.GetAxis(&quot;Vertical&quot;);</span><br><span class="line">transform.Translate(Vector3.right * h * Time.deltaTime);</span><br><span class="line">transform.Translate(Vector3.forward * v * Time.deltaTime);</span><br></pre></td></tr></table></figure>
<h4 id="292-物体旋转方法"><a class="markdownIt-Anchor" href="#292-物体旋转方法"></a> 2.9.2 物体旋转方法</h4>
<ul>
<li>
<p>第一种方法：使用transform.Rotate方法</p>
<p>transform.Rotate(), 参数是欧拉角</p>
</li>
<li>
<p>第二种方法：使用四元数的乘法，实现当按下R键的时候让物体在当前角度的基础上沿Y轴旋转5度</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Quaternion q1 &#x3D;  transform.rotation;</span><br><span class="line">Quaternion q2 &#x3D; Quaternion.Euler(0, 5 ,0);</span><br><span class="line">if(Input.GetKeyDown(KeyCode.R)) &#123;</span><br><span class="line">    transform.rotation &#x3D;  q1 * q2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="210-invoke方法"><a class="markdownIt-Anchor" href="#210-invoke方法"></a> 2.10 Invoke方法</h3>
<ul>
<li>
<p>调用函数，多少秒后执行某个函数</p>
<p>Invoke(string, float);</p>
</li>
<li>
<p>重复调用函数，多少秒后执行某个函数，并且每隔多少秒都会执行一次</p>
<p>InvokeRepeating(string, float, float);</p>
</li>
<li>
<p>取消脚本中所有的Invoke调用</p>
<p>CancelInvoke();</p>
</li>
<li>
<p>取消某个函数的Invoke调用</p>
<p>CancelInvoke(“函数名”);</p>
</li>
<li>
<p>判断某个函数是否在等候调用</p>
<p>IsInvoking(string);</p>
</li>
</ul>
<h3 id="211-协程"><a class="markdownIt-Anchor" href="#211-协程"></a> 2.11 协程</h3>
<p><strong>|协程|</strong>：协同程序，即主程序在运行的同时开启另外一段处理逻辑。调用协程方法可以不用等这个方法执行完就继续向下执行。</p>
<h4 id="2111-协程的定义"><a class="markdownIt-Anchor" href="#2111-协程的定义"></a> 2.11.1 协程的定义</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IEnumerator Task() &#123;</span><br><span class="line">	yield return new WaitForSeconds(2f); &#x2F;&#x2F; 等待2s后继续执行下面语句</span><br><span class="line">    Debug.Log(&quot;Test&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>返回值为IEnumerator，使用yield语句可以暂停协程的执行，yield return的返回值决定了什么时候恢复协程的执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">yield return null;&#x2F;&#x2F; 暂停，下一帧继续</span><br><span class="line">yield return new WaitForSeconds(2f);&#x2F;&#x2F; 暂停2s	</span><br><span class="line">yield return StartCoroutine(&quot;Other&quot;);&#x2F;&#x2F; 暂停当前协程，开启协程Ohter</span><br><span class="line">yield new WaitForFixedUpdate();&#x2F;&#x2F; 暂停，下一次FixedUpdate继续</span><br></pre></td></tr></table></figure>
<h4 id="2112-协程的开启和关闭"><a class="markdownIt-Anchor" href="#2112-协程的开启和关闭"></a> 2.11.2 协程的开启和关闭</h4>
<p><strong>两种开启与关闭的方法</strong></p>
<ul>
<li>
<p>参数为协程方法名</p>
<p>StartCoroutine (string methodName);</p>
<p>StopCoroutine (string methodName);</p>
</li>
<li>
<p>参数为IEnumerator类型</p>
<p>StartCoroutine(IEnumerator routine);</p>
<p>StopCoroutine(IEnumerator routine);</p>
</li>
<li>
<p>停止当前脚本所有协程</p>
<p>StopAllCoroutines();</p>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void Start() &#123;</span><br><span class="line">    StartCoroutine (&quot;TestCoroutine&quot;);</span><br><span class="line">    StartCoroutine (TestCoroutine());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>**PS：**开启协程和停止协程的方式必须保持一致</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>第1章 Unity介绍</title>
    <url>/2021/04/06/Unity/%E7%AC%AC1%E7%AB%A0%20Unity%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="unity介绍"><a class="markdownIt-Anchor" href="#unity介绍"></a> Unity介绍</h2>
<h3 id="14-游戏对象与组件"><a class="markdownIt-Anchor" href="#14-游戏对象与组件"></a> 1.4 游戏对象与组件</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/04/19/QsCd1yGr4biHc7h.png" alt="1.png" /></p>
<h4 id="组件和游戏对象的关系"><a class="markdownIt-Anchor" href="#组件和游戏对象的关系"></a> 组件和游戏对象的关系</h4>
<p><img src="https://i.loli.net/2021/04/19/TdaPmCtDsir7Gwx.png" alt="2.png" /></p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>第3章 Unity物理引擎</title>
    <url>/2021/04/19/Unity/%E7%AC%AC3%E7%AB%A0%20Unity%E7%89%A9%E7%90%86%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="unity物理引擎"><a class="markdownIt-Anchor" href="#unity物理引擎"></a> Unity物理引擎</h2>
<h3 id="31-刚体"><a class="markdownIt-Anchor" href="#31-刚体"></a> 3.1 刚体</h3>
<a id="more"></a>
<p><strong>|刚体|</strong>：添加了刚体组件的游戏物体，就有了重力，会做自由落体运动可以像现实中的物体一样运动。</p>
<h4 id="311-刚体组件属性"><a class="markdownIt-Anchor" href="#311-刚体组件属性"></a> 3.1.1 刚体组件属性</h4>
<ul>
<li>Mass: 设置物理的质量，单位是KG。</li>
<li>Drag: 空气阻力，0表示无阻力，值很大时物体会停止运动。</li>
<li>Angular Drag: 受到扭曲力时的空气阻力。</li>
<li>Use Gravity： 是否使用重力。</li>
</ul>
<h4 id="312-刚体移动方法"><a class="markdownIt-Anchor" href="#312-刚体移动方法"></a> 3.1.2 刚体移动方法</h4>
<ul>
<li>
<p>Rigidbody.MovePosition(Vector3);</p>
<p><strong>参数Vector3表示要移动到的新位置</strong>，使用“当前位置“ + 移动增量的方式。</p>
</li>
</ul>
<h4 id="313-特点"><a class="markdownIt-Anchor" href="#313-特点"></a> 3.1.3 特点</h4>
<ul>
<li>会与场景中的物体发生碰撞</li>
<li>会受重力影响，在到达场景边缘外时，会自由下落。</li>
</ul>
<h3 id="32-碰撞体"><a class="markdownIt-Anchor" href="#32-碰撞体"></a> 3.2 碰撞体</h3>
<p><strong>|碰撞体|</strong>：使用刚体移动的物体，与场景中的其他物体相碰撞，其实碰撞的是目标物体的“碰撞体”组件，也就是 Collider。</p>
<h4 id="321-应用场景"><a class="markdownIt-Anchor" href="#321-应用场景"></a> 3.2.1 应用场景</h4>
<p><img src="https://i.loli.net/2021/04/19/4UhF25tgOfQiXkm.png" alt="1.png" /></p>
<h3 id="33-碰撞事件检测与处理"><a class="markdownIt-Anchor" href="#33-碰撞事件检测与处理"></a> 3.3 碰撞事件检测与处理</h3>
<h4 id="331-碰撞事件检测方法"><a class="markdownIt-Anchor" href="#331-碰撞事件检测方法"></a> 3.3.1 碰撞事件检测方法</h4>
<p><strong>与start、update方法同级！！！</strong></p>
<ul>
<li>OnCollisionEnter(Collision);</li>
<li>OnCollisionExit(Collision);</li>
<li>OnCollisionStay(Collision);</li>
</ul>
<p>Collision参数：碰撞类，用于传递碰撞信息。</p>
<h4 id="332-碰撞检测条件"><a class="markdownIt-Anchor" href="#332-碰撞检测条件"></a> 3.3.2 碰撞检测条件</h4>
<ul>
<li>两个物体接触并发生碰撞</li>
<li>运动的物体必须带有碰撞体Collider和刚体Rigidbody</li>
<li>另一个物体(可以静止也可以运动)必须至少带有碰撞体Collider</li>
</ul>
<h3 id="34-触发事件检测与处理"><a class="markdownIt-Anchor" href="#34-触发事件检测与处理"></a> 3.4 触发事件检测与处理</h3>
<p><strong>|触发器|</strong>： 将碰撞体组件属性面板上的“ Is Trigger” 选项选中，当前的游戏物体的碰撞体就变成了触发器。不与目标物体发生直接的碰撞（接触），而是只要进入目标物体的“触发范围”就能执行某些特定操作。</p>
<h4 id="341-触发事件检测方法"><a class="markdownIt-Anchor" href="#341-触发事件检测方法"></a> 3.4.1 触发事件检测方法</h4>
<p><strong>与start、update方法同级</strong></p>
<ul>
<li>OnTriggerEnter( Collider);</li>
<li>OnTriggerExit( Collider);</li>
<li>OnTriggerStay( Collider);</li>
</ul>
<p>Collider参数：碰撞体类，用于传递触发信息。</p>
<h4 id="342-触发检测条件"><a class="markdownIt-Anchor" href="#342-触发检测条件"></a> 3.4.2 触发检测条件</h4>
<ul>
<li>运动的物体必须带有碰撞体Collider和刚体Rigidbody</li>
<li>另一个物体(可以静止也可以运动)必须至少带有碰撞体Collider</li>
<li>其中一个物体上勾选了 Is Trigger 选项</li>
</ul>
<h3 id="35-物理射线检测"><a class="markdownIt-Anchor" href="#35-物理射线检测"></a> 3.5 物理射线检测</h3>
<h4 id="351-物理射线检测方法"><a class="markdownIt-Anchor" href="#351-物理射线检测方法"></a> 3.5.1 物理射线检测方法</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private Ray ray;</span><br><span class="line">ray &#x3D; Camera.main.ScreenPointToRay(Input.mousePosition);</span><br></pre></td></tr></table></figure>
<ul>
<li>Camera.main ：代表 tag 设置为&quot;MainCamera&quot;的摄像机的 Camera组件的引用。</li>
<li>ScreenPointToRay (Vector3 )：摄像机组件对象下的一个方法，将屏幕点转化为射线 ，返回一个Ray 类型的射线。</li>
<li>Input.mousePosition：鼠标所在的位置，Vector3类型。</li>
</ul>
<h4 id="352-检测射线与其他物体的碰撞"><a class="markdownIt-Anchor" href="#352-检测射线与其他物体的碰撞"></a> 3.5.2 检测射线与其他物体的碰撞</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private RaycastHit hit;</span><br><span class="line">if(Physics.Raycast(ray, out hit)) &#123;</span><br><span class="line">    &#x2F;&#x2F; 将碰撞到的物体销毁</span><br><span class="line">    GameObject.Destroy(hit.collider.gameObject);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>RaycastHit ：一个结构体，用于存储射线的碰撞信息。</p>
</li>
<li>
<p>Physics.Raycast (Ray, out RaycastHit)：射线检测，第一个参数为要检测的射线，如果射线与其他物体相撞了，相撞的信息存储在第二参数里。</p>
</li>
</ul>
<h4 id="353-物理射线使用步骤"><a class="markdownIt-Anchor" href="#353-物理射线使用步骤"></a> 3.5.3 物理射线使用步骤</h4>
<p>第一步：创建一根射线。</p>
<p>第二步：检查这根射线与其他物体的碰撞，得到碰撞信息。</p>
<p>第三步：通过碰撞信息对碰撞到的物体进行处理。</p>
]]></content>
      <categories>
        <category>Unity</category>
      </categories>
  </entry>
  <entry>
    <title>1 CSS 基础、文本、显示模式、背景</title>
    <url>/2021/07/16/%E5%89%8D%E7%AB%AF/1%20CSS%20%E5%9F%BA%E7%A1%80%E3%80%81%E6%96%87%E6%9C%AC%E3%80%81%E6%98%BE%E7%A4%BA%E6%A8%A1%E5%BC%8F%E3%80%81%E8%83%8C%E6%99%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="css-基础-文本-显示模式-背景"><a class="markdownIt-Anchor" href="#css-基础-文本-显示模式-背景"></a> CSS 基础、文本、显示模式、背景</h2>
<h3 id="1-语法规范"><a class="markdownIt-Anchor" href="#1-语法规范"></a> 1. 语法规范</h3>
<a id="more"></a>
<p>选择器+声明</p>
<h3 id="2-基础选择器"><a class="markdownIt-Anchor" href="#2-基础选择器"></a> 2. 基础选择器</h3>
<h4 id="标签选择器"><a class="markdownIt-Anchor" href="#标签选择器"></a> 标签选择器</h4>
<p>html标签</p>
<h4 id="类选择器"><a class="markdownIt-Anchor" href="#类选择器"></a> 类选择器</h4>
<ul>
<li>
<p>class属性中可以写多个类名，用空格隔开</p>
</li>
<li>
<p>标签可以调用公共的类，再调用自己独有的类</p>
</li>
</ul>
<h4 id="id选择器"><a class="markdownIt-Anchor" href="#id选择器"></a> id选择器</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-id">#id</span> &#123;</span></span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="通配符选择器"><a class="markdownIt-Anchor" href="#通配符选择器"></a> 通配符选择器</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="3-字体属性"><a class="markdownIt-Anchor" href="#3-字体属性"></a> 3. 字体属性</h3>
<h4 id="31-字体系列"><a class="markdownIt-Anchor" href="#31-字体系列"></a> 3.1 字体系列</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">font-family: 'Microsoft Yahei';</span><br></pre></td></tr></table></figure>
<ul>
<li>各字体之间用逗号隔开</li>
<li>可以有多个字体，系统按顺序选择</li>
</ul>
<h4 id="32-字体大小"><a class="markdownIt-Anchor" href="#32-字体大小"></a> 3.2 字体大小</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">font-size: 20px;</span><br></pre></td></tr></table></figure>
<h4 id="33-字体粗细"><a class="markdownIt-Anchor" href="#33-字体粗细"></a> 3.3 字体粗细</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">font-weight</span>: 400;</span><br></pre></td></tr></table></figure>
<h4 id="34-文字样式"><a class="markdownIt-Anchor" href="#34-文字样式"></a> 3.4 文字样式</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">font-style: normal/italic;</span><br></pre></td></tr></table></figure>
<h4 id="35-字体复合属性"><a class="markdownIt-Anchor" href="#35-字体复合属性"></a> 3.5 字体复合属性</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">font: font-style font-weight font-size/line-height font-family;</span><br></pre></td></tr></table></figure>
<ul>
<li>必须保留font-size和font-family</li>
</ul>
<h3 id="4-文本属性"><a class="markdownIt-Anchor" href="#4-文本属性"></a> 4. 文本属性</h3>
<h4 id="41-文本颜色color"><a class="markdownIt-Anchor" href="#41-文本颜色color"></a> 4.1 文本颜色color</h4>
<ul>
<li>预定义的值</li>
<li>十六进制</li>
<li>RGB代码</li>
</ul>
<h4 id="42-文本对齐text-align"><a class="markdownIt-Anchor" href="#42-文本对齐text-align"></a> 4.2 文本对齐text-align</h4>
<p>让盒子内的元素水平对齐</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">text-align: left/center/right;</span><br></pre></td></tr></table></figure>
<h4 id="43-文本装饰text-decoration"><a class="markdownIt-Anchor" href="#43-文本装饰text-decoration"></a> 4.3 文本装饰text-decoration</h4>
<p>none/underline/overline/line-through</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">text-decoration</span>: <span class="selector-tag">underline</span>;</span><br></pre></td></tr></table></figure>
<h4 id="44-文本缩进text-indent"><a class="markdownIt-Anchor" href="#44-文本缩进text-indent"></a> 4.4 文本缩进text-indent</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">text-indent: 10px/2em;</span><br></pre></td></tr></table></figure>
<h4 id="45-line-height"><a class="markdownIt-Anchor" href="#45-line-height"></a> 4.5 line-height</h4>
<p>行间距 = 上间距 + 文本高度 + 下间距</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">line-height</span>: 26<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h3 id="5-css引入方式"><a class="markdownIt-Anchor" href="#5-css引入方式"></a> 5. CSS引入方式</h3>
<h4 id="51-行内样式表"><a class="markdownIt-Anchor" href="#51-行内样式表"></a> 5.1 行内样式表</h4>
<p>写在行内</p>
<h4 id="52-内部样式表"><a class="markdownIt-Anchor" href="#52-内部样式表"></a> 5.2 内部样式表</h4>
<p>style理论上可以放在HTML的任何地方，但一般会放在head标签中</p>
<h4 id="53-外部样式表"><a class="markdownIt-Anchor" href="#53-外部样式表"></a> 5.3 外部样式表</h4>
<p>样式单独写到CSS文件中，把CSS文件引入到HTML页面中使用</p>
<p>通过&lt;link&gt;标签引入文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"css文件路径"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="6-emmet语法"><a class="markdownIt-Anchor" href="#6-emmet语法"></a> 6. Emmet语法</h3>
<h4 id="61-快速生成html标签"><a class="markdownIt-Anchor" href="#61-快速生成html标签"></a> 6.1 快速生成html标签</h4>
<ul>
<li>
<p>div + tab</p>
</li>
<li>
<p>生成多个相同标签：div * 3</p>
</li>
<li>
<p>父子关系： ul &gt; li * 3</p>
</li>
<li>
<p>兄弟关系：div + p</p>
</li>
<li>
<p>带有类名或id： div.demo、p#two</p>
</li>
<li>
<p>生成带有顺序的类名：div.demo$*5</p>
</li>
<li>
<p>在生成的标签内部写内容可以用{}表示</p>
</li>
</ul>
<h4 id="62-快速生成css样式"><a class="markdownIt-Anchor" href="#62-快速生成css样式"></a> 6.2 快速生成css样式</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">tac = text-align: center;</span><br><span class="line">ti2em = text-indent: 2em;</span><br><span class="line">w100 = width: 100px;</span><br></pre></td></tr></table></figure>
<h3 id="7-css复合选择器"><a class="markdownIt-Anchor" href="#7-css复合选择器"></a> 7. CSS复合选择器</h3>
<p>复合选择器是基础选择器的组合，常用的复合选择器包括：后代选择器、子选择器、并集选择器、伪类选择器等</p>
<h4 id="71-后代选择器"><a class="markdownIt-Anchor" href="#71-后代选择器"></a> 7.1 后代选择器</h4>
<p>选择父元素里面子元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ol</span> <span class="selector-tag">li</span> &#123; &#125;</span><br></pre></td></tr></table></figure>
<h4 id="72-子选择器"><a class="markdownIt-Anchor" href="#72-子选择器"></a> 7.2 子选择器</h4>
<p>只能选择最近的一级子元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ol</span>&gt;<span class="selector-tag">li</span></span><br></pre></td></tr></table></figure>
<h4 id="73-并集选择器"><a class="markdownIt-Anchor" href="#73-并集选择器"></a> 7.3 并集选择器</h4>
<p>选择多组标签，同时为它们定义相同的样式，任何形式的选择器都可以作为并集选择器的一部分</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>,</span><br><span class="line"><span class="selector-tag">body</span> &#123;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="74-伪类选择器"><a class="markdownIt-Anchor" href="#74-伪类选择器"></a> 7.4 伪类选择器</h4>
<p>伪类选择器用于向某些选择器添加特殊的效果，比如给链接添加特殊效果，或选择第一个，第n个元素。</p>
<p>伪类选择器用 <strong>:</strong> 表示</p>
<h5 id="741-链接伪类选择器"><a class="markdownIt-Anchor" href="#741-链接伪类选择器"></a> 7.4.1 链接伪类选择器</h5>
<ul>
<li>a:link		  没有点击过的(访问过的)链接</li>
<li>a:visited	 点击过的(访问过的)链接</li>
<li>a:hover	  鼠标经过的那个链接</li>
<li>a:active	  鼠标正在按下还没有弹起鼠标的那个链接</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:link</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: <span class="number">#333</span>;</span><br><span class="line">    <span class="attribute">text-decoration</span>: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:visited</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: orange;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: skyblue;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">a</span><span class="selector-pseudo">:active</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: green;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>需要按照l、v、h、a的顺序来写</p>
</li>
<li>
<p>a链接在浏览器中具有默认样式，所以需要单独指定样式</p>
</li>
</ul>
<h5 id="742-focus伪类选择器"><a class="markdownIt-Anchor" href="#742-focus伪类选择器"></a> 7.4.2 focus伪类选择器</h5>
<p>用于选取获得焦点的表单元素</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">:focus</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: yellow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="75-总结"><a class="markdownIt-Anchor" href="#75-总结"></a> 7.5 总结</h4>
<p><img src="https://i.loli.net/2021/07/21/buyrw5WPsUQ1TMj.png" alt="1570868930472.png" /></p>
<h4 id="8-元素显示模式"><a class="markdownIt-Anchor" href="#8-元素显示模式"></a> 8. 元素显示模式</h4>
<h4 id="81-块元素"><a class="markdownIt-Anchor" href="#81-块元素"></a> 8.1  块元素</h4>
<p>div、p……</p>
<ul>
<li>可以设置w、h、margin</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>文字类的元素不能使用块级元素（p中不能放div）</li>
</ul>
<h4 id="82-行内元素"><a class="markdownIt-Anchor" href="#82-行内元素"></a> 8.2 行内元素</h4>
<p>a、span……</p>
<ul>
<li>w、h设置无效</li>
<li>默认宽度就是本身内容宽度</li>
<li>行内元素只能容纳文本或其他行内元素</li>
</ul>
<p><strong>注意</strong></p>
<ul>
<li>链接里面不能再放链接</li>
</ul>
<h4 id="83-行内块元素"><a class="markdownIt-Anchor" href="#83-行内块元素"></a> 8.3 行内块元素</h4>
<p>一行可以放多个，且可以设置w、h（input）</p>
<h4 id="84-元素显示模式转换"><a class="markdownIt-Anchor" href="#84-元素显示模式转换"></a> 8.4 元素显示模式转换</h4>
<p>一个模式的元素需要另外一种模式的特性（增加&lt;a&gt;的触发范围）</p>
<p><strong>行内转块</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: 150<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 50<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">block</span>;</span><br></pre></td></tr></table></figure>
<p><strong>块转行</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline</span>;</span><br></pre></td></tr></table></figure>
<p><strong>转换为行内块</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">inline-block</span>;</span><br></pre></td></tr></table></figure>
<h3 id="9-背景"><a class="markdownIt-Anchor" href="#9-背景"></a> 9. 背景</h3>
<h4 id="91-背景颜色"><a class="markdownIt-Anchor" href="#91-背景颜色"></a> 9.1 背景颜色</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-color</span>: <span class="selector-tag">pink</span>;</span><br></pre></td></tr></table></figure>
<h4 id="92-背景图片"><a class="markdownIt-Anchor" href="#92-背景图片"></a> 9.2 背景图片</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-image</span>: <span class="selector-tag">url</span>();</span><br></pre></td></tr></table></figure>
<h4 id="93-背景平铺"><a class="markdownIt-Anchor" href="#93-背景平铺"></a> 9.3 背景平铺</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-repeat:repeat | norepeat | repeat-x;</span><br></pre></td></tr></table></figure>
<h4 id="94-背景图片位置"><a class="markdownIt-Anchor" href="#94-背景图片位置"></a> 9.4 背景图片位置</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background-position</span>: <span class="selector-tag">x</span> <span class="selector-tag">y</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/Gqr4JpAeHalkWiw.png" alt="1570887034135.png" /></p>
<ul>
<li>如果指定的两个值都是方位名词，则前后顺序无关</li>
<li>如果只指定了一个方位名词，则另一个默认center</li>
</ul>
<p><strong>精确单位</strong></p>
<ul>
<li>第一个肯定是x，第二个肯定是y</li>
</ul>
<h4 id="95-背景固定背景附着"><a class="markdownIt-Anchor" href="#95-背景固定背景附着"></a> 9.5 背景固定（背景附着）</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">background-attachment: scroll | fixed</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/2fyuIFax9GXYv7j.png" alt="1570887699177.png" /></p>
<h4 id="96-背景复合写法"><a class="markdownIt-Anchor" href="#96-背景复合写法"></a> 9.6 背景复合写法</h4>
<p>背景颜色、背景图片地址、背景平铺、背景图像滚动、背景图片位置</p>
<ul>
<li>没有顺序要求</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: 背景颜色 背景图片地址 背景平铺 背景图像滚动 背景图片位置;</span><br></pre></td></tr></table></figure>
<h4 id="97-背景色半透明"><a class="markdownIt-Anchor" href="#97-背景色半透明"></a> 9.7 背景色半透明</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.3</span>);</span><br></pre></td></tr></table></figure>
<h4 id="98-背景总结"><a class="markdownIt-Anchor" href="#98-背景总结"></a> 9.8 背景总结</h4>
<p><img src="https://i.loli.net/2021/07/21/o7yYjeVBuMxag4J.png" alt="1570888283511.png" /></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>1 HTML基本结构标签</title>
    <url>/2021/07/14/%E5%89%8D%E7%AB%AF/1%20HTML%E5%9F%BA%E6%9C%AC%E7%BB%93%E6%9E%84%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="html基本结构标签"><a class="markdownIt-Anchor" href="#html基本结构标签"></a> HTML基本结构标签</h2>
<a id="more"></a>
<ul>
<li>
<p>!DOCTYPE是文档类型声明标签，用来标识版本为html5</p>
</li>
<li>
<p>lang=&quot;en&quot;表示语言为英文（中文为zh-CN）</p>
</li>
<li>
<p>BGK是国标，UTF-8也被称为万国码，基本包含了全世界所有国家需要用的字符</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>1 js 简介</title>
    <url>/2021/08/01/%E5%89%8D%E7%AB%AF/1%20js%20%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="js-简介"><a class="markdownIt-Anchor" href="#js-简介"></a> js 简介</h2>
<h3 id="js简介"><a class="markdownIt-Anchor" href="#js简介"></a> js简介</h3>
<a id="more"></a>
<p>浏览器本身并不会执行JS代码，而是通过内置 JavaScript 引擎(解释器) 来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行，所以 JavaScript 语言归为脚本语言，会逐行解释执行。</p>
<h3 id="js书写位置"><a class="markdownIt-Anchor" href="#js书写位置"></a> js书写位置</h3>
<p>JS有3中书写位置，分别为行内、内嵌、外部</p>
<p><strong>行内</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">value</span>=<span class="string">"1"</span> <span class="attr">onclick</span>=<span class="string">"alert('2')"</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>内嵌</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">    alert(<span class="string">'123'</span>);</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>外部</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"./index.js"</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>2 HTML常用标签</title>
    <url>/2021/07/15/%E5%89%8D%E7%AB%AF/2%20HTML%E5%B8%B8%E7%94%A8%E6%A0%87%E7%AD%BE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="html常用标签"><a class="markdownIt-Anchor" href="#html常用标签"></a> HTML常用标签</h2>
<h3 id="1-段落和换行"><a class="markdownIt-Anchor" href="#1-段落和换行"></a> 1. 段落和换行</h3>
<a id="more"></a>
<ul>
<li>
<p>p：段落标签</p>
</li>
<li>
<p>br：换行标签</p>
</li>
</ul>
<h3 id="2-文本格式化标签"><a class="markdownIt-Anchor" href="#2-文本格式化标签"></a> 2. 文本格式化标签</h3>
<ul>
<li>
<p>strong或b：加粗</p>
</li>
<li>
<p>em或i：倾斜t</p>
</li>
<li>
<p>del或s：删除线</p>
</li>
<li>
<p>ins或u：下划线</p>
</li>
</ul>
<h3 id="3-div和span标签"><a class="markdownIt-Anchor" href="#3-div和span标签"></a> 3. &lt;div&gt;和&lt;span&gt;标签</h3>
<p>用来装内容的盒子，无语义</p>
<p><strong>特点</strong></p>
<ul>
<li>div一行只能放一个，大盒子。</li>
<li>span一行上可以多个，小盒子。</li>
</ul>
<h3 id="4-image标签"><a class="markdownIt-Anchor" href="#4-image标签"></a> 4. image标签</h3>
<p><img src="https://i.loli.net/2021/07/21/vdHcM21f7qaEz8n.png" alt="图片属性.png" /></p>
<h4 id="5-相对路径与绝对路径"><a class="markdownIt-Anchor" href="#5-相对路径与绝对路径"></a> 5. 相对路径与绝对路径</h4>
<p><img src="https://i.loli.net/2021/07/21/NAHObQGc7qXs2zx.png" alt="路径.png" /></p>
<p><strong>绝对路径</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">src=“https://i0.hdslb.com/bfs/face/4a425d42e4e3829a07e4a1b0d16c97062b8a3c5b.jpg@160w_160h_1c.webp”</span><br></pre></td></tr></table></figure>
<h3 id="6-超链接标签"><a class="markdownIt-Anchor" href="#6-超链接标签"></a> 6. 超链接标签</h3>
<ul>
<li>a：超链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"跳转目标"</span> <span class="attr">target</span>=<span class="string">"目标窗口的弹出方式"</span>&gt;</span> 文本或图像 <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/AipuHNTxfh8WR1b.png" alt="image-20210706102901832.png" /></p>
<h4 id="链接分类"><a class="markdownIt-Anchor" href="#链接分类"></a> 链接分类</h4>
<ul>
<li>
<p>外部链接</p>
</li>
<li>
<p>内部链接</p>
</li>
<li>
<p>空链接：href=“#”</p>
</li>
<li>
<p>下载链接：地址链接的是文件</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">href="img.zip"</span><br></pre></td></tr></table></figure>
<ul>
<li>网页元素的链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"http://www.baidu.com"</span>&gt;</span> <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"img.jpg"</span>/&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>锚点链接</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#two"</span>&gt;</span> <span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span> <span class="attr">id</span>=<span class="string">"two"</span>&gt;</span></span><br><span class="line">   	h3</span><br><span class="line"><span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="7-注释和特殊字符"><a class="markdownIt-Anchor" href="#7-注释和特殊字符"></a> 7. 注释和特殊字符</h3>
<p><strong>注释</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- more --&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>特殊字符</strong></p>
<p><img src="https://i.loli.net/2021/07/21/sduGSZzqaUMI3k8.png" alt="特殊字符.png" /></p>
<h3 id="8-表格标签"><a class="markdownIt-Anchor" href="#8-表格标签"></a> 8. 表格标签</h3>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>	<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    	<span class="tag">&lt;<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>&lt;/table&gt; 是用于定义表格的标签。</p>
</li>
<li>
<p>&lt;/tr&gt; 标签用于定义表格中的行，必须嵌套在 &lt;/table&gt;标签中。</p>
</li>
<li>
<p>&lt;/td&gt; 用于定义表格中的单元格，必须嵌套在&lt;/tr&gt;标签中。</p>
</li>
<li>
<p>字母 td 指表格数据（table data），即数据单元格的内容。</p>
</li>
<li>
<p>th：表头单元格，会加粗居中</p>
</li>
</ol>
<h4 id="表格属性"><a class="markdownIt-Anchor" href="#表格属性"></a> 表格属性</h4>
<p><img src="https://i.loli.net/2021/07/21/GK3iaqusnjcl694.png" alt="表格属性.png" /></p>
<h4 id="表格结构标签"><a class="markdownIt-Anchor" href="#表格结构标签"></a> 表格结构标签</h4>
<ul>
<li>thead：表格的头部区域</li>
<li>tbody：表格的主体区域</li>
</ul>
<h4 id="合并单元格"><a class="markdownIt-Anchor" href="#合并单元格"></a> 合并单元格</h4>
<ul>
<li>rowspan：跨行合并，最上侧单元格作为目标单元格</li>
<li>colspan：跨列合并，最左侧单元格作为目标单元格</li>
</ul>
<p>找到目标单元格，写上合并方式，删除多余的单元格。</p>
<h3 id="9-列表标签"><a class="markdownIt-Anchor" href="#9-列表标签"></a> 9. 列表标签</h3>
<h4 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>ul里只能放li，li里面可以用其他的标签</p>
<h4 id="有序列表"><a class="markdownIt-Anchor" href="#有序列表"></a> 有序列表</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="自定义列表"><a class="markdownIt-Anchor" href="#自定义列表"></a> 自定义列表</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dt</span>&gt;</span>关注我们<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>新浪微博<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>官方微信<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>dl用于定义列表</li>
<li>dt表示项目</li>
<li>dd表示名字</li>
</ul>
<h3 id="10-表单标签"><a class="markdownIt-Anchor" href="#10-表单标签"></a> 10. 表单标签</h3>
<p>由表单域、表单控件、提示信息组成</p>
<h4 id="表单域"><a class="markdownIt-Anchor" href="#表单域"></a> 表单域</h4>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"url地址"</span> <span class="attr">method</span>=<span class="string">"提交方式"</span> <span class="attr">name</span>=<span class="string">"表单域名称"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/MUQ4awtriW1eZKX.png" alt="表单常用属性.png" /></p>
<h4 id="表单控件"><a class="markdownIt-Anchor" href="#表单控件"></a> 表单控件</h4>
<h5 id="input输入表单元素"><a class="markdownIt-Anchor" href="#input输入表单元素"></a> input输入表单元素</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"属性值"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/AawbfjX3WGoFP72.png" alt="表单标签.png" /></p>
<ul>
<li>单标签</li>
</ul>
<p><img src="https://i.loli.net/2021/07/21/ZlC9F5fkotqI1xN.png" alt="表单其他属性.png" /></p>
<ul>
<li>多选1必须具有相同的name</li>
<li>value主要针对后台人员使用</li>
<li>checked针对按钮选择</li>
</ul>
<h5 id="label标签"><a class="markdownIt-Anchor" href="#label标签"></a> label标签</h5>
<p>label标签用于绑定一个表单元素，当点击label内文本时，会自动聚焦</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"sex"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"radio"</span> <span class="attr">name</span>=<span class="string">"sex"</span> <span class="attr">id</span>=<span class="string">"sex"</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>label标签的for属性应当与相关元素的id属性相同</li>
</ul>
<h5 id="select下拉表单元素"><a class="markdownIt-Anchor" href="#select下拉表单元素"></a> select下拉表单元素</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span>&gt;</span><span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>可以在option中定义selected=“selected”</li>
</ul>
<h5 id="texarea文本域元素"><a class="markdownIt-Anchor" href="#texarea文本域元素"></a> texarea文本域元素</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">rows</span>=<span class="string">"3"</span> <span class="attr">cols</span>=<span class="string">"50"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>2 CSS 特性、盒子模型、浮动</title>
    <url>/2021/07/17/%E5%89%8D%E7%AB%AF/2%20CSS%E7%89%B9%E6%80%A7%E3%80%81%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B%E3%80%81%E6%B5%AE%E5%8A%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="css-特性-盒子模型-浮动"><a class="markdownIt-Anchor" href="#css-特性-盒子模型-浮动"></a> CSS 特性、盒子模型、浮动</h2>
<h3 id="1-css-特性"><a class="markdownIt-Anchor" href="#1-css-特性"></a> 1. CSS 特性</h3>
<a id="more"></a>
<p>CSS三大特性：层叠性、继承性、优先级</p>
<h4 id="11-层叠性"><a class="markdownIt-Anchor" href="#11-层叠性"></a> 1.1 层叠性</h4>
<p><strong>层叠性原则</strong></p>
<ul>
<li>样式冲突，遵循<font color="red">就近原则</font>，哪个样式离结构近，就执行哪个样式</li>
<li>样式不冲突，不会层叠</li>
</ul>
<h4 id="12-继承性"><a class="markdownIt-Anchor" href="#12-继承性"></a> 1.2 继承性</h4>
<p>子标签会继承父标签的某些样式，如文本颜色和字号。</p>
<p><strong>行高的继承性</strong></p>
<p>行高为当前子元素大小的1.5倍</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">font: 12px/1.5 'Microsoft YaHei';</span><br></pre></td></tr></table></figure>
<h4 id="13-优先级"><a class="markdownIt-Anchor" href="#13-优先级"></a> 1.3 优先级</h4>
<ul>
<li>选择器相同，则执行层叠性</li>
<li>选择器不同，则根据<font color="red">选择器权重执行</font></li>
</ul>
<p><img src="https://i.loli.net/2021/07/21/t6ZYDoxUKdMFeqN.png" alt="1571490129794.png" /></p>
<p><strong>继承的权重是0</strong>，不管父元素权重多高，子元素的权重都是0</p>
<h5 id="131-复合选择器的优先级"><a class="markdownIt-Anchor" href="#131-复合选择器的优先级"></a> 1.3.1 复合选择器的优先级</h5>
<p>如果是复合选择器，则会有权重叠加，需要计算权重。</p>
<ul>
<li>div ul li → 0, 0, 3</li>
<li>.nav ul li → 0, 1, 2</li>
<li>a:hover → 0, 1, 1</li>
<li>.nav a → 0, 1, 1</li>
</ul>
<h3 id="2-盒子模型"><a class="markdownIt-Anchor" href="#2-盒子模型"></a> 2. 盒子模型</h3>
<p>边框border、外边距margin、内边距padding、实际内容content</p>
<img src="https://i.loli.net/2021/07/21/41uKBLPczAXhQqi.png" alt="1571492529986.png" style="zoom:80%;" />
<h4 id="21-border"><a class="markdownIt-Anchor" href="#21-border"></a> 2.1 border</h4>
<p>边框由三部分组成：边框宽度、边框样式、边框颜色</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">border: border-width || border-style || border-color</span><br></pre></td></tr></table></figure>
<ul>
<li>无顺序</li>
<li>边框宽度会影响盒子宽度</li>
</ul>
<h5 id="211-border-collapse"><a class="markdownIt-Anchor" href="#211-border-collapse"></a> 2.1.1 border-collapse</h5>
<p>合并边框</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-collapse</span>: <span class="selector-tag">collapse</span>;</span><br></pre></td></tr></table></figure>
<h4 id="22-内边距"><a class="markdownIt-Anchor" href="#22-内边距"></a> 2.2 内边距</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">padding</span>: 5<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/h23AvciRkGUtSlp.png" alt="1571493298248.png" /></p>
<ul>
<li>
<p>padding会影响盒子大小</p>
</li>
<li>
<p>用width和height减去padding的值</p>
</li>
<li>
<p>不用width、height的话不会撑大盒子</p>
</li>
</ul>
<h4 id="23-外边距"><a class="markdownIt-Anchor" href="#23-外边距"></a> 2.3 外边距</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">margin</span>: 0 <span class="selector-tag">auto</span>;</span><br></pre></td></tr></table></figure>
<h5 id="231-块级盒子水平居中"><a class="markdownIt-Anchor" href="#231-块级盒子水平居中"></a> 2.3.1 块级盒子水平居中</h5>
<ul>
<li>盒子必须指定宽度</li>
<li>左右外边距设为auto</li>
</ul>
<h5 id="232-行内元素水平居中"><a class="markdownIt-Anchor" href="#232-行内元素水平居中"></a> 2.3.2 行内元素水平居中</h5>
<ul>
<li>给父元素添加text-align: center</li>
</ul>
<h5 id="233-垂直外边距合并"><a class="markdownIt-Anchor" href="#233-垂直外边距合并"></a> 2.3.3 垂直外边距合并</h5>
<p><strong>相邻块元素垂直外边距的合并</strong></p>
<p><img src="https://i.loli.net/2021/07/21/UYDV2jCgIKhpsNb.png" alt="1571494239103.png" /></p>
<p><strong>嵌套块元素垂直外边距的塌陷</strong></p>
<p><img src="https://i.loli.net/2021/07/21/n4Mu8cLg61A7ZxE.png" alt="1571494373778.png" /></p>
<ul>
<li>可以为父元素定义上边框</li>
<li>可以为父元素定义上内边距</li>
<li>可以为父元素添加overflow:hidden</li>
</ul>
<p><strong>清除内外边距</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>行内元素尽量只设置左右的内外边距</li>
</ul>
<h4 id="24-圆角边框"><a class="markdownIt-Anchor" href="#24-圆角边框"></a> 2.4 圆角边框</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">border-radius</span>: 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h4 id="25-盒子阴影"><a class="markdownIt-Anchor" href="#25-盒子阴影"></a> 2.5 盒子阴影</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box-shadow</span>: <span class="selector-tag">h-shadow</span> <span class="selector-tag">v-shadow</span> <span class="selector-tag">blur</span> <span class="selector-tag">spread</span> <span class="selector-tag">color</span> <span class="selector-tag">inset</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/1IkehlaAvNYcR3V.png" alt="1571541874805.png" /></p>
<ul>
<li>
<p>默认为outset，不用写</p>
</li>
<li>
<p>阴影不占用空间</p>
</li>
</ul>
<h4 id="26-文字阴影"><a class="markdownIt-Anchor" href="#26-文字阴影"></a> 2.6 文字阴影</h4>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">text-shadow: h-shadow v-shadow blur color;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/8vVUThxKawdGioW.png" alt="1571541954222.png" /></p>
<h3 id="3-浮动"><a class="markdownIt-Anchor" href="#3-浮动"></a> 3. 浮动</h3>
<p><strong>float</strong>属性用于创建浮动框，将其移动到一边，直到左边缘或右边缘触及包含块或另一个浮动框的边缘。</p>
<p>多个块级元素纵向排列找标准流，多个块级元素横向排列找浮动。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">float: none || left || right;</span><br></pre></td></tr></table></figure>
<h4 id="31-浮动特性"><a class="markdownIt-Anchor" href="#31-浮动特性"></a> 3.1 浮动特性</h4>
<ol>
<li>
<p>脱离标准流的控制移动到指定位置（<strong>脱标</strong>）</p>
</li>
<li>
<p>浮动的盒子<strong>不再保留原先的位置</strong></p>
</li>
<li>
<p>浮动元素具有行内块元素特性</p>
<p>任何元素都可以浮动</p>
<ul>
<li>如果块级盒子没有设置宽度，默认宽度和父级一样宽，但是添加浮动后，它的大小根据内容来决定</li>
<li>浮动的盒子中间是没有缝隙的，是紧挨在一起的</li>
<li>行内元素同理</li>
</ul>
</li>
</ol>
<h4 id="32-浮动元素经常和标准流父级搭配使用"><a class="markdownIt-Anchor" href="#32-浮动元素经常和标准流父级搭配使用"></a> 3.2 浮动元素经常和标准流父级搭配使用</h4>
<p>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置，符合网页布局第一准则</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"box"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="4-常见网页布局"><a class="markdownIt-Anchor" href="#4-常见网页布局"></a> 4. 常见网页布局</h3>
<h4 id="41-常见网页布局"><a class="markdownIt-Anchor" href="#41-常见网页布局"></a> 4.1 常见网页布局</h4>
<p><img src="https://i.loli.net/2021/07/21/QHBEfoTRlMA158d.png" alt="1571555421784.png" style="zoom:50%;" />  				<img src="https://i.loli.net/2021/07/21/5fPXmqvE8VHrRT2.png" alt="1571555492364.png" style="zoom:50%;" /></p>
<img src="https://i.loli.net/2021/07/21/HULhF9J4SqzoVQP.png" alt="image-20210713172158796.png" style="zoom:80%;" />
<h4 id="42-浮动布局注意点"><a class="markdownIt-Anchor" href="#42-浮动布局注意点"></a> 4.2 浮动布局注意点</h4>
<ol>
<li>先用标准流的父元素排列上下位置，之后内部子元素采取浮动排列左右位置</li>
<li>浮动的盒子只会影响浮动盒子后面的标准流，不会影响前面的标准流</li>
</ol>
<h4 id="43-清除浮动"><a class="markdownIt-Anchor" href="#43-清除浮动"></a> 4.3 清除浮动</h4>
<p><img src="https://i.loli.net/2021/07/21/4wPetuXLW9gSpO7.png" alt="1571555883628.png" /></p>
<ul>
<li>清除浮动的本质是清除浮动元素造成的影响</li>
<li>如果父盒子本身有高度，则不需要清除浮动</li>
<li>清除浮动之后，父级就会根据浮动的子盒子自动检测高度。父级有了高度，就不会影响下面的标准流了</li>
</ul>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">clear: left || right || both;</span><br></pre></td></tr></table></figure>
<p><strong>清除浮动的策略</strong></p>
<p>闭合浮动：只让浮动在父盒子内部影响，不影响父盒子外面的其他盒子</p>
<h5 id="431-额外标签法隔墙法"><a class="markdownIt-Anchor" href="#431-额外标签法隔墙法"></a> 4.3.1 额外标签法（隔墙法）</h5>
<p>在浮动元素末尾添加一个空的标签，必须是块级元素</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.clear</span> &#123;</span></span><br><span class="line">        clear: both;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"clear"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="432-父级添加overflow属性"><a class="markdownIt-Anchor" href="#432-父级添加overflow属性"></a> 4.3.2 父级添加overflow属性</h5>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">	<span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：代码简洁</p>
<p>缺点：无法显示溢出的部分</p>
<h5 id="433-父级添加after伪元素"><a class="markdownIt-Anchor" href="#433-父级添加after伪元素"></a> 4.3.3 父级添加after伪元素</h5>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;			<span class="comment">/* IE6、7专有 */</span></span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：没有增加标签，结构更简单</p>
<h5 id="434-父级添加双伪元素"><a class="markdownIt-Anchor" href="#434-父级添加双伪元素"></a> 4.3.4 父级添加双伪元素</h5>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::bofore</span>, </span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">::after</span> &#123;</span><br><span class="line">    <span class="attribute">clear</span>: both; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.clearfix</span> &#123;			<span class="comment">/* IE6、7专有 */</span></span><br><span class="line">    *zoom: 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>优点：代码更简洁</p>
<h4 id="44-清除浮动总结"><a class="markdownIt-Anchor" href="#44-清除浮动总结"></a> 4.4 清除浮动总结</h4>
<p><strong>为什么需要清除浮动</strong></p>
<p>① 父级没高度</p>
<p>② 子盒子浮动了</p>
<p>③ 影响下面布局了</p>
<h3 id="5-css属性书写顺序"><a class="markdownIt-Anchor" href="#5-css属性书写顺序"></a> 5. CSS属性书写顺序</h3>
<ol>
<li>布局定位属性：display / position / float / clear / visibility / overflow</li>
<li>自身属性：width / height / margin / padding / border / background</li>
<li>文本属性：color / font / text-decoration / text-align / vertical-align / white- space / break-word</li>
<li>其他属性（CSS3）：content / cursor / border-radius / box-shadow / text-shadow / background:linear-gradient …</li>
</ol>
<h4 id="52-页面布局分析"><a class="markdownIt-Anchor" href="#52-页面布局分析"></a> 5.2 页面布局分析</h4>
<p>为了提高网页制作的效率，布局时通常有以下的布局流程：</p>
<ol>
<li>
<p>必须确定页面的版心（可视区），我们测量可得知。</p>
</li>
<li>
<p>分析页面中的行模块，以及每个行模块中的列模块。其实页面布局，就是一行行罗列而成的。</p>
</li>
<li>
<p>制作 HTML 结构。我们还是遵循，先有结构，后有样式的原则。结构永远最重要。</p>
</li>
<li>
<p>开始运用盒子模型的原理，通过 DIV+CSS 布局来控制网页的各个模块。</p>
</li>
</ol>
<h4 id="53-注意事项"><a class="markdownIt-Anchor" href="#53-注意事项"></a> 5.3 注意事项</h4>
<h5 id="531-导航栏"><a class="markdownIt-Anchor" href="#531-导航栏"></a> 5.3.1 导航栏</h5>
<p>实际开发中，我们不会直接用链接a而是用li包含链接a的做法</p>
<ul>
<li>li + a语义更清晰</li>
<li>如果直接用a，搜索引擎容易辨别为有堆砌关键字嫌疑，从而影响网站排名</li>
</ul>
<p><strong>注意</strong></p>
<p>1.让导航栏一行显示, 给 li 加浮动, 因为 li 是块级元素, 需要一行显示.</p>
<p>2.这个nav导航栏可以不给宽度,将来可以继续添加其余文字</p>
<p>3.因为导航栏里面文字不一样多,所以最好给链接 a 左右padding 撑开盒子,而不是指定宽度</p>
<h5 id="532-浮动"><a class="markdownIt-Anchor" href="#532-浮动"></a> 5.3.2 浮动</h5>
<p>浮动的盒子不会有外边距合并</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>2 js 语法</title>
    <url>/2021/08/02/%E5%89%8D%E7%AB%AF/2%20js%20%E8%AF%AD%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="js-语法"><a class="markdownIt-Anchor" href="#js-语法"></a> js 语法</h2>
<a id="more"></a>
<h3 id="1-js-输入输出语句"><a class="markdownIt-Anchor" href="#1-js-输入输出语句"></a> 1. js 输入输出语句</h3>
<table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>说明</strong></th>
<th><strong>归属</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>alert(msg)</td>
<td>浏览器弹出警示框</td>
<td>浏览器</td>
</tr>
<tr>
<td>console.log(msg)</td>
<td>浏览器控制台打印输出信息</td>
<td>浏览器</td>
</tr>
<tr>
<td>prompt(info)</td>
<td>浏览器弹出输入框，用户可以输入</td>
<td>浏览器</td>
</tr>
</tbody>
</table>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">var name = prompt('输入姓名');</span><br><span class="line">alert(name);</span><br></pre></td></tr></table></figure>
<h3 id="2-变量"><a class="markdownIt-Anchor" href="#2-变量"></a> 2. 变量</h3>
<table>
<thead>
<tr>
<th><strong>情况</strong></th>
<th><strong>说明</strong></th>
<th><strong>结果</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>var age ; console.log (age);</td>
<td>只声明 不赋值</td>
<td>undefined</td>
</tr>
<tr>
<td>console.log(age)</td>
<td>不声明 不赋值 直接使用</td>
<td>报错</td>
</tr>
<tr>
<td>age  = 10; console.log (age);</td>
<td>不声明  只赋值</td>
<td>10</td>
</tr>
</tbody>
</table>
<h3 id="3-数据类型"><a class="markdownIt-Anchor" href="#3-数据类型"></a> 3. 数据类型</h3>
<p><strong>JavaScript</strong> **是一种弱类型或者说动态语言。**这意味着不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> age = <span class="number">10</span>;				<span class="comment">// 数字型</span></span><br><span class="line"><span class="keyword">var</span> areYouOk = <span class="string">'是的'</span>;	   <span class="comment">// 字符型</span></span><br></pre></td></tr></table></figure>
<p>在代码运行时，变量的数据类型是由 JS引擎 根据 = 右边变量值的数据类型来判断 的，运行完毕之后， 变量就确定了数据类型。</p>
<p>JavaScript 拥有动态类型，同时也意味着相同的变量可用作不同的类型：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">6</span>;			<span class="comment">// x为数字</span></span><br><span class="line"><span class="keyword">var</span> x = <span class="string">'Bill'</span>;		<span class="comment">// x为字符串</span></span><br></pre></td></tr></table></figure>
<h4 id="31-简单数据类型"><a class="markdownIt-Anchor" href="#31-简单数据类型"></a> 3.1 简单数据类型</h4>
<p><img src="https://i.loli.net/2021/08/02/TLO1IPRhJjqaHVG.png" alt="1.png" /></p>
<h5 id="311-数字型三个特殊值"><a class="markdownIt-Anchor" href="#311-数字型三个特殊值"></a> 3.1.1 数字型三个特殊值</h5>
<ul>
<li>
<p>Infinity ，代表无穷大，大于任何数值</p>
</li>
<li>
<p>-Infinity ，代表无穷小，小于任何数值</p>
</li>
<li>
<p>NaN ，Not a number，代表一个非数值</p>
</li>
</ul>
<h5 id="314-undefined-和-null"><a class="markdownIt-Anchor" href="#314-undefined-和-null"></a> 3.1.4 Undefined 和 Null</h5>
<p>一个声明后没有被赋值的变量会有一个默认值 undefined ( 如果进行相连或者相加时，注意结果）</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> variable;</span><br><span class="line"><span class="built_in">console</span>.log(variable);				<span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好'</span> + variable);	   <span class="comment">// 你好undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11</span> + variable);			<span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + variable);		<span class="comment">//  NaN</span></span><br></pre></td></tr></table></figure>
<p>一个声明变量给 null 值，里面存的值为空</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vari = <span class="literal">null</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'你好'</span> + vari);  		<span class="comment">// 你好null</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">11</span> + vari);     	 <span class="comment">// 11</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="literal">true</span> + vari);   	 <span class="comment">//  1</span></span><br></pre></td></tr></table></figure>
<h4 id="32-typeof"><a class="markdownIt-Anchor" href="#32-typeof"></a> 3.2 typeof</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> num = <span class="number">18</span>;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> num) <span class="comment">// 结果 number</span></span><br></pre></td></tr></table></figure>
<h4 id="33-数据类型转换"><a class="markdownIt-Anchor" href="#33-数据类型转换"></a> 3.3 数据类型转换</h4>
<p><img src="https://i.loli.net/2021/08/02/hpMuOKcFIlHgiP5.png" alt="2.png" /></p>
<p><img src="https://i.loli.net/2021/08/02/oxbztX2KLRn3VJ8.png" alt="3.png" /></p>
<h3 id="4-运算符"><a class="markdownIt-Anchor" href="#4-运算符"></a> 4. 运算符</h3>
<h4 id="41-浮点数的精度问题"><a class="markdownIt-Anchor" href="#41-浮点数的精度问题"></a> 4.1 浮点数的精度问题</h4>
<p>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> result = <span class="number">0.1</span> + <span class="number">0.2</span>;    <span class="comment">// 结果不是 0.3，而是：0.30000000000000004</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">0.07</span> * <span class="number">100</span>);   <span class="comment">// 结果不是 7，  而是：7.000000000000001</span></span><br></pre></td></tr></table></figure>
<p>不能直接判断两个浮点数是否相等 !</p>
<h4 id="42-比较运算符"><a class="markdownIt-Anchor" href="#42-比较运算符"></a> 4.2 比较运算符</h4>
<p><img src="https://i.loli.net/2021/08/02/BRNKEaCLf1QqXGr.png" alt="4.png" /></p>
<h4 id="43-逻辑运算符短路运算"><a class="markdownIt-Anchor" href="#43-逻辑运算符短路运算"></a> 4.3 逻辑运算符（短路运算）</h4>
<p>**短路运算的原理：**当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值。</p>
<h5 id="1-逻辑与"><a class="markdownIt-Anchor" href="#1-逻辑与"></a> 1. 逻辑与</h5>
<ul>
<li>
<p>语法： <font color="red">表达式1 &amp;&amp; 表达式2</font></p>
</li>
<li>
<p>如果第一个表达式的值为真，则返回表达式2</p>
</li>
<li>
<p>如果第一个表达式的值为假，则返回表达式1</p>
</li>
</ul>
<h5 id="2-逻辑或"><a class="markdownIt-Anchor" href="#2-逻辑或"></a> 2. 逻辑或</h5>
<ul>
<li>
<p>语法： <font color="red">表达式1 || 表达式2</font></p>
</li>
<li>
<p>如果第一个表达式的值为真，则返回表达式1</p>
</li>
<li>
<p>如果第一个表达式的值为假，则返回表达式2</p>
</li>
</ul>
<h4 id="44-运算符优先级"><a class="markdownIt-Anchor" href="#44-运算符优先级"></a> 4.4 运算符优先级</h4>
<p><img src="https://i.loli.net/2021/08/02/C4nlscPOirNQXJZ.png" alt="5.png" /></p>
<h3 id="5-数组"><a class="markdownIt-Anchor" href="#5-数组"></a> 5. 数组</h3>
<h4 id="51-创建数组"><a class="markdownIt-Anchor" href="#51-创建数组"></a> 5.1 创建数组</h4>
<ul>
<li>
<p>利用 new 创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>利用数组字面量创建数组</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="keyword">var</span>  arr = [<span class="string">'小白'</span>,<span class="string">'小黑'</span>,<span class="string">'大黄'</span>,<span class="string">'瑞奇'</span>];</span><br><span class="line"></span><br><span class="line">#### 5.2 数组新增元素</span><br><span class="line"></span><br><span class="line">- 通过修改 length 长度新增数组元素，length 是可读写的</span><br><span class="line"></span><br><span class="line">  <span class="string">``</span><span class="string">`js</span></span><br><span class="line"><span class="string">  var arr = ['red', 'green', 'blue', 'pink'];</span></span><br><span class="line"><span class="string">  arr.length = 7;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>通过修改数组索引新增数组元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="string">'red'</span>, <span class="string">'green'</span>, <span class="string">'blue'</span>, <span class="string">'pink'</span>];</span><br><span class="line">arr[<span class="number">4</span>] = <span class="string">'hotpink'</span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="6-函数"><a class="markdownIt-Anchor" href="#6-函数"></a> 6. 函数</h3>
<h4 id="61-函数参数"><a class="markdownIt-Anchor" href="#61-函数参数"></a> 6.1 函数参数</h4>
<p><img src="https://i.loli.net/2021/08/02/rhd9Uqo72QSvbkG.png" alt="6.png" /></p>
<h4 id="62-函数返回值"><a class="markdownIt-Anchor" href="#62-函数返回值"></a> 6.2 函数返回值</h4>
<ul>
<li>如果函数没有 return ，返回的值是 undefined</li>
</ul>
<h4 id="63-arguments"><a class="markdownIt-Anchor" href="#63-arguments"></a> 6.3 arguments</h4>
<p>当我们不确定有多少个参数传递的时候，可以用 <strong>arguments</strong> 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个<strong>内置对象</strong>。所有函数都内置了一个 arguments 对象，<strong>arguments 对象中存储了传递的所有实参</strong>。</p>
<p><strong>arguments展示形式是一个伪数组</strong>，因此可以进行遍历。伪数组具有以下特点：</p>
<ul>
<li>具有 length 属性</li>
<li>按索引方式储存数据</li>
<li>不具有数组的 push , pop 等方法</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">maxValue</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> max = <span class="built_in">arguments</span>[<span class="number">0</span>];</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">         <span class="keyword">if</span> (max &lt; <span class="built_in">arguments</span>[i]) &#123;</span><br><span class="line">                    max = <span class="built_in">arguments</span>[i];</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> max;</span><br><span class="line">&#125;</span><br><span class="line"> <span class="built_in">console</span>.log(maxValue(<span class="number">2</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">9</span>));</span><br><span class="line"> <span class="built_in">console</span>.log(maxValue(<span class="number">12</span>, <span class="number">4</span>, <span class="number">9</span>));</span><br></pre></td></tr></table></figure>
<h4 id="64-函数声明方式"><a class="markdownIt-Anchor" href="#64-函数声明方式"></a> 6.4 函数声明方式</h4>
<ul>
<li>
<p>命名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 声明定义方式</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;...&#125;</span><br><span class="line"><span class="comment">// 调用  </span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>匿名函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这是函数表达式写法，匿名函数后面跟分号结束</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;...&#125;；</span><br><span class="line"><span class="comment">// 调用的方式，函数调用必须写到函数体下面</span></span><br><span class="line">fn();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="65-立即执行函数"><a class="markdownIt-Anchor" href="#65-立即执行函数"></a> 6.5 立即执行函数</h4>
<p>不需要调用，立马能够自己执行的函数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)()</span><br><span class="line"><span class="number">2.</span> (<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;());</span><br></pre></td></tr></table></figure>
<p>主要作用：创建一个独立的作用域，避免了命名冲突问题</p>
<h3 id="7-作用域"><a class="markdownIt-Anchor" href="#7-作用域"></a> 7. 作用域</h3>
<ul>
<li>js 没有块作用域</li>
<li>用 var 在函数内创建局部变量</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn() &#123;</span><br><span class="line">    a = b = c = <span class="number">10</span>;		<span class="comment">// a, b, c为全局变量</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="8-预解析"><a class="markdownIt-Anchor" href="#8-预解析"></a> 8. 预解析</h3>
<p><strong>|预解析|</strong>：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和 function 声明的变量在内存中进行提前声明或者定义。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(num);  		<span class="comment">// undifined</span></span><br><span class="line"><span class="keyword">var</span> num = <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn();					<span class="comment">// 10</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">fn();					<span class="comment">// undifined</span></span><br><span class="line"><span class="keyword">var</span>  fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>等价于</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> fn;</span><br><span class="line">fn();</span><br><span class="line">fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="built_in">console</span>.log(<span class="number">10</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="9-对象"><a class="markdownIt-Anchor" href="#9-对象"></a> 9. 对象</h3>
<h4 id="91-利用字面量创建对象"><a class="markdownIt-Anchor" href="#91-利用字面量创建对象"></a> 9.1 利用字面量创建对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> star = &#123;</span><br><span class="line">    name : <span class="string">'Jaron'</span>,</span><br><span class="line">    age : <span class="number">18</span>,</span><br><span class="line">    sex : <span class="string">'男'</span>,</span><br><span class="line">    sayHi : <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">'嗷呜~'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="92-利用new-object创建对象"><a class="markdownIt-Anchor" href="#92-利用new-object创建对象"></a> 9.2 利用new Object创建对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> andy = <span class="keyword">new</span> Obect();</span><br><span class="line">andy.name = <span class="string">'Jaron'</span>;</span><br><span class="line">andy.age = <span class="number">18</span>;</span><br><span class="line">andy.sex = <span class="string">'男'</span>;</span><br><span class="line">andy.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">'嗷呜~'</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="93-利用构造函数创建对象"><a class="markdownIt-Anchor" href="#93-利用构造函数创建对象"></a> 9.3 利用构造函数创建对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, sex</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">this</span>.name = name;</span><br><span class="line">     <span class="keyword">this</span>.age = age;</span><br><span class="line">     <span class="keyword">this</span>.sex = sex;</span><br><span class="line">     <span class="keyword">this</span>.sayHi = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      alert(<span class="string">'我的名字叫：'</span> + <span class="keyword">this</span>.name + <span class="string">'，年龄：'</span> + <span class="keyword">this</span>.age + <span class="string">'，性别：'</span> + <span class="keyword">this</span>.sex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> bigbai = <span class="keyword">new</span> Person(<span class="string">'大白'</span>, <span class="number">100</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="keyword">var</span> smallbai = <span class="keyword">new</span> Person(<span class="string">'小白'</span>, <span class="number">21</span>, <span class="string">'男'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(bigbai.name);</span><br><span class="line"><span class="built_in">console</span>.log(smallbai.name);</span><br></pre></td></tr></table></figure>
<ol>
<li>构造函数约定首字母大写。</li>
<li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li>
<li>构造函数中不需要 return 返回结果。</li>
<li>当我们创建对象的时候，必须用 new 来调用构造函数。</li>
</ol>
<h4 id="94-遍历对象属性"><a class="markdownIt-Anchor" href="#94-遍历对象属性"></a> 9.4 遍历对象属性</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> k <span class="keyword">in</span> obj) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(k);      <span class="comment">// 这里的 k 是属性名</span></span><br><span class="line">    <span class="built_in">console</span>.log(obj[k]); <span class="comment">// 这里的 obj[k] 是属性值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="10-内置对象"><a class="markdownIt-Anchor" href="#10-内置对象"></a> 10. 内置对象</h3>
<h4 id="101-math-对象"><a class="markdownIt-Anchor" href="#101-math-对象"></a> 10.1 Math 对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Math</span>.PI		 		   <span class="comment">// 圆周率</span></span><br><span class="line"><span class="built_in">Math</span>.floor() 	 	   <span class="comment">// 向下取整</span></span><br><span class="line"><span class="built_in">Math</span>.ceil()            <span class="comment">// 向上取整</span></span><br><span class="line"><span class="built_in">Math</span>.round()           <span class="comment">// 四舍五入版 就近取整   注意 -3.5   结果是  -3 </span></span><br><span class="line"><span class="built_in">Math</span>.abs()			   <span class="comment">// 绝对值</span></span><br><span class="line"><span class="built_in">Math</span>.max()/<span class="built_in">Math</span>.min()  <span class="comment">// 求最大和最小值</span></span><br></pre></td></tr></table></figure>
<h4 id="102-date-对象"><a class="markdownIt-Anchor" href="#102-date-对象"></a> 10.2 Date 对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> now = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"><span class="built_in">console</span>.log(now);</span><br></pre></td></tr></table></figure>
<ul>
<li>如果Date()不写参数，就返回当前时间</li>
<li>如果Date()里面写参数，就返回括号里面输入的时间</li>
</ul>
<p><img src="https://i.loli.net/2021/08/02/JryvZ4H63QsOu7b.png" alt="7.png" /></p>
<h4 id="103-数组对象"><a class="markdownIt-Anchor" href="#103-数组对象"></a> 10.3 数组对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = <span class="keyword">new</span> <span class="built_in">Array</span>();</span><br></pre></td></tr></table></figure>
<h5 id="1031-数组检测"><a class="markdownIt-Anchor" href="#1031-数组检测"></a> 10.3.1 数组检测</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(arr <span class="keyword">instanceof</span> <span class="built_in">Array</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(arr));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="1032-数组方法"><a class="markdownIt-Anchor" href="#1032-数组方法"></a> 10.3.2 数组方法</h5>
<p><img src="https://i.loli.net/2021/08/02/oYngFlBaxfe6D9O.png" alt="8.png" /></p>
<p><strong>sort</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">64</span>, <span class="number">9</span>, <span class="number">6</span>];</span><br><span class="line">arr.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b - a;      <span class="comment">// 降序</span></span><br><span class="line">    <span class="comment">// return a - b;   // 升序</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">console</span>.log(arr);</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/02/J3hjPanmOCplWVo.png" alt="9.png" /><br />
<img src="https://i.loli.net/2021/08/02/iapmJ4zGtb7NKBg.png" alt="10.png" /></p>
<h4 id="104-字符串对象"><a class="markdownIt-Anchor" href="#104-字符串对象"></a> 10.4 字符串对象</h4>
<h5 id="1041-基本包装类型"><a class="markdownIt-Anchor" href="#1041-基本包装类型"></a> 10.4.1 基本包装类型</h5>
<p><strong>|基本包装类型|</strong>：就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'andy'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.length);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span></span><br><span class="line"><span class="keyword">var</span> temp = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'andy'</span>);</span><br><span class="line"><span class="comment">// 2. 赋值给我们声明的字符变量</span></span><br><span class="line">str = temp;</span><br><span class="line"><span class="comment">// 3. 销毁临时变量</span></span><br><span class="line">temp = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h5 id="1042-字符串的不可变"><a class="markdownIt-Anchor" href="#1042-字符串的不可变"></a> 10.4.2 字符串的不可变</h5>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'abc'</span>;</span><br><span class="line">str = <span class="string">'hello'</span>;</span><br><span class="line"><span class="comment">// 当重新给 str 赋值的时候，常量'abc'不会被修改，依然在内存中</span></span><br><span class="line"><span class="comment">// 重新给字符串赋值，会重新在内存中开辟空间，这个特点就是字符串的不可变</span></span><br><span class="line"><span class="comment">// 由于字符串的不可变，在大量拼接字符串的时候会有效率问题</span></span><br><span class="line"><span class="keyword">var</span> str = <span class="string">''</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">100000</span>; i++) &#123;</span><br><span class="line">    str += i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(str); <span class="comment">// 这个结果需要花费大量时间来显示，因为需要不断的开辟新的空间</span></span><br></pre></td></tr></table></figure>
<h5 id="1043-字符串方法"><a class="markdownIt-Anchor" href="#1043-字符串方法"></a> 10.4.3 字符串方法</h5>
<p><img src="https://i.loli.net/2021/08/02/uietF4qzPwZ7jO5.png" alt="11.png" /></p>
<p>replace() 方法用于在字符串中用一些字符替换另一些字符。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">replace(被替换的字符串， 要替换为的字符串)；		<span class="comment">// 只替换第一个字符</span></span><br></pre></td></tr></table></figure>
<p>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> str = <span class="string">'a,b,c,d'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(str.split(<span class="string">','</span>));   <span class="comment">// 返回的是一个数组 [a, b, c, d]</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>3 CSS CSS定位、元素显示与隐藏</title>
    <url>/2021/07/18/%E5%89%8D%E7%AB%AF/3%20CSS%E5%AE%9A%E4%BD%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="css定位-元素显示与隐藏"><a class="markdownIt-Anchor" href="#css定位-元素显示与隐藏"></a> CSS定位、元素显示与隐藏</h2>
<h3 id="1-定位"><a class="markdownIt-Anchor" href="#1-定位"></a> 1. 定位</h3>
<a id="more"></a>
<p>浮动可以让多个块级盒子一行没有缝隙排列显示，经常用于横向排列盒子</p>
<p>定位则是可以让盒子自由的在某个盒子内移动位置或者固定屏幕中的某个位置，并且可以压住其他盒子</p>
<p>定位 = 定位模式 + 边偏移</p>
<h4 id="11-定位模式"><a class="markdownIt-Anchor" href="#11-定位模式"></a> 1.1 定位模式</h4>
<p>定位模式决定元素的定位方式，它通过position的属性来设置</p>
<p><img src="https://i.loli.net/2021/07/21/VGwRP8oi7qaLUdj.png" alt="image-20210715151138669.png" /></p>
<h4 id="12-边偏移"><a class="markdownIt-Anchor" href="#12-边偏移"></a> 1.2 边偏移</h4>
<p>边偏移就是定位的盒子移动到最终位置，有top、right、bottom和left四个属性。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">top</span>: 80<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h4 id="13-静态定位static"><a class="markdownIt-Anchor" href="#13-静态定位static"></a> 1.3 静态定位static</h4>
<p>元素的默认定位方式，无定位</p>
<ul>
<li>按照标准流特性摆放位置，没有边偏移</li>
</ul>
<h4 id="14-相对定位"><a class="markdownIt-Anchor" href="#14-相对定位"></a> 1.4 相对定位</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>它是相对于自己原来的位置来移动的。</p>
</li>
<li>
<p>原来在标准流的位置继续占有，后面的盒子仍然以标准流的方式对待它。（停职留薪）</p>
</li>
<li>
<p>相对定位并没有脱标，它最典型的应用是给绝对定位当爹。</p>
</li>
</ol>
<h4 id="15-绝对定位"><a class="markdownIt-Anchor" href="#15-绝对定位"></a> 1.5 绝对定位</h4>
<p>绝对定位是元素在移动位置的时候，相对于它祖先元素来说的。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>如果没有祖先元素或者祖先元素没有定位，则以浏览器为准定位。</li>
<li>如果祖先元素有定位（相对、绝对、固定定位），则以最近一级的有定位祖先元素为参考点移动位置。</li>
<li>绝对定位不再占有原先的位置。（脱标）</li>
</ol>
<h4 id="16-固定定位"><a class="markdownIt-Anchor" href="#16-固定定位"></a> 1.6 固定定位</h4>
<p>固定定位是元素固定于浏览器可视区的位置。主要使用场景：可以在浏览器页面滚动时元素的位置不会改变。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>
<p>以浏览器的可视窗口为参照点移动元素。</p>
<ul>
<li>跟父元素没有任何关系</li>
<li>不随滚动条滚动</li>
</ul>
</li>
<li>
<p>固定定位不再占有原先的位置</p>
<p>固定定位也是脱标的，可以看作是一种特殊的绝对定位</p>
</li>
</ol>
<p><strong>固定定位小技巧：固定在版心右侧</strong></p>
<ol>
<li>让固定定位的盒子 left: 50%. 走到浏览器可视区（也可以看做版心） 的一半位置。</li>
<li>让固定定位的盒子 margin-left: 版心宽度的一半距离。 多走 版心宽度的一半位置。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">fixed</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 50%;</span><br><span class="line"><span class="selector-tag">margin-left</span>: 410<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 100<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">height</span>: 100<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<h4 id="17-粘性定位"><a class="markdownIt-Anchor" href="#17-粘性定位"></a> 1.7 粘性定位</h4>
<p>粘性定位可以被认为是相对定位和固定定位的混合。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">sticky</span>; <span class="selector-tag">top</span>: 10<span class="selector-tag">px</span>;</span><br></pre></td></tr></table></figure>
<ol>
<li>以浏览器的可视窗口为参照点移动元素（固定定位特点）</li>
<li>粘性定位占有原先的位置（相对定位特点）</li>
<li>必须添加 top 、left、right、bottom 其中一个才有效</li>
</ol>
<p>IE不兼容</p>
<h4 id="18-定位叠放次序"><a class="markdownIt-Anchor" href="#18-定位叠放次序"></a> 1.8 定位叠放次序</h4>
<p>在使用定位布局时，可能会出现盒子重叠的情况，用z-index来控制盒子的</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">z-index</span>: 1;</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>数值越大，盒子越靠上</p>
</li>
<li>
<p>属性值相同，则按照书写顺序，后来居上</p>
</li>
<li>
<p>只有定位的盒子才有z-index属性</p>
</li>
</ul>
<h4 id="19-定位的拓展"><a class="markdownIt-Anchor" href="#19-定位的拓展"></a> 1.9 定位的拓展</h4>
<h5 id="191-绝对定位的盒子居中"><a class="markdownIt-Anchor" href="#191-绝对定位的盒子居中"></a> 1.9.1 绝对定位的盒子居中</h5>
<p>加了绝对定位的盒子不能通过<css>margin: 0 auto</css>水平居中</p>
<ol>
<li>让盒子的左侧移动到父级元素的水平中心位置。</li>
<li>让盒子向左移动自身宽度的一半。</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">position</span>: <span class="selector-tag">absolute</span>;</span><br><span class="line"><span class="selector-tag">width</span>: 200<span class="selector-tag">px</span>;</span><br><span class="line"><span class="selector-tag">left</span>: 50%:</span><br><span class="line"><span class="selector-tag">margin-left</span>: <span class="selector-tag">-100px</span>;</span><br></pre></td></tr></table></figure>
<h5 id="192-定位特殊特性"><a class="markdownIt-Anchor" href="#192-定位特殊特性"></a> 1.9.2 定位特殊特性</h5>
<p>绝对定位和固定定位也和浮动类似。</p>
<ol>
<li>行内元素添加绝对或者固定定位，可以直接设置高度和宽度。</li>
<li>块级元素添加绝对或者固定定位，如果不给宽度或者高度，默认大小是内容的大小。</li>
</ol>
<h5 id="193-脱标的盒子不会触发外边距塌陷"><a class="markdownIt-Anchor" href="#193-脱标的盒子不会触发外边距塌陷"></a> 1.9.3 脱标的盒子不会触发外边距塌陷</h5>
<p>浮动元素、绝对定位（固定定位）元素都不会触发外边距合并的问题。</p>
<h5 id="194-绝对定位固定定位会完全压住盒子"><a class="markdownIt-Anchor" href="#194-绝对定位固定定位会完全压住盒子"></a> 1.9.4 绝对定位（固定定位）会完全压住盒子</h5>
<p>浮动元素只会压住它下面标准流的盒子，但是不会压住下面标准流盒子里面的文字。</p>
<p>绝对定位（固定定位） 会压住下面标准流所有的内容，包含文字。</p>
<p>浮动之所以不会压住文字，因为浮动产生的目的最初是为了做文字环绕效果的。 文字会围绕浮动元素。</p>
<h5 id="195-边偏移重叠"><a class="markdownIt-Anchor" href="#195-边偏移重叠"></a> 1.9.5 边偏移重叠</h5>
<p>如果一个盒子既有left属性也有right属性，则默认会执行left属性，top、bottom同理</p>
<h3 id="2-网页布局总结"><a class="markdownIt-Anchor" href="#2-网页布局总结"></a> 2. 网页布局总结</h3>
<ol>
<li>
<p>标准流</p>
<p>可以让盒子上下排列或者左右排列，垂直的块级盒子显示就用标准流布局。</p>
</li>
<li>
<p>浮动</p>
<p>可以让多个块级元素一行显示或者左右对齐盒子，多个块级盒子水平显示就用浮动布局。</p>
</li>
<li>
<p>定位</p>
<p>定位最大的特点是有层叠的概念，就是可以让多个盒子前后叠压来显示。如果元素自由在某个盒子内移动就 用定位布局。</p>
</li>
</ol>
<h3 id="3-元素的显示与隐藏"><a class="markdownIt-Anchor" href="#3-元素的显示与隐藏"></a> 3. 元素的显示与隐藏</h3>
<p>让一个元素在页面中隐藏或者显示出来</p>
<h4 id="31-display属性"><a class="markdownIt-Anchor" href="#31-display属性"></a> 3.1 display属性</h4>
<p>display属性用于设置一个元素应如何显示</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">box</span><span class="selector-pseudo">:hover</span> <span class="selector-class">.mask</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>display: none；	隐藏对象</li>
<li>display: block;       显示元素</li>
</ul>
<p>display隐藏元素后，不再占有原来的位置。</p>
<h4 id="32-visibility-可见性"><a class="markdownIt-Anchor" href="#32-visibility-可见性"></a> 3.2 visibility 可见性</h4>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">visibiliity: visible || hidden;</span><br></pre></td></tr></table></figure>
<ul>
<li>visibility: visible；	元素可视</li>
<li>visibility: hidden;      元素隐藏</li>
</ul>
<p>visibility隐藏元素后，继续占有原来的位置。</p>
<h4 id="33-overflow溢出"><a class="markdownIt-Anchor" href="#33-overflow溢出"></a> 3.3 overflow溢出</h4>
<p>overflow 属性指定了如果内容溢出一个元素的框（超过其指定高度及宽度） 时，会发生什么。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/r4sbTPmLVjoUIK6.png" alt="image-20210716103943915.png" /></p>
<p>如果有定位的盒子，需要慎用overflow，因为它会隐藏多余的部分。</p>
<h4 id="34-总结"><a class="markdownIt-Anchor" href="#34-总结"></a> 3.4 总结</h4>
<ol>
<li>display 显示隐藏元素 但是不保留位置</li>
<li>visibility 显示隐藏元素 但是保留原来的位置</li>
<li>overflow 溢出显示隐藏 但是只是对于溢出的部分处理</li>
</ol>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>3 js DOM操作</title>
    <url>/2021/08/08/%E5%89%8D%E7%AB%AF/3%20js%20DOM%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="js-dom操作"><a class="markdownIt-Anchor" href="#js-dom操作"></a> js DOM操作</h2>
<h3 id="1-获取元素"><a class="markdownIt-Anchor" href="#1-获取元素"></a> 1. 获取元素</h3>
<a id="more"></a>
<h4 id="11-根据-id-获取"><a class="markdownIt-Anchor" href="#11-根据-id-获取"></a> 1.1 根据 ID 获取</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementById(<span class="string">'id'</span>);</span><br></pre></td></tr></table></figure>
<p>使用 console.dir() 可以打印我们获取的元素对象，更好的查看对象里面的属性和方法。</p>
<h4 id="12-根据标签名获取"><a class="markdownIt-Anchor" href="#12-根据标签名获取"></a> 1.2 根据标签名获取</h4>
<p>返回带有指定标签名的对象的集合。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.getElementsByTagName(<span class="string">'标签名'</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>
<p>因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。</p>
</li>
<li>
<p>得到元素对象是动态的</p>
</li>
</ul>
<p>还可以获取某个元素(父元素)内部所有指定标签名的子元素。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ol = <span class="built_in">document</span>.getElementById(<span class="string">'ol'</span>);</span><br><span class="line"><span class="keyword">var</span> li = ol.getElementsByTagName(<span class="string">'li'</span>);</span><br></pre></td></tr></table></figure>
<h4 id="13-通过-html5-新增的方法获取"><a class="markdownIt-Anchor" href="#13-通过-html5-新增的方法获取"></a> 1.3 通过 HTML5 新增的方法获取</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.getElementsByClassName(‘类名’)；<span class="comment">// 根据类名返回元素对象集合</span></span><br><span class="line"><span class="number">2.</span> <span class="built_in">document</span>.querySelector(<span class="string">'选择器'</span>);        <span class="comment">// 根据指定选择器返回第一个元素对象</span></span><br><span class="line"><span class="number">3.</span> <span class="built_in">document</span>.querySelectorAll(<span class="string">'选择器'</span>);     <span class="comment">// 根据指定选择器返回</span></span><br></pre></td></tr></table></figure>
<p>querySelector 和 querySelectorAll里面的选择器需要加符号,比如:document.querySelector(‘#nav’);</p>
<h4 id="14-获取特殊元素bodyhtml"><a class="markdownIt-Anchor" href="#14-获取特殊元素bodyhtml"></a> 1.4 获取特殊元素（body，html）</h4>
<p>获取body元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> doucumnet.body  <span class="comment">// 返回body元素对象</span></span><br></pre></td></tr></table></figure>
<p>获取html元素</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> <span class="built_in">document</span>.documentElement  <span class="comment">// 返回html元素对象</span></span><br></pre></td></tr></table></figure>
<h3 id="2-事件"><a class="markdownIt-Anchor" href="#2-事件"></a> 2. 事件</h3>
<ol>
<li>
<p>获取事件源</p>
</li>
<li>
<p>注册事件（绑定事件）</p>
</li>
<li>
<p>添加事件处理程序（采取函数赋值形式）</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.getElementById(<span class="string">'btn'</span>);</span><br><span class="line">btn.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'你好吗'</span>);  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-操作元素"><a class="markdownIt-Anchor" href="#3-操作元素"></a> 3. 操作元素</h3>
<h4 id="31-改变元素内容"><a class="markdownIt-Anchor" href="#31-改变元素内容"></a> 3.1 改变元素内容</h4>
<p>从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.innerText = <span class="string">'无法加粗'</span>;</span><br></pre></td></tr></table></figure>
<p>起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">element.innerHTML = <span class="string">'&lt;strong&gt;加粗&lt;/strong&gt;'</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>两种都可读写</li>
</ul>
<h4 id="32-样式属性操作"><a class="markdownIt-Anchor" href="#32-样式属性操作"></a> 3.2 样式属性操作</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1. element.style     行内样式操作</span><br><span class="line">2. element.className 类名样式操作</span><br></pre></td></tr></table></figure>
<ul>
<li>js 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor</li>
<li>js 修改 style 样式操作，产生的是行内样式，CSS 权重比较高</li>
</ul>
<p><strong>例：循环精灵图</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> lis = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; lis.length; i++) &#123;</span><br><span class="line">    <span class="comment">// 让索引号 乘以 44 就是每个li 的背景y坐标 index就是我们的y坐标</span></span><br><span class="line">    <span class="keyword">var</span> index = i * <span class="number">44</span>;</span><br><span class="line">    lis[i].style.backgroundPosition = <span class="string">'0 -'</span> + index + <span class="string">'px'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>例：通过类名修改样式</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;style&gt;</span><br><span class="line">    .change &#123;</span><br><span class="line">        color: #fff;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;script&gt; </span></span><br><span class="line"><span class="regexp">	var test = document.querySelector('div');</span></span><br><span class="line"><span class="regexp">	test.onclick = function() &#123;</span></span><br><span class="line"><span class="regexp">        /</span><span class="regexp">/ 让当前元素类名改为change</span></span><br><span class="line"><span class="regexp">		this.className = 'change';</span></span><br><span class="line"><span class="regexp">    &#125;</span></span><br><span class="line"><span class="regexp">&lt;/</span>script&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>如果样式修改较多，可以采取操作类名方式更改元素样式</li>
<li>className 会直接更改元素的类名，会覆盖原先的类名</li>
</ul>
<h4 id="33-排他思想"><a class="markdownIt-Anchor" href="#33-排他思想"></a> 3.3 排他思想</h4>
<p>如果有同一组元素，我们想要某一个元素实现某种样式， 需要用到循环的排他思想算法：</p>
<ol>
<li>所有元素全部清除样式（干掉其他人）</li>
<li>给当前元素设置样式 （留下我自己）</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">    <span class="keyword">var</span> btns = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'button'</span>);</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">    btns[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; btns.length; i++) &#123;</span><br><span class="line">            btns[i].style.backgroundColor = <span class="string">''</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">this</span>.style.backgroundColor = <span class="string">'pink'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="34-自定义属性值"><a class="markdownIt-Anchor" href="#34-自定义属性值"></a> 3.4 自定义属性值</h4>
<ol>
<li>获取属性值</li>
</ol>
<p>element.属性  获取属性值。</p>
<p>element.getAttribute(‘属性’);</p>
<p><strong>区别</strong></p>
<ul>
<li>
<p>element.属性  获取内置属性值（元素本身自带的属性）</p>
</li>
<li>
<p>element.getAttribute(‘属性’);  主要获得自定义的属性 （标准） 我们程序员自定义的属性</p>
</li>
</ul>
<ol start="2">
<li>
<p>设置属性值</p>
<p>element.setAttribute(‘属性’, ‘值’);</p>
</li>
<li>
<p>移除属性</p>
<p>element.removeAttribute(‘属性’);</p>
</li>
</ol>
<h4 id="35-h5自定义属性"><a class="markdownIt-Anchor" href="#35-h5自定义属性"></a> 3.5 H5自定义属性</h4>
<ol>
<li>
<p>设置H5自定义属性</p>
<p>H5规定自定义属性data-开头做为属性名并且赋值。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">比如 &lt;div data-index=<span class="string">"1"</span>&gt;&lt;<span class="regexp">/div&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li>
<p>获取H5自定义属性</p>
<p>兼容性获取  element.getAttribute(‘data-index’);</p>
<p>H5新增 element.dataset.index 或者 element.dataset[‘index’]  ie 11才开始支持</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 如果自定义属性里面又多个-链接的单词，获取的时候采取驼峰命名法</span></span><br><span class="line">div.dataset.listName;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="4-节点"><a class="markdownIt-Anchor" href="#4-节点"></a> 4. 节点</h3>
<h4 id="41-节点概述"><a class="markdownIt-Anchor" href="#41-节点概述"></a> 4.1 节点概述</h4>
<p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p>
<ul>
<li>
<p>元素节点  nodeType 为 1</p>
</li>
<li>
<p>属性节点 nodeType 为 2</p>
</li>
<li>
<p>文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）</p>
</li>
</ul>
<h4 id="42-节点层级"><a class="markdownIt-Anchor" href="#42-节点层级"></a> 4.2 节点层级</h4>
<p><strong>1. 父级节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.parentNode</span><br></pre></td></tr></table></figure>
<p>​	返回最近的一个父节点</p>
<p><strong>2. 子节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> parentNode.childNodes</span><br></pre></td></tr></table></figure>
<p>​	返回值里面包含了所有的子节点，包括元素节点，文本节点等。</p>
<p>​	如果只想要获得里面的元素节点，则需要专门处理。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> ul = <span class="built_in">document</span>. querySelector(‘ul’);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; ul.childNodes.length;i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ul.childNodes[i].nodeType == <span class="number">1</span>) &#123;    </span><br><span class="line">        <span class="built_in">console</span>.log(ul.childNodes[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> parentNode.children</span><br></pre></td></tr></table></figure>
<p>​	parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回	子元素节点，其余节点不返回</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span> parentNode.firstChild</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">4.</span> parentNode.lastChild</span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">5.</span> parentNode.firstElementChild</span><br></pre></td></tr></table></figure>
<p>​	firstElementChild  返回第一个子元素节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">6.</span> parentNode.lastElementChild</span><br></pre></td></tr></table></figure>
<p>​	lastElementChild 返回最后一个子元素节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">7.</span> parentNode.children[index];</span><br></pre></td></tr></table></figure>
<p><strong>3. 兄弟节点</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> node.nextSibling  </span><br><span class="line"><span class="number">2.</span> node.previousSibling</span><br></pre></td></tr></table></figure>
<p>​	包含所有的节点</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">3.</span> nextElementSibling</span><br><span class="line"><span class="number">4.</span> node.previousElementSibling</span><br></pre></td></tr></table></figure>
<p>​	返回元素节点</p>
<h4 id="43-创建节点"><a class="markdownIt-Anchor" href="#43-创建节点"></a> 4.3 创建节点</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.createElement(<span class="string">'tagName'</span>)</span><br></pre></td></tr></table></figure>
<h4 id="44-添加节点"><a class="markdownIt-Anchor" href="#44-添加节点"></a> 4.4 添加节点</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">1.</span> node.appendChild(child)</span><br></pre></td></tr></table></figure>
<p>​	node.appendChild() 方法将一个节点添加到指定父节点的子节点列表末尾</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="number">2.</span> node.insertBefore(child, 指定元素)</span><br></pre></td></tr></table></figure>
<p>​	node.insertBefore() 方法将一个节点添加到父节点的指定子节点前面</p>
<h4 id="45-删除节点"><a class="markdownIt-Anchor" href="#45-删除节点"></a> 4.5 删除节点</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.removeChild(child)</span><br></pre></td></tr></table></figure>
<p>​	node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点</p>
<h4 id="46-复制节点"><a class="markdownIt-Anchor" href="#46-复制节点"></a> 4.6 复制节点</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">node.cloneNode()</span><br></pre></td></tr></table></figure>
<p>​	node.cloneNode() 方法返回调用该方法的节点的一个副本</p>
<p><strong>注意</strong></p>
<ol>
<li>
<p>如果括号参数为空或者为 false ，则是浅拷贝，即只克隆复制节点本身，不克隆里面的子节点。</p>
</li>
<li>
<p>如果括号参数为 true ，则是深度拷贝，会复制节点本身以及里面所有的子节点。</p>
</li>
</ol>
<h4 id="47-三种动态创建元素区别"><a class="markdownIt-Anchor" href="#47-三种动态创建元素区别"></a> 4.7 三种动态创建元素区别</h4>
<ul>
<li>
<p>document.write()</p>
</li>
<li>
<p>element.innerHTML</p>
</li>
<li>
<p>document.createElement()</p>
</li>
</ul>
<p><strong>区别</strong></p>
<ol>
<li>
<p>document.write 是直接将内容写入页面的内容流，但是文档流执行完毕，则它**<font color="red">会导致页面全部重绘</font>**</p>
</li>
<li>
<p>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘</p>
</li>
<li>
<p>innerHTML 创建多个元素效率更高（不要拼接字符串，采取数组形式拼接），结构稍微复杂</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    array.push(<span class="string">'&lt;div style="width:100px; height:2px; border:1px solid blue;"&gt;&lt;/div&gt;'</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">document</span>.body.innerHTML = array.join(<span class="string">''</span>);</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>createElement() 创建多个元素效率稍低一点点，但是结构更清晰</p>
</li>
</ol>
<p>总结：不同浏览器下，innerHTML 效率要比 creatElement 高</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>4 CSS高级技巧</title>
    <url>/2021/07/19/%E5%89%8D%E7%AB%AF/4%20CSS%E9%AB%98%E7%BA%A7%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="css高级技巧"><a class="markdownIt-Anchor" href="#css高级技巧"></a> CSS高级技巧</h2>
<h3 id="1-精灵图"><a class="markdownIt-Anchor" href="#1-精灵图"></a> 1. 精灵图</h3>
<a id="more"></a>
<p>有效地减少服务器接收和发送请求的次数，提高页面的加载速度</p>
<h4 id="11-精灵图的使用"><a class="markdownIt-Anchor" href="#11-精灵图的使用"></a> 1.1 精灵图的使用</h4>
<ol>
<li>精灵技术主要针对于背景图片使用。就是把多个小背景图片整合到一张大图片中。</li>
<li>这个大图片也称为 sprites 精灵图</li>
<li>移动背景图片位置， 此时可以使用 background-position 。</li>
<li>移动的距离就是这个目标图片的 x 和 y 坐标。注意网页中的坐标有所不同</li>
<li>因为一般情况下都是往上往左移动，所以数值是负值。</li>
<li>使用精灵图的时候需要精确测量，每个小背景图片的大小和位置。</li>
</ol>
 <figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">60px</span>;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">100px</span> auto;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">url</span>(./images/sprites.png) no-repeat -<span class="number">182px</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-字体图标"><a class="markdownIt-Anchor" href="#2-字体图标"></a> 2. 字体图标</h3>
<p>字体图标使用场景： 主要用于显示网页中通用、常用的一些小图标</p>
<p>字体图标可以为前端工程师提供一种方便高效的图标使用方式，展示的是图标，本质属于字体。</p>
<h4 id="21-优点"><a class="markdownIt-Anchor" href="#21-优点"></a> 2.1 优点</h4>
<ul>
<li>
<p>轻量级</p>
</li>
<li>
<p>灵活性</p>
</li>
<li>
<p>兼容性</p>
</li>
</ul>
<h4 id="22-字体图标的引入"><a class="markdownIt-Anchor" href="#22-字体图标的引入"></a> 2.2 字体图标的引入</h4>
<p>通过css将字体图标引入（到阿里巴巴矢量图库上复制代码）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="keyword">@font-face</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"iconfont"</span>; <span class="comment">/* Project id 2682552 */</span></span><br><span class="line">  <span class="attribute">src</span>: <span class="built_in">url</span>(<span class="string">'http://at.alicdn.com/t/font_2682552_i74b4euo3zg.woff2?t=1626590070178'</span>) <span class="built_in">format</span>(<span class="string">'woff2'</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">'http://at.alicdn.com/t/font_2682552_i74b4euo3zg.woff?t=1626590070178'</span>) <span class="built_in">format</span>(<span class="string">'woff'</span>),</span><br><span class="line">       <span class="built_in">url</span>(<span class="string">'http://at.alicdn.com/t/font_2682552_i74b4euo3zg.ttf?t=1626590070178'</span>) <span class="built_in">format</span>(<span class="string">'truetype'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.iconfont</span> &#123;</span><br><span class="line">  <span class="attribute">font-family</span>: <span class="string">"iconfont"</span> <span class="meta">!important</span>;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">font-style</span>: normal;</span><br><span class="line">  <span class="attribute">-webkit-font-smoothing</span>: antialiased;</span><br><span class="line">  <span class="attribute">-moz-osx-font-smoothing</span>: grayscale;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.icon-sousuo_huaban1</span><span class="selector-pseudo">:before</span> &#123;</span><br><span class="line">  <span class="attribute">content</span>: <span class="string">"\e60d"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-css三角"><a class="markdownIt-Anchor" href="#3-css三角"></a> 3. CSS三角</h3>
<p>三边设置透明，一边有颜色</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">div</span> &#123;</span><br><span class="line"> <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line"> <span class="attribute">border</span>: <span class="number">50px</span> solid transparent;</span><br><span class="line"> <span class="attribute">border-left-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="31-案例"><a class="markdownIt-Anchor" href="#31-案例"></a> 3.1 案例</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.jd</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">120px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">249px</span>;</span><br><span class="line">    <span class="attribute">background-color</span>: pink;</span><br><span class="line">&#125;</span><br><span class="line">        </span><br><span class="line"><span class="selector-class">.jd</span> <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">right</span>: <span class="number">15px</span>;</span><br><span class="line">    <span class="attribute">top</span>: -<span class="number">10px</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">font-size</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">line-height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">5px</span> solid transparent;</span><br><span class="line">    <span class="attribute">border-bottom-color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-用户界面样式"><a class="markdownIt-Anchor" href="#4-用户界面样式"></a> 4. 用户界面样式</h3>
<h4 id="41-鼠标样式cursor"><a class="markdownIt-Anchor" href="#41-鼠标样式cursor"></a> 4.1 鼠标样式cursor</h4>
<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">cursor</span>: pointer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/LjC4XIKGqAR3QFV.png" alt="1571521805183.png" /></p>
<h4 id="42-轮廓线-outline"><a class="markdownIt-Anchor" href="#42-轮廓线-outline"></a> 4.2 轮廓线 outline</h4>
<p>给表单添加 outline: 0; 或者 outline: none; 样式之后，就可以去掉默认的蓝色边框。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span> &#123;</span><br><span class="line">    <span class="attribute">outline</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="43-防止拖拽文本域-resize"><a class="markdownIt-Anchor" href="#43-防止拖拽文本域-resize"></a> 4.3  防止拖拽文本域 resize</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">textarea</span>&#123; <span class="attribute">resize</span>: none;&#125;</span><br></pre></td></tr></table></figure>
<p>注：文本域尽量放到一行，不然首字会有空隙</p>
<h3 id="5-vertical-align"><a class="markdownIt-Anchor" href="#5-vertical-align"></a> 5. vertical-align</h3>
<p>经常用于设置图片或者表单(行内块元素）和文字垂直对齐。</p>
<p>用于设置一个元素的垂直对齐方式，但是它只针对于行内元素或者行内块元素有效。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">vertical-align : baseline | top | middle | bottom</span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/07/21/KXMGtqLyEDH5VNf.png" alt="1571522023413.png" /></p>
<img src="https://i.loli.net/2021/07/21/OqobtJjlnQGi63A.png" alt="1571522040645.png" style="zoom:80%;" />
<h4 id="51-图片和文字垂直居中"><a class="markdownIt-Anchor" href="#51-图片和文字垂直居中"></a> 5.1 图片和文字垂直居中</h4>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="attribute">vertical-align</span>: middle;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="52-解决图片底部默认空白缝隙问题"><a class="markdownIt-Anchor" href="#52-解决图片底部默认空白缝隙问题"></a> 5.2 解决图片底部默认空白缝隙问题</h4>
<p>图片底侧会有一个空白缝隙，原因是行内块元素会和文字的基线对齐。</p>
<p><strong>解决方法</strong></p>
<ol>
<li>给图片添加 vertical-align: middle | top| bottom（提倡使用的）</li>
<li>把图片转换为块级元素 display: block;</li>
</ol>
<h3 id="6-溢出的文字省略号显示"><a class="markdownIt-Anchor" href="#6-溢出的文字省略号显示"></a> 6. 溢出的文字省略号显示</h3>
<h4 id="1-单行文本溢出显示省略号"><a class="markdownIt-Anchor" href="#1-单行文本溢出显示省略号"></a> 1. 单行文本溢出显示省略号</h4>
<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*1. 先强制一行内显示文本*/</span></span><br><span class="line"> white-space: nowrap; （ 默认 normal 自动换行）</span><br><span class="line"> <span class="comment">/*2. 超出的部分隐藏*/</span></span><br><span class="line"> overflow: hidden;</span><br><span class="line"> <span class="comment">/*3. 文字用省略号替代超出的部分*/</span></span><br><span class="line"> text-overflow: ellipsis;</span><br></pre></td></tr></table></figure>
<h4 id="2-多行文本溢出显示省略号"><a class="markdownIt-Anchor" href="#2-多行文本溢出显示省略号"></a> 2. 多行文本溢出显示省略号</h4>
<p>多行文本溢出显示省略号，有较大兼容性问题， 适合于webkit浏览器或移动端（移动端大部分是webkit内核）</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">overflow</span>: <span class="selector-tag">hidden</span>;</span><br><span class="line"><span class="selector-tag">text-overflow</span>: <span class="selector-tag">ellipsis</span>;</span><br><span class="line"><span class="comment">/* 弹性伸缩盒子模型显示 */</span></span><br><span class="line"><span class="selector-tag">display</span>: <span class="selector-tag">-webkit-box</span>;</span><br><span class="line"><span class="comment">/* 限制在一个块元素显示的文本的行数 */</span></span><br><span class="line"><span class="selector-tag">-webkit-line-clamp</span>: 2;</span><br><span class="line"><span class="comment">/* 设置或检索伸缩盒对象的子元素的排列方式 */</span></span><br><span class="line"><span class="selector-tag">-webkit-box-orient</span>: <span class="selector-tag">vertical</span>;</span><br></pre></td></tr></table></figure>
<h3 id="7-常见布局技巧"><a class="markdownIt-Anchor" href="#7-常见布局技巧"></a> 7. 常见布局技巧</h3>
<h4 id="71-margin负值运用"><a class="markdownIt-Anchor" href="#71-margin负值运用"></a> 7.1 margin负值运用</h4>
<ol>
<li>让每个盒子margin 往左侧移动 -1px 正好压住相邻盒子边框</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">list-style</span>: none;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">1px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>鼠标经过某个盒子的时候，提高当前盒子的层级即可（如果没有有定位，则加相对定位（保留位置），如 果有定位，则加z-index）</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">ul</span> <span class="selector-tag">li</span><span class="selector-pseudo">:hover</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid blue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="72-文字围绕浮动元素"><a class="markdownIt-Anchor" href="#72-文字围绕浮动元素"></a> 7.2 文字围绕浮动元素</h4>
<p>利用浮动元素不会压住文字的 特性</p>
<h4 id="73-行内块巧妙运用"><a class="markdownIt-Anchor" href="#73-行内块巧妙运用"></a> 7.3 行内块巧妙运用</h4>
<p><strong>页码在页面中间显示</strong></p>
<ol>
<li>把这些链接盒子转换为行内块， 之后给父级指定 text-align:center;</li>
<li>利用行内块元素中间有缝隙，并且给父级添加 text-align:center; 行内块元素会水平会居中</li>
</ol>
<h4 id="74-css-三角强化"><a class="markdownIt-Anchor" href="#74-css-三角强化"></a> 7.4 CSS 三角强化</h4>
<p><strong>原理：</strong></p>
<p><img src="https://i.loli.net/2021/07/21/a4Hl6MDkuA72wVp.png" alt="1571523024087.png" /></p>
<p><strong>代码：</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="comment">/* 只保留右边的边框有颜色 */</span></span><br><span class="line">    <span class="attribute">border-color</span>: transparent red transparent transparent;</span><br><span class="line">    <span class="attribute">border-style</span>: solid;            </span><br><span class="line">    <span class="comment">/* 左边和下边的边框宽度设置为0，上边框调大 */</span></span><br><span class="line">    <span class="attribute">border-width</span>: <span class="number">100px</span> <span class="number">50px</span> <span class="number">0</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="741-示例"><a class="markdownIt-Anchor" href="#741-示例"></a> 7.4.1 示例</h4>
<img src="https://i.loli.net/2021/07/21/sgLRzUrI3M8mWVc.png" alt="1571548099631.png" style="zoom:80%;" />
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line"><span class="css">    <span class="selector-class">.price</span> &#123;</span></span><br><span class="line">        width: 160px;</span><br><span class="line">        height: 24px;</span><br><span class="line">        line-height: 24px;</span><br><span class="line">        border: 1px solid red;</span><br><span class="line">        margin: 100px auto;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.price</span> <span class="selector-class">.discount</span> &#123;</span></span><br><span class="line">        float: left;</span><br><span class="line">        position: relative;</span><br><span class="line">        width: 90px;</span><br><span class="line">        height: 100%;</span><br><span class="line">        background-color: red;</span><br><span class="line">        text-align: center;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line">        font-weight: 700;</span><br><span class="line">        margin-right: 8px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.price</span> <span class="selector-class">.discount</span> <span class="selector-tag">i</span> &#123;</span></span><br><span class="line">        position: absolute;</span><br><span class="line">        right: 0;</span><br><span class="line">        top: 0;</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line"><span class="css">        <span class="selector-tag">border-color</span>: <span class="selector-tag">transparent</span> <span class="selector-id">#fff</span> <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span>;</span></span><br><span class="line">        border-style: solid;</span><br><span class="line">        border-width: 24px 12px 0 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.price</span> <span class="selector-class">.origin</span> &#123;</span></span><br><span class="line">        font-size: 12px;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#ccc</span>;</span></span><br><span class="line">        text-decoration: line-through;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"price"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"discount"</span>&gt;</span></span><br><span class="line">            ￥1650 <span class="tag">&lt;<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">span</span> <span class="attr">class</span>=<span class="string">"origin"</span>&gt;</span>￥5650<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="8-css-初始化"><a class="markdownIt-Anchor" href="#8-css-初始化"></a> 8. CSS 初始化</h3>
<p>不同浏览器对有些标签的默认值是不同的，为了消除不同浏览器对HTML文本呈现的差异，照顾浏览器的兼 容，我们需要对CSS 初始化</p>
<p><strong>例</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 把所有内外边距清零 */</span></span><br><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">0</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 去掉li的小圆点 */</span></span><br><span class="line"><span class="selector-tag">li</span> &#123;</span><br><span class="line">    <span class="attribute">list-style</span>: none</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">img</span> &#123;</span><br><span class="line">    <span class="comment">/* 取消图片底侧有空白缝隙的问题 */</span></span><br><span class="line">    <span class="attribute">vertical-align</span>: middle</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Unicode编码字体</strong></p>
<p>把中文字体的名称用相应的Unicode编码来代替，这样就可以有效的避免浏览器解释CSS代码时候出现乱码的问题。</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">font-family: ' \9ED1\4F53', '\5B8B\4F53', '\5FAE\8F6F\96C5\9ED1'</span><br></pre></td></tr></table></figure>
<ul>
<li>黑体 \9ED1\4F53</li>
<li>宋体 \5B8B\4F53</li>
<li>微软雅黑 \5FAE\8F6F\96C5\9ED1</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>4 js 事件高级</title>
    <url>/2021/08/15/%E5%89%8D%E7%AB%AF/4%20js%20%E4%BA%8B%E4%BB%B6%E9%AB%98%E7%BA%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="js-事件高级"><a class="markdownIt-Anchor" href="#js-事件高级"></a> js 事件高级</h2>
<h3 id="1-注册事件"><a class="markdownIt-Anchor" href="#1-注册事件"></a> 1. 注册事件</h3>
<a id="more"></a>
<p>注册事件有两种方式：传统方式和方法监听注册方式</p>
<h4 id="11-传统注册方式"><a class="markdownIt-Anchor" href="#11-传统注册方式"></a> 1.1 传统注册方式</h4>
<ul>
<li>
<p>利用 on 开头的事件 onclick</p>
</li>
<li>
<p>&lt;button onclick=“alert(‘hi~’)”&gt;&lt;/button&gt;</p>
</li>
<li>
<p>btn.onclick = function() {}</p>
</li>
<li>
<p>特点： 注册事件的<strong>唯一性</strong></p>
</li>
<li>
<p>同一个元素同一个事件只能设置一个处理函数，<strong>最后注册的处理函数将会覆盖前面注册的处理函数</strong></p>
</li>
</ul>
<h4 id="12-addeventlistener事件监听方式"><a class="markdownIt-Anchor" href="#12-addeventlistener事件监听方式"></a> 1.2 addEventListener事件监听方式</h4>
<ul>
<li>
<p>addEventListener() 它是一个方法</p>
</li>
<li>
<p>特点：<strong>同一个元素同一个事件可以注册多个监听器</strong>，按注册顺序依次执行</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventTarget.addEventListener(type, listener[, useCapture])</span><br></pre></td></tr></table></figure>
<p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。</p>
<p>该方法接收三个参数：</p>
<ul>
<li>
<p>type：事件类型是字符串，比如 click 、mouseover ，注意这里不要带 on</p>
</li>
<li>
<p>listener：事件处理函数，事件发生时，会调用该监听函数</p>
</li>
<li>
<p>useCapture：可选参数，是一个布尔值，默认是 false。学完 DOM 事件流后，我们再进一步学习</p>
</li>
</ul>
<h4 id="13-attachevent事件监听方式"><a class="markdownIt-Anchor" href="#13-attachevent事件监听方式"></a> 1.3 attachEvent事件监听方式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventTarget.attachEvent(eventNameWithOn, callback)</span><br></pre></td></tr></table></figure>
<p>eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触发指定的事件时，指定的回调函数就会被执行。</p>
<p>该方法接收两个参数：</p>
<ul>
<li>
<p>eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on</p>
</li>
<li>
<p>callback： 事件处理函数，当目标触发事件时回调函数被调用</p>
</li>
</ul>
<h3 id="2-删除事件"><a class="markdownIt-Anchor" href="#2-删除事件"></a> 2. 删除事件</h3>
<h4 id="21-传统注册方式"><a class="markdownIt-Anchor" href="#21-传统注册方式"></a> 2.1 传统注册方式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventTarget.onclick = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<h4 id="22-方法监听注册方式"><a class="markdownIt-Anchor" href="#22-方法监听注册方式"></a> 2.2 方法监听注册方式</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventTarget.removeEventListener(type, listener[, useCapture]);</span><br><span class="line">eventTarget.detachEvent(eventNameWithOn, callback);</span><br></pre></td></tr></table></figure>
<h3 id="3-dom事件流"><a class="markdownIt-Anchor" href="#3-dom事件流"></a> 3. DOM事件流</h3>
<p>事件流描述的是从页面中接收事件的顺序。</p>
<p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流</p>
<p>DOM 事件流分为3个阶段：</p>
<ol>
<li>
<p>捕获阶段</p>
</li>
<li>
<p>当前目标阶段</p>
</li>
<li>
<p>冒泡阶段</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/08/29/sY4qeXgctF2zxSP.png" alt="1.png" /></p>
<p><strong>注意</strong></p>
<ol>
<li>
<p>JS 代码中只能执行捕获或者冒泡其中的一个阶段。</p>
</li>
<li>
<p>onclick 和 attachEvent 只能得到冒泡阶段。</p>
</li>
<li>
<p>addEventListener(type, listener[, useCapture])第三个参数如果是 true，表示在事件捕获阶段调用事件处理程序；如果是 false（不写默认就是false），表示在事件冒泡阶段调用事件处理程序。</p>
</li>
<li>
<p>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</p>
</li>
<li>
<p>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</p>
</li>
</ol>
<h3 id="4-事件对象"><a class="markdownIt-Anchor" href="#4-事件对象"></a> 4. 事件对象</h3>
<h4 id="41-事件对象"><a class="markdownIt-Anchor" href="#41-事件对象"></a> 4.1 事件对象</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">eventTarget.onclick = <span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这个 event 是个形参，系统帮我们设定为事件对象，不需要传递实参过去。</p>
<p>当我们注册事件时， event 对象就会被系统自动创建，并依次传递给事件监听器（事件处理函数）。</p>
<p>官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。</p>
<p>简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象 event，它有很多属性和方法。</p>
<h4 id="42-事件对象的常见属性和方法"><a class="markdownIt-Anchor" href="#42-事件对象的常见属性和方法"></a> 4.2 事件对象的常见属性和方法</h4>
<p><strong>e.target和this的区别</strong></p>
<p>this 是事件绑定的元素， 这个函数的调用者（绑定这个事件的元素）</p>
<p>e.target 是事件触发的元素。</p>
<p>例：绑ul点li，this指向ul，target指向li</p>
<p><img src="https://i.loli.net/2021/08/29/pmYqvsZn71OkexM.png" alt="2.png" /></p>
<h3 id="5-阻止事件冒泡"><a class="markdownIt-Anchor" href="#5-阻止事件冒泡"></a> 5. 阻止事件冒泡</h3>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">e.stopPropagation()</span><br></pre></td></tr></table></figure>
<h3 id="6-事件委托"><a class="markdownIt-Anchor" href="#6-事件委托"></a> 6. 事件委托</h3>
<p><strong>事件委托的原理</strong></p>
<p><strong><font color="red">不是每个子节点单独设置事件监听器，而是事件监听器设置在其父节点上，然后利用冒泡原理影响设置每个子节点。</font></strong></p>
<p>例：给 ul 注册点击事件，然后利用事件对象的 target 来找到当前点击的 li，因为点击 li，事件会冒泡到 ul 上， ul 有注册事件，就会触发事件监听器。</p>
<p><strong>事件委托的作用</strong></p>
<p>我们只操作了一次 DOM ，提高了程序的性能。</p>
<h3 id="7-常用的鼠标事件"><a class="markdownIt-Anchor" href="#7-常用的鼠标事件"></a> 7. 常用的鼠标事件</h3>
<h4 id="71-常用的鼠标事件"><a class="markdownIt-Anchor" href="#71-常用的鼠标事件"></a> 7.1 常用的鼠标事件</h4>
<p><img src="https://i.loli.net/2021/08/29/wSmFjEDdh7otIOg.png" alt="3.png" /></p>
<p><strong>1. 禁止鼠标右键菜单</strong></p>
<p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'contextmenu'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">	e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p><strong>2. 禁止鼠标选中</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'selectstart'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h4 id="72-鼠标事件对象"><a class="markdownIt-Anchor" href="#72-鼠标事件对象"></a> 7.2 鼠标事件对象</h4>
<p><img src="https://i.loli.net/2021/08/29/tDrvaywFBu2Vcb8.png" alt="4.png" /></p>
<p><strong>例：跟随鼠标移动</strong></p>
<p>① 鼠标不断的移动，使用鼠标移动事件： mousemove</p>
<p>② 在页面中移动，给document注册事件</p>
<p>③ 图片要移动距离，而且不占位置，我们使用绝对定位即可</p>
<p>④ 核心原理： 每次鼠标移动，我们都会获得最新的鼠标坐标， 把这个x和y坐标做为图片的top和left 值就可以移动图片</p>
<h3 id="8-常用的键盘事件"><a class="markdownIt-Anchor" href="#8-常用的键盘事件"></a> 8. 常用的键盘事件</h3>
<h4 id="81-常用键盘事件"><a class="markdownIt-Anchor" href="#81-常用键盘事件"></a> 8.1 常用键盘事件</h4>
<p><img src="https://i.loli.net/2021/08/29/tsY8zfcICESnNBk.png" alt="5.png" /></p>
<p>三个事件的执行顺序是： keydown → keypress → keyup</p>
<h4 id="82-键盘事件对象"><a class="markdownIt-Anchor" href="#82-键盘事件对象"></a> 8.2 键盘事件对象</h4>
<p><img src="https://i.loli.net/2021/08/29/mZIKtMUwDyQ9dsr.png" alt="6.png" /></p>
<p>onkeydown 和 onkeyup 不区分字母大小写，onkeypress 区分字母大小写。</p>
<p><strong>例</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line">    * &#123;</span><br><span class="line">        margin: 0;</span><br><span class="line">        padding: 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.search</span> &#123;</span></span><br><span class="line">        position: relative;</span><br><span class="line">        width: 178px;</span><br><span class="line">        margin: 100px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.con</span> &#123;</span></span><br><span class="line">        display: none;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: -40px;</span><br><span class="line">        width: 171px;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.2</span>);</span></span><br><span class="line"><span class="css">        <span class="selector-tag">box-shadow</span>: 0 2<span class="selector-tag">px</span> 4<span class="selector-tag">px</span> <span class="selector-tag">rgba</span>(0, 0, 0, <span class="selector-class">.2</span>);</span></span><br><span class="line">        padding: 5px 0;</span><br><span class="line">        font-size: 18px;</span><br><span class="line">        line-height: 20px;</span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#333</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.con</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">        content: '';</span><br><span class="line">        width: 0;</span><br><span class="line">        height: 0;</span><br><span class="line">        position: absolute;</span><br><span class="line">        top: 28px;</span><br><span class="line">        left: 18px;</span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 8<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">        border-style: solid dashed dashed;</span><br><span class="line"><span class="css">        <span class="selector-tag">border-color</span>: <span class="selector-id">#fff</span> <span class="selector-tag">transparent</span> <span class="selector-tag">transparent</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"search"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"con"</span>&gt;</span>123<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">placeholder</span>=<span class="string">"请输入您的快递单号"</span> <span class="attr">class</span>=<span class="string">"jd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 快递单号输入内容时， 上面的大号字体盒子（con）显示(这里面的字号更大）</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 表单检测用户输入： 给表单添加键盘事件</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 同时把快递单号里面的值（value）获取过来赋值给 con盒子（innerText）做为内容</span></span></span><br><span class="line"><span class="actionscript">        <span class="comment">// 如果快递单号里面内容为空，则隐藏大号字体盒子(con)盒子</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> con = <span class="built_in">document</span>.querySelector(<span class="string">'.con'</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> jd_input = <span class="built_in">document</span>.querySelector(<span class="string">'.jd'</span>);</span></span><br><span class="line"><span class="actionscript">        jd_input.addEventListener(<span class="string">'keyup'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                <span class="comment">// console.log('输入内容啦');</span></span></span><br><span class="line"><span class="actionscript">                <span class="keyword">if</span> (<span class="keyword">this</span>.value == <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                    con.style.display = <span class="string">'none'</span>;</span></span><br><span class="line"><span class="actionscript">                &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="actionscript">                    con.style.display = <span class="string">'block'</span>;</span></span><br><span class="line"><span class="actionscript">                    con.innerText = <span class="keyword">this</span>.value;</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">            <span class="comment">// 当我们失去焦点，就隐藏这个con盒子</span></span></span><br><span class="line"><span class="actionscript">        jd_input.addEventListener(<span class="string">'blur'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">                con.style.display = <span class="string">'none'</span>;</span></span><br><span class="line">            &#125;)</span><br><span class="line"><span class="actionscript">            <span class="comment">// 当我们获得焦点，就显示这个con盒子</span></span></span><br><span class="line"><span class="actionscript">        jd_input.addEventListener(<span class="string">'focus'</span>, <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">            <span class="keyword">if</span> (<span class="keyword">this</span>.value !== <span class="string">''</span>) &#123;</span></span><br><span class="line"><span class="actionscript">                con.style.display = <span class="string">'block'</span>;</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>5 HTML5和CSS3新特性</title>
    <url>/2021/07/20/%E5%89%8D%E7%AB%AF/5%20HTML5%E5%92%8CCSS3%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="html5和css3新特性"><a class="markdownIt-Anchor" href="#html5和css3新特性"></a> HTML5和CSS3新特性</h2>
<h3 id="1-html5的新特性"><a class="markdownIt-Anchor" href="#1-html5的新特性"></a> 1. HTML5的新特性</h3>
<a id="more"></a>
<h4 id="11-html5新增的语义化标签"><a class="markdownIt-Anchor" href="#11-html5新增的语义化标签"></a> 1.1 HTML5新增的语义化标签</h4>
<ul>
<li>header：头部标签</li>
<li>nav：导航标签</li>
<li>article：内容标签</li>
<li>section：定义文档某个区域</li>
<li>aside：侧边栏标签</li>
<li>footer：尾部标签</li>
</ul>
<img src="https://i.loli.net/2021/07/21/SmM4zH56teo8hFx.png" alt="语义化标签.png" style="zoom:80%;" />
<h4 id="12-html5-新增的多媒体标签"><a class="markdownIt-Anchor" href="#12-html5-新增的多媒体标签"></a> 1.2 HTML5 新增的多媒体标签</h4>
<ul>
<li>
<p>&lt;audio&gt;：音频</p>
</li>
<li>
<p>&lt;video&gt;：视频</p>
</li>
</ul>
<h5 id="121-视频"><a class="markdownIt-Anchor" href="#121-视频"></a> 1.2.1 视频</h5>
<img src="https://i.loli.net/2021/07/21/uBnWdxFNgoTLv49.png" alt="video支持格式.png" style="zoom:80%;" />
<p><strong>常用属性</strong></p>
<p><img src="https://i.loli.net/2021/07/21/mWlzqeAB3FCNari.png" alt="video常用属性.png" /></p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">"文件地址"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 兼容性写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">controls</span>=<span class="string">"controls"</span> <span class="attr">width</span>=<span class="string">"300"</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"move.ogg"</span> <span class="attr">type</span>=<span class="string">"video/ogg"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"move.mp4"</span> <span class="attr">type</span>=<span class="string">"video/mp4"</span> &gt;</span></span><br><span class="line">	您的浏览器暂不支持 <span class="tag">&lt;<span class="name">video</span>&gt;</span> 标签播放视频</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">video</span> &gt;</span></span><br></pre></td></tr></table></figure>
<h5 id="122-音频"><a class="markdownIt-Anchor" href="#122-音频"></a> 1.2.2 音频</h5>
<img src="https://i.loli.net/2021/07/21/mNBvePubMaXr3hI.png" alt="audio支持格式.png" style="zoom:80%;" />
<p><strong>常用属性</strong></p>
<p><img src="https://i.loli.net/2021/07/21/7k29OAvJ5mQf3hC.png" alt="audio常用属性.png" /></p>
<p><strong>语法</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">"文件地址"</span> <span class="attr">controls</span>=<span class="string">"controls"</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 兼容性写法 --&gt;</span></span><br><span class="line"><span class="tag">&lt; <span class="attr">audio</span> <span class="attr">controls</span>=<span class="string">"controls"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"happy.mp3"</span> <span class="attr">type</span>=<span class="string">"audio/mpeg"</span> &gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">source</span> <span class="attr">src</span>=<span class="string">"happy.ogg"</span> <span class="attr">type</span>=<span class="string">"audio/ogg"</span> &gt;</span></span><br><span class="line">	您的浏览器暂不支持 <span class="tag">&lt;<span class="name">audio</span>&gt;</span> 标签。</span><br><span class="line"><span class="tag">&lt;/ <span class="attr">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="13-html5-新增的-input-类型"><a class="markdownIt-Anchor" href="#13-html5-新增的-input-类型"></a> 1.3 HTML5 新增的 input 类型</h4>
<p>验证的时候必须添加form表单域</p>
<p><img src="https://i.loli.net/2021/07/21/FvgxbzMHa1IAruj.png" alt="新增input表单.png" /></p>
<h4 id="14-html5-新增的表单属性"><a class="markdownIt-Anchor" href="#14-html5-新增的表单属性"></a> 1.4 HTML5 新增的表单属性</h4>
<p><img src="https://i.loli.net/2021/07/21/FV1mzHgLOufabSi.png" alt="image-20210718201124525.png" /></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 可以通过以下设置方式修改placeholder里面的字体颜色。 */</span></span><br><span class="line"><span class="selector-tag">input</span><span class="selector-pseudo">::placeholder</span> &#123;</span><br><span class="line">	<span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-css3的新特性"><a class="markdownIt-Anchor" href="#2-css3的新特性"></a> 2. CSS3的新特性</h3>
<ul>
<li>属性选择器</li>
<li>结构伪类选择器</li>
<li>伪元素选择器</li>
</ul>
<h4 id="21-属性选择器"><a class="markdownIt-Anchor" href="#21-属性选择器"></a> 2.1 属性选择器</h4>
<p><img src="https://i.loli.net/2021/07/21/drmwtCzW8vnOaF9.png" alt="属性选择器.png" /></p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">input</span><span class="selector-attr">[type=<span class="string">"text"</span>]</span> &#123;</span><br><span class="line">    <span class="attribute">color</span>: pink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong></p>
<p>类选择器、属性选择器、伪类选择器，<strong>权重为 10</strong>。</p>
<h4 id="22-结构伪类选择器"><a class="markdownIt-Anchor" href="#22-结构伪类选择器"></a> 2.2 结构伪类选择器</h4>
<p>结构伪类选择器主要根据文档结构来选择器元素， 常用于根据父级选择器里面的子元</p>
<p><img src="https://i.loli.net/2021/07/21/WxrlQdfcGuwCTv8.png" alt="结构伪类选择器-01.png" /></p>
<p><strong>nth-child(n)</strong></p>
<p>nth-child（n） 选择某个父元素的一个或多个特定的子元素（重点）</p>
<ul>
<li>n 可以是数字，关键字和公式</li>
<li>n 如果是数字，就是选择第 n 个子元素， 里面数字从1开始…</li>
<li>n 可以是关键字：even 偶数，odd 奇数</li>
<li>n 可以是公式：常见的公式如下 ( 如果n是公式，则从0开始计算，但是第 0 个元素或者超出了元素的个数会被忽略）</li>
</ul>
<p><img src="https://i.loli.net/2021/07/21/JfUacM297QKSrW6.png" alt="nth-child公式.png" /></p>
<p><strong>区别</strong></p>
<ol>
<li><strong>nth-child</strong>：对父元素里面所有孩子排序选择（序号是固定的） 先找到第n个孩子，然后看看是否和E匹配</li>
<li><strong>nth-of-type</strong>：对父元素里面指定子元素进行排序选择。 先去匹配E ，然后再根据E 找第n个孩子</li>
</ol>
<h4 id="23-伪元素选择器"><a class="markdownIt-Anchor" href="#23-伪元素选择器"></a> 2.3 伪元素选择器</h4>
<p>伪元素选择器可以帮助我们利用CSS创建新标签元素，而不需要HTML标签，从而简化HTML结构。</p>
<p><img src="https://i.loli.net/2021/07/21/Ca5LdDnzmJYUTZv.png" alt="伪元素.png" /></p>
<ul>
<li>before 和 after 创建一个元素，但是属于行内元素</li>
<li>新创建的这个元素在文档树中是找不到的，所以我们称为伪元素</li>
<li>语法： element::before {}</li>
<li><strong>before 和 after 必须有 content 属性</strong></li>
<li>before 在父元素内容的前面创建元素，after 在父元素内容的后面插入元素</li>
<li>伪元素选择器和标签选择器一样，<strong>权重为 1</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 权重是2 */</span></span><br><span class="line"><span class="selector-tag">div</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>使用场景</strong></p>
<ul>
<li>
<p>可以用来配合字体图标</p>
</li>
<li>
<p>可以用来做遮罩层</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="built_in">rbga</span>(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, .<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.box</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li>
<p>清除浮动</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.clearfix</span><span class="selector-pseudo">:after</span> &#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">""</span>;</span><br><span class="line">    <span class="attribute">display</span>: block;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">clear</span>: both;</span><br><span class="line">    <span class="attribute">visibility</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="24-css3-盒子模型"><a class="markdownIt-Anchor" href="#24-css3-盒子模型"></a> 2.4 CSS3 盒子模型</h4>
<p>CSS3 中可以通过 <strong>box-sizing</strong> 来指定盒模型，有2个值：即可指定为 <strong>content-box</strong>、<strong>border-box</strong>，这样我们 计算盒子大小的方式就发生了改变。</p>
<p>可以分成两种情况：</p>
<ol>
<li>box-sizing: content-box 盒子大小为 width + padding + border （以前默认的）</li>
<li>box-sizing: border-box 盒子大小为 width</li>
</ol>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">* &#123;</span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="25-css3-其他特性"><a class="markdownIt-Anchor" href="#25-css3-其他特性"></a> 2.5 CSS3 其他特性</h4>
<h5 id="251-css3滤镜filter"><a class="markdownIt-Anchor" href="#251-css3滤镜filter"></a> 2.5.1 CSS3滤镜filter：</h5>
<p>filter CSS属性将模糊或颜色偏移等图形效果应用于元素。</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* filter: 函数(); */</span> </span><br><span class="line"><span class="selector-tag">filter</span>: <span class="selector-tag">blur</span>(5<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
<h5 id="252-css3-calc函数"><a class="markdownIt-Anchor" href="#252-css3-calc函数"></a> 2.5.2 CSS3 calc函数：</h5>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">width</span>: <span class="selector-tag">calc</span>(100% <span class="selector-tag">-</span> 80<span class="selector-tag">px</span>);</span><br></pre></td></tr></table></figure>
<p>括号里面可以使用 + - * / 来进行计算。</p>
<h4 id="26-css3-过渡"><a class="markdownIt-Anchor" href="#26-css3-过渡"></a> 2.6 CSS3 过渡</h4>
<p>过渡动画： 是从一个状态渐渐的过渡到另外一个状态，经常和 :hover 一起搭配使用</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: 要过渡的属性 花费时间 运动曲线 何时开始;</span><br></pre></td></tr></table></figure>
<ol>
<li>属性 ： 想要变化的 css 属性， 宽度高度 背景颜色 内外边距都可以 。如果想要所有的属性都 变化过渡， 写一个all 就可以。</li>
<li>花费时间： 单位是 秒**（必须写单位）** 比如 0.5s</li>
<li>运动曲线： 默认是 ease <strong>（可以省略）</strong></li>
<li>何时开始 ：单位是 秒**（必须写单位）**可以设置延迟触发时间 默认是 0s <strong>（可以省略）</strong></li>
</ol>
<p>多个属性用 , 进行分割</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">width</span> 1<span class="selector-tag">s</span> <span class="selector-tag">ease</span> 1<span class="selector-tag">s</span>, <span class="selector-tag">height</span> 1<span class="selector-tag">s</span> <span class="selector-tag">ease</span> 1<span class="selector-tag">s</span>;</span><br><span class="line"><span class="selector-tag">transition</span>: <span class="selector-tag">all</span> 1<span class="selector-tag">s</span>;</span><br></pre></td></tr></table></figure>
<h5 id="261-案例"><a class="markdownIt-Anchor" href="#261-案例"></a> 2.6.1 案例</h5>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">lang</span>=<span class="string">"en"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"X-UA-Compatible"</span> <span class="attr">content</span>=<span class="string">"ie=edge"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.header-logo</span> &#123;</span></span><br><span class="line">            position: relative;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* 设置a标签的样式 */</span></span></span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.logo</span> &#123;</span></span><br><span class="line">            display: block;</span><br><span class="line">            width: 55px;</span><br><span class="line">            height: 55px;</span><br><span class="line">            overflow: hidden;</span><br><span class="line"><span class="css">            <span class="selector-tag">background-color</span>: <span class="selector-id">#ff6700</span>;</span></span><br><span class="line">            text-align: left;</span><br><span class="line">            text-indent: -9999em;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* mi logo的样式 */</span></span></span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.logo</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line"><span class="css">            <span class="comment">/* 定位 */</span></span></span><br><span class="line">            position: absolute;</span><br><span class="line"><span class="css">            <span class="comment">/* 伪元素必须要设置content属性 */</span></span></span><br><span class="line">            content: '';</span><br><span class="line"><span class="css">            <span class="comment">/* 左偏移 */</span></span></span><br><span class="line">            left: 0;</span><br><span class="line"><span class="css">            <span class="comment">/* 上偏移 */</span></span></span><br><span class="line">            top: 0;</span><br><span class="line">            width: 55px;</span><br><span class="line">            height: 55px;</span><br><span class="line"><span class="css">            <span class="comment">/* 设置过渡 */</span></span></span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.3s</span>;</span></span><br><span class="line"><span class="css">            <span class="comment">/* 背景图片 */</span></span></span><br><span class="line">            background: url(./images/mi-logo.png) no-repeat center center;</span><br><span class="line"><span class="css">            <span class="comment">/* 透明度 */</span></span></span><br><span class="line">            opacity: 1;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* mi home 的样式 */</span></span></span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.logo</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            position: absolute;</span><br><span class="line">            content: '';</span><br><span class="line">            left: 0;</span><br><span class="line">            top: 0;</span><br><span class="line">            width: 55px;</span><br><span class="line">            height: 55px;</span><br><span class="line"><span class="css">            <span class="selector-tag">transition</span>: <span class="selector-tag">all</span> <span class="selector-class">.3s</span>;</span></span><br><span class="line">            background: url(./images/mi-home.png) no-repeat center center;</span><br><span class="line">            margin-left: -55px;</span><br><span class="line">            opacity: 0;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* 鼠标移入 让mi logo 往右侧进行滑动 */</span></span></span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.logo</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::before</span> &#123;</span></span><br><span class="line">            opacity: 0;</span><br><span class="line">            margin-left: 55px;</span><br><span class="line">        &#125;</span><br><span class="line"><span class="css">        <span class="comment">/* 鼠标移入 让mi home 回到盒子中间 */</span></span></span><br><span class="line">        </span><br><span class="line"><span class="css">        <span class="selector-class">.logo</span><span class="selector-pseudo">:hover</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line">            opacity: 1;</span><br><span class="line">            margin-left: 0;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"header-logo"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">""</span> <span class="attr">class</span>=<span class="string">"logo"</span> <span class="attr">title</span>=<span class="string">"小米官网"</span>&gt;</span>小米官网<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>css</tag>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title>5 js BOM</title>
    <url>/2021/08/22/%E5%89%8D%E7%AB%AF/5%20js%20BOM/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="js-bom"><a class="markdownIt-Anchor" href="#js-bom"></a> js BOM</h2>
<h3 id="1-bom概述"><a class="markdownIt-Anchor" href="#1-bom概述"></a> 1. BOM概述</h3>
<a id="more"></a>
<h4 id="11-什么是bom"><a class="markdownIt-Anchor" href="#11-什么是bom"></a> 1.1 什么是BOM</h4>
<p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p>
<p><strong>DOM</strong></p>
<ul>
<li>
<p>文档对象模型</p>
</li>
<li>
<p>DOM 就是把「文档」当做一个「对象」来看待</p>
</li>
<li>
<p>DOM 的顶级对象是 document</p>
</li>
<li>
<p>DOM 主要学习的是操作页面元素</p>
</li>
<li>
<p>DOM 是 W3C 标准规范</p>
</li>
</ul>
<p><strong>BOM</strong></p>
<ul>
<li>
<p>浏览器对象模型</p>
</li>
<li>
<p>把「浏览器」当做一个「对象」来看待</p>
</li>
<li>
<p>BOM 的顶级对象是 window</p>
</li>
<li>
<p>BOM 学习的是浏览器窗口交互的一些对象</p>
</li>
<li>
<p>BOM 是浏览器厂商在各自浏览器上定义的，兼容性较差</p>
</li>
</ul>
<h4 id="12-bom的构成"><a class="markdownIt-Anchor" href="#12-bom的构成"></a> 1.2 BOM的构成</h4>
<p><img src="https://i.loli.net/2021/08/29/sm7kTpJMAP4LZCg.png" alt="1.png" /></p>
<h3 id="2-window-对象的常见事件"><a class="markdownIt-Anchor" href="#2-window-对象的常见事件"></a> 2. window 对象的常见事件</h3>
<h4 id="21-窗口加载事件"><a class="markdownIt-Anchor" href="#21-窗口加载事件"></a> 2.1 窗口加载事件</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">或者 </span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"load"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等), 就调用的处理函数。</p>
<p><strong>注意</strong></p>
<ol>
<li>
<p>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕，再去执行处理函数。</p>
</li>
<li>
<p>window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个 window.onload 为准。</p>
</li>
<li>
<p>如果使用 addEventListener 则没有限制</p>
</li>
</ol>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'DOMContentLoaded'</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure>
<p>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。</p>
<h4 id="22-调整窗口大小事件"><a class="markdownIt-Anchor" href="#22-调整窗口大小事件"></a> 2.2 调整窗口大小事件</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.onresize = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">window</span>.addEventListener(<span class="string">"resize"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;);</span><br></pre></td></tr></table></figure>
<p>window.onresize 是调整窗口大小加载事件, 当触发时就调用的处理函数。</p>
<p><strong>注意：</strong></p>
<ol>
<li>
<p>只要窗口大小发生像素变化，就会触发这个事件。</p>
</li>
<li>
<p>我们经常利用这个事件完成响应式布局。 window.innerWidth 当前屏幕的宽度</p>
</li>
</ol>
<h3 id="3-定时器"><a class="markdownIt-Anchor" href="#3-定时器"></a> 3. 定时器</h3>
<h4 id="31-settimeout"><a class="markdownIt-Anchor" href="#31-settimeout"></a> 3.1 setTimeout</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.setTimeout(调用函数, [延迟的毫秒数]);</span><br></pre></td></tr></table></figure>
<p>setTimeout() 方法用于设置一个定时器，该定时器在定时器到期后执行调用函数。</p>
<p><strong>注意</strong></p>
<ol>
<li>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</li>
</ol>
<h4 id="32-cleartimeout"><a class="markdownIt-Anchor" href="#32-cleartimeout"></a> 3.2 clearTimeout</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.clearTimeout(timeoutID)</span><br></pre></td></tr></table></figure>
<p>clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。</p>
<h4 id="33-setinterval"><a class="markdownIt-Anchor" href="#33-setinterval"></a> 3.3 setInterval</h4>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">window</span>.setInterval(回调函数, [间隔的毫秒数]);</span><br></pre></td></tr></table></figure>
<p>setInterval() 方法重复调用一个函数，每隔这个时间，就去调用一次回调函数。</p>
<h4 id="34-clearinterval"><a class="markdownIt-Anchor" href="#34-clearinterval"></a> 3.4 clearInterval</h4>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.clearInterval(intervalID);</span><br></pre></td></tr></table></figure>
<p>clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。</p>
<p><strong>例：发送短信</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> btn = <span class="built_in">document</span>.querySelector(<span class="string">'.btn1'</span>);</span><br><span class="line">btn.disabled = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">var</span> time = <span class="number">60</span>;</span><br><span class="line"><span class="keyword">var</span> timer = setInterval(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (time == <span class="number">0</span>) &#123;</span><br><span class="line">        clearInterval(timer);</span><br><span class="line">        btn.disabled = <span class="literal">false</span>;</span><br><span class="line">        btn.innerHTML = <span class="string">'获取验证码'</span>;</span><br><span class="line">        time = <span class="number">60</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        btn.innerHTML = time + <span class="string">'s'</span>;</span><br><span class="line">        time--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<h3 id="4-js-执行机制"><a class="markdownIt-Anchor" href="#4-js-执行机制"></a> 4. JS 执行机制</h3>
<h4 id="41-同步任务"><a class="markdownIt-Anchor" href="#41-同步任务"></a> 4.1 同步任务</h4>
<p>同步任务都在主线程上执行，形成一个执行栈。</p>
<h4 id="42-异步任务"><a class="markdownIt-Anchor" href="#42-异步任务"></a> 4.2 异步任务</h4>
<p>JS 的异步是通过回调函数实现的。</p>
<p>一般而言，异步任务有以下三种类型:</p>
<p>1、普通事件，如 click、resize 等</p>
<p>2、资源加载，如 load、error 等</p>
<p>3、定时器，包括 setInterval、setTimeout 等</p>
<p>异步任务相关回调函数添加到<strong>任务队列</strong>中（任务队列也称为消息队列）。</p>
<h4 id="43-执行机制"><a class="markdownIt-Anchor" href="#43-执行机制"></a> 4.3 执行机制</h4>
<ol>
<li>
<p>先执行执行栈中的同步任务。</p>
</li>
<li>
<p>异步任务（回调函数）放入任务队列中。</p>
</li>
<li>
<p>一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取任务队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行。</p>
<p><img src="https://i.loli.net/2021/08/29/6IoeB4v8srmWjih.png" alt="2.png" /></p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/08/29/P8au3RyM5Ubt4ze.png" alt="3.png" /></p>
<p>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。</p>
<h3 id="5-location对象"><a class="markdownIt-Anchor" href="#5-location对象"></a> 5. location对象</h3>
<h4 id="51-location对象"><a class="markdownIt-Anchor" href="#51-location对象"></a> 5.1 location对象</h4>
<p>window 对象给我们提供了一个 location 属性用于获取或设置窗体的 URL，并且可以用于解析 URL 。 因为这个属性返回的是一个对象，所以我们将这个属性也称为 location 对象。</p>
<h4 id="52-url"><a class="markdownIt-Anchor" href="#52-url"></a> 5.2 URL</h4>
<p>统一资源定位符 (Uniform Resource Locator, URL) 是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">protocol:<span class="comment">//host[:port]/path/[?query]#fragment</span></span><br><span class="line"></span><br><span class="line">http:<span class="comment">//www.itcast.cn/index.html?name=andy&amp;age=18#link</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.loli.net/2021/08/29/lm7IQnF8xA9RvKB.png" alt="4.png" /></p>
<h4 id="53-location-对象的属性"><a class="markdownIt-Anchor" href="#53-location-对象的属性"></a> 5.3 location 对象的属性</h4>
<p><img src="https://i.loli.net/2021/08/29/AX5Csl1nI7vKWoc.png" alt="5.png" /></p>
<p><strong>例：页面间数据传递</strong></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- login.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"index.html"</span>&gt;</span></span><br><span class="line">        用户名：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"登录"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- index.html --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> params = location.search.substr(<span class="number">1</span>);</span></span><br><span class="line"><span class="actionscript">        <span class="keyword">var</span> arr = params.split(<span class="string">'='</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">var</span> div = <span class="built_in">document</span>.querySelector(<span class="string">'div'</span>);</span></span><br><span class="line"><span class="actionscript">        div.innerHTML = arr[<span class="number">1</span>] + <span class="string">'欢迎你'</span>;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="54-location-对象的方法"><a class="markdownIt-Anchor" href="#54-location-对象的方法"></a> 5.4 location 对象的方法</h4>
<p><img src="https://i.loli.net/2021/08/29/XWSG6flriHUy9w4.png" alt="6.png" /></p>
<ul>
<li>
<p>assign记录浏览历史，可以后退</p>
</li>
<li>
<p>replace不可以后退</p>
</li>
</ul>
<h3 id="6-navigator-对象"><a class="markdownIt-Anchor" href="#6-navigator-对象"></a> 6. navigator 对象</h3>
<p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户机发送服务器的 user-agent 头部的值。</p>
<p>下面前端代码可以判断用户那个终端打开页面，实现跳转</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>((navigator.userAgent.match(<span class="regexp">/(phone|pad|pod|iPhone|iPod|ios|iPad|Android|Mobile|BlackBerry|IEMobile|MQQBrowser|JUC|Fennec|wOSBrowser|BrowserNG|WebOS|Symbian|Windows Phone)/i</span>))) &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">""</span>;     <span class="comment">//手机</span></span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">window</span>.location.href = <span class="string">""</span>;     <span class="comment">//电脑</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="7-history-对象"><a class="markdownIt-Anchor" href="#7-history-对象"></a> 7. history 对象</h3>
<p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。</p>
<p><img src="https://i.loli.net/2021/08/29/lbWxZGBwA7fae5D.png" alt="7.png" /></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>品优购案例</title>
    <url>/2021/07/21/%E5%89%8D%E7%AB%AF/%E5%93%81%E4%BC%98%E8%B4%AD%E7%BD%91%E7%AB%99%E5%BC%80%E5%8F%91%E6%A1%88%E4%BE%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="品优购案例"><a class="markdownIt-Anchor" href="#品优购案例"></a> 品优购案例</h2>
<h3 id="1-品优购项目规划"><a class="markdownIt-Anchor" href="#1-品优购项目规划"></a> 1. 品优购项目规划</h3>
<a id="more"></a>
<h4 id="11-网站制作流程"><a class="markdownIt-Anchor" href="#11-网站制作流程"></a> 1.1 网站制作流程</h4>
<p><img src="https://i.loli.net/2021/07/21/GsT5ncSjfh98wgY.png" alt="网站制作流程.png" /></p>
<h4 id="12-开发工具及技术栈"><a class="markdownIt-Anchor" href="#12-开发工具及技术栈"></a> 1.2 开发工具及技术栈</h4>
<p><strong>1. 开发工具</strong></p>
<p>VScode 、Photoshop（fw）、主流浏览器（以Chrome浏览器为主）</p>
<p><strong>2. 技术栈</strong></p>
<ul>
<li>利用 HTML5 + CSS3 手动布局，可以大量使用 H5 新增标签和样式</li>
<li>采取结构与样式相分离，模块化开发</li>
<li>良好的代码规范有利于团队更好的开发协作，提高代码质量，因此品优购项目里面，请同学们遵循以下代 码规范。（详情见— <strong><a href="http://xn--mnqve04pnx6burlnrjs3f.md" target="_blank" rel="noopener">品优购代码规范.md</a></strong>）</li>
</ul>
<p>下载链接：<a href="https://jaron-doge-1305669952.cos.ap-beijing.myqcloud.com/Notes/%E5%89%8D%E7%AB%AF/%E5%93%81%E4%BC%98%E8%B4%AD%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83.md" target="_blank" rel="noopener">https://jaron-doge-1305669952.cos.ap-beijing.myqcloud.com/Notes/前端/品优购代码规范.md</a></p>
<h4 id="13-品优购项目搭建工作"><a class="markdownIt-Anchor" href="#13-品优购项目搭建工作"></a> 1.3 品优购项目搭建工作</h4>
<p><strong>1. 需要创建如下文件夹：</strong></p>
<p><img src="https://i.loli.net/2021/07/21/Hx5Y8aAmghQktfl.png" alt="文件夹.png" /></p>
<p><strong>2. 需要创建如下文件：</strong></p>
<p><img src="https://i.loli.net/2021/07/21/mM1DgKU7wnaTxbs.png" alt="文件.png" /></p>
<p><strong>3. 模块化开发</strong></p>
<ul>
<li>有些样式和结构在很多页面都会出现，比如页面头部和底部，大部分页面都有。此时，可以把这些结构 和样式单独作为一个模块，然后重复使用</li>
<li>这里最典型的应用就是 common.css 公共样式。写好一个样式，其余的页面用到这些相同的样式</li>
<li>模块化开发具有重复使用、修改方便等优点</li>
</ul>
<p><img src="https://i.loli.net/2021/07/21/i7VLEpmMThkfdow.png" alt="commonCSS.png" /></p>
<p>common.css 公共样式里面包含版心宽度、清除浮动、页面文字颜色等公共样式。</p>
<h4 id="16-网站-favicon-图标"><a class="markdownIt-Anchor" href="#16-网站-favicon-图标"></a> 1.6 网站 favicon 图标</h4>
<p><strong>一、制作favicon图标</strong></p>
<ol>
<li>把品优购图标切成 png 图片。</li>
<li>把 png 图片转换为 ico 图标。</li>
</ol>
<p><strong>二、favicon图标放到网站根目录下</strong></p>
<p><strong>三、 HTML页面引入favicon图标</strong></p>
<p>在html 页面里面的 head 元素之间引入代码</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;link rel="shortcut icon" href="favicon.ico" /&gt;</span><br></pre></td></tr></table></figure>
<h4 id="17-网站tdk三大标签seo优化"><a class="markdownIt-Anchor" href="#17-网站tdk三大标签seo优化"></a> 1.7  网站TDK三大标签SEO优化</h4>
<p><strong>SEO（Search Engine Optimization）<strong>汉译为</strong>搜索引擎优化</strong>，是一种利用搜索引擎的规则提高网站在有关搜索引擎内自然排名的方式。</p>
<p>SEO 的目的是<strong>对网站进行深度的优化</strong>，从而帮助网站获取免费的流量，进而在搜索引擎上提升网站的排名，提高网站的知名度。</p>
<p>页面必须有三个标签用来符合 SEO 优化。</p>
<img src="https://i.loli.net/2021/07/21/piLFnxbG7q2XTmu.png" alt="SEO优化.png" style="zoom:80%;" />
<p>对于前端人员来说，只需要准备好这三个标签，具体里面的内容，有专门的 SEO 人员准备。</p>
<h5 id="1-title-网站标题"><a class="markdownIt-Anchor" href="#1-title-网站标题"></a> 1. title 网站标题</h5>
<p>title 具有不可替代性，是我们内页的第一个重要标签，是搜索引擎了解网页的入口和对网页主题归属的最佳判 断点。</p>
<p>建议：<strong>网站名（产品名）- 网站的介绍</strong> （尽量不要超过30个汉字）</p>
<p>例如：</p>
<ul>
<li>京东(<a href="http://JD.COM" target="_blank" rel="noopener">JD.COM</a>)-综合网购首选-正品低价、品质保障、配送及时、轻松购物！</li>
<li>小米商城 - 小米5s、红米Note 4、小米MIX、小米笔记本官方网站</li>
</ul>
<h5 id="2-description-网站说明"><a class="markdownIt-Anchor" href="#2-description-网站说明"></a> 2. description 网站说明</h5>
<p>简要说明我们网站主要是做什么的。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta name="description" content="京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、</span><br><span class="line">家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物</span><br><span class="line">体验!" /&gt;</span><br></pre></td></tr></table></figure>
<h5 id="3-keywords-关键字"><a class="markdownIt-Anchor" href="#3-keywords-关键字"></a> 3.  keywords 关键字</h5>
<p>keywords 是页面关键词，是搜索引擎的关注点之一。</p>
<p>keywords 最好限制为 6～8 个关键词，关键词之间用英文逗号隔开，采用 关键词1,关键词2 的形式。</p>
<p>例如：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;meta name="keywords" content="网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东" /&gt;</span><br></pre></td></tr></table></figure>
<h3 id="2-品优购首页制作"><a class="markdownIt-Anchor" href="#2-品优购首页制作"></a> 2. 品优购首页制作</h3>
<h4 id="21-logo-seo优化"><a class="markdownIt-Anchor" href="#21-logo-seo优化"></a> 2.1 LOGO SEO优化</h4>
<ol>
<li>logo 里面首先放一个 h1 标签，目的是为了提权，告诉搜索引擎，这个地方很重要。</li>
<li>h1 里面再放一个链接，可以返回首页的，把 logo 的背景图片给链接即可。</li>
<li>为了搜索引擎收录我们，我们链接里面要放文字（网站名称），但是文字不要显示出来。
<ul>
<li>方法1：text-indent 移到盒子外面（text-indent: -9999px) ，然后overflow:hidden ，淘宝的做法。</li>
<li>方法2：直接给 font-size: 0; 就看不到文字了，京东的做法。</li>
</ul>
</li>
<li>最后给链接一个 title 属性，这样鼠标放到 logo 上就可以看到提示文字了。</li>
</ol>
<h3 id="3-总结"><a class="markdownIt-Anchor" href="#3-总结"></a> 3. 总结</h3>
<ul>
<li>hover显示边框时可以给原盒子先设置透明边框</li>
<li>溢出的部分用overflow</li>
</ul>
<h3 id="4-网站地址"><a class="markdownIt-Anchor" href="#4-网站地址"></a> 4. 网站地址</h3>
<p><a href="http://www.peregrine.top/test/shopping/index.html" target="_blank" rel="noopener">http://www.peregrine.top/test/shopping/index.html</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>快捷键</title>
    <url>/2021/07/13/%E5%89%8D%E7%AB%AF/%E5%BF%AB%E6%8D%B7%E9%94%AE/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="快捷键"><a class="markdownIt-Anchor" href="#快捷键"></a> 快捷键</h2>
<h3 id="快捷键-2"><a class="markdownIt-Anchor" href="#快捷键-2"></a> 快捷键</h3>
<a id="more"></a>
<ul>
<li>
<ul>
<li></li>
</ul>
</li>
<li>&gt;</li>
<li>!：用来创建骨架</li>
<li>光标确定后ctrl+c + ctrl + v</li>
<li>全屏显示：F11</li>
<li>主命令框：F1</li>
<li>shift + alt拖下来选择一列</li>
</ul>
<h4 id="ctrl"><a class="markdownIt-Anchor" href="#ctrl"></a> ctrl</h4>
<ul>
<li>ctrl + - ：缩小</li>
<li>ctrl + +：放大</li>
<li>ctrl + /：添加注释</li>
<li>ctrl + L：选取一行（鼠标三击）</li>
</ul>
<h3 id="格式调整"><a class="markdownIt-Anchor" href="#格式调整"></a> 格式调整</h3>
<ul>
<li>
<p>代码行向左或向右缩进:   Ctrl+[ 、 Ctrl+]</p>
</li>
<li>
<p>向上或向下移动一行:   Alt+Up 或 Alt+Down</p>
</li>
<li>
<p>向上或向下复制一行:   Shift+Alt+Up 或 Shift+Alt+Down</p>
</li>
<li>
<p>在当前行下方插入一行:   Ctrl+Enter</p>
</li>
<li>
<p>在当前行上方插入一行:   Ctrl+Shift+Enter</p>
</li>
</ul>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 绪论</title>
    <url>/2020/10/01/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC1%E7%AB%A0%20%E7%BB%AA%E8%AE%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第一章-绪论"><a class="markdownIt-Anchor" href="#第一章-绪论"></a> 第一章 绪论</h2>
<h3 id="基本概念"><a class="markdownIt-Anchor" href="#基本概念"></a> 基本概念</h3>
<a id="more"></a>
<ul>
<li>字母表是一个非空又穷集合，字母表中的元素称为该字母表的一个<strong>字母</strong></li>
<li>字母表中的字符具有<strong>整体性</strong>和<strong>可辨认性</strong></li>
<li>语言是为广大人群所理解的<strong>字</strong>和<strong>组成这些字的方法</strong></li>
</ul>
<ol>
<li>
<p>字母表Σ的n次幂</p>
<p>​	Σ<sup>0</sup>={ε}</p>
<p>​	Σ<sup>n</sup>=Σ<sup>n-1</sup>Σ</p>
</li>
<li>
<p>Σ的正闭包</p>
<p>​	Σ<sup>+</sup>=Σ∪Σ<sup>2</sup>∪Σ<sup>3</sup>∪……</p>
</li>
<li>
<p>Σ的克林闭包</p>
<p>Σ<sup>*</sup>=Σ<sup>0</sup>∪Σ<sup>+</sup>=Σ<sup>0</sup>∪Σ∪Σ<sup>2</sup>∪Σ<sup>3</sup>∪……</p>
</li>
<li>
<p>句子</p>
<p>∑是一个字母表，∀x∈∑，x叫做∑上的一个句子</p>
</li>
<li>
<p>语言</p>
<p>设∑是一个字母表，∀L∈∑*，L称为字母表∑上的一个语言</p>
</li>
</ol>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>为什么要研究形式语言？为什么要学习形式语言？</p>
<p>​		对语言的处理是计算机学科的主要任务之一，对语言进行形式化表示是使语言能够得到计算机自动计算的前提，所以需要对语言的形式化方法进行研究。<br />
​		形式语言与自动机理论不仅是计算机科学与技术学科的重要基础理论，有着广泛的应用，而且对于专业人才的计算思维的培养，占有十分重要的地位，是引导学生理解抽象、形式化、自动计算这一计算机基本原理的非常合适的课程载体。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 文法</title>
    <url>/2020/10/05/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC2%E7%AB%A0%20%E6%96%87%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第二章-文法"><a class="markdownIt-Anchor" href="#第二章-文法"></a> 第二章 文法</h2>
<h3 id="形式定义"><a class="markdownIt-Anchor" href="#形式定义"></a> 形式定义</h3>
<h4 id="g-v-t-p-s"><a class="markdownIt-Anchor" href="#g-v-t-p-s"></a> G = (V, T, P, S)</h4>
<a id="more"></a>
<ul>
<li>V——<strong>变量</strong>，∀A∈V, A叫作<strong>语法变量/非终极符号</strong>，它表示一个<strong>语法范畴L(A)</strong></li>
<li>T——<strong>终极符</strong>, ∀a∈T, a叫作终极符</li>
<li>P——<strong>产生式</strong></li>
<li>S——<strong>开始符号</strong>， S∈V</li>
</ul>
<p>一般地，按如下方式使用符号：</p>
<ul>
<li>A, B, C…表示语法变量;</li>
<li>a, b, c…表示终极符号;</li>
<li>X, Y, Z…表示语法变量或终极符号;</li>
<li>x, y, z…表示由终极符号组成的行；</li>
<li>α, β, γ…表示由语法变量和终极符号组成的行</li>
</ul>
<h4 id="推导"><a class="markdownIt-Anchor" href="#推导"></a> 推导</h4>
<ul>
<li>α⇒<sup>+</sup>β：表示α在G中经过至少1步推导出β</li>
<li>α⇒*β：表示α在G中经过若干步推导出β</li>
</ul>
<h5 id="几点结论"><a class="markdownIt-Anchor" href="#几点结论"></a> 几点结论</h5>
<ul>
<li>
<p>对任意的x∈∑+，我们要使语法范畴D代表的集合为{xn|n≥0}，可用产生式组{D→ε|xD}来实现。</p>
</li>
<li>
<p>对任意的x，y∈∑<sup>+</sup>，我们要使语法范畴D代表的集合为{xnyn|n≥1}，可用产生式组{D→xy|xDy}来实现</p>
</li>
<li>
<p>对任意的x，y∈∑+，我们要使语法范畴D代表的集合为{xnyn|n≥0}，可用产生式组{D→ε|xDy}来实现</p>
</li>
</ul>
<h4 id="语言"><a class="markdownIt-Anchor" href="#语言"></a> 语言</h4>
<p>L(G)={w | w∈T*且S ⇒w*}</p>
<h5 id="句子"><a class="markdownIt-Anchor" href="#句子"></a> 句子</h5>
<p>∀w∈L(G)，w称为G产生的一个句子。</p>
<h5 id="句型"><a class="markdownIt-Anchor" href="#句型"></a> 句型</h5>
<p>G=(V，T，P，S)，对于∀α∈(V∪T)*，如果S ⇒* α，则称α是G产生的一个句型。</p>
<ul>
<li>句子不含语法变量，句型可能含语法变量</li>
</ul>
<h3 id="文法的构造"><a class="markdownIt-Anchor" href="#文法的构造"></a> 文法的构造</h3>
<ul>
<li>设有两个文法G1和G2，如果L(G1)= L(G2)，则称G1与G2等价。</li>
</ul>
<h3 id="文法的乔姆斯基体系"><a class="markdownIt-Anchor" href="#文法的乔姆斯基体系"></a> 文法的乔姆斯基体系</h3>
<h4 id="g-v-t-p-s-2"><a class="markdownIt-Anchor" href="#g-v-t-p-s-2"></a> G = (V, T, P, S)</h4>
<ul>
<li>
<p>G叫作<strong>0型文法</strong>，或<strong>短语结构文法(PSG)</strong></p>
</li>
<li>
<p>如果对于如果对于∀α→β∈P，均有|β|≥|α|成立，则称G为<strong>1型文法</strong>，或<strong>上下文有关文法(CSG)</strong></p>
</li>
<li>
<p>如果对于∀α→β∈P，均有|β|≥|α|，并且α∈V成立，则称G为<strong>2型文法</strong>，或<strong>上下文无关文法(CFG)</strong></p>
</li>
<li>
<p>如果对于∀α→β∈P，α→β均具有形式<br />
A→w<br />
A→wB<br />
其中A，B∈V，w∈T<sup>+</sup>。则称G为<strong>3型文法</strong>，也可称为<strong>正则文法(RG)</strong></p>
<p>如果一个文法G是RG，则它也是CFG、CSG和短语结构文法。反之不一定成立</p>
</li>
</ul>
<h5 id="定理2-1"><a class="markdownIt-Anchor" href="#定理2-1"></a> 定理2-1</h5>
<p>​		L是RL的充要条件是存在一个文法，该文法产生语言L，并且它的产生式要么是形如：A→a的产生式，要么是形如A→aB的产生式。其中A、B为语法变量，a为终极符号。</p>
<h4 id="线性文法"><a class="markdownIt-Anchor" href="#线性文法"></a> 线性文法</h4>
<ul>
<li>设G=(V，T，P，S)，如果对于∀α→β∈P，α →β均具有如下形式：<br />
A→w<br />
A→wBx<br />
其中A，B∈V，w，x∈T*，则称G为<strong>线性文法</strong></li>
<li>设G=(V，T，P，S)，如果对于∀α→β∈P，α→β均具有如下形式：<br />
A→w<br />
A→wB<br />
其中A，B∈V，w∈T<sup>+</sup>，则称G为<strong>右线性文法</strong></li>
<li>左线性文法(left liner grammar)<br />
设G=(V，T，P，S)，如果对于∀α→β∈P，α→β均具有如下形式：<br />
A→w<br />
A→Bw<br />
其中A，B∈V，w∈T<sup>+</sup>，则称G为<strong>左线性文法</strong></li>
</ul>
<h5 id="定理2-3"><a class="markdownIt-Anchor" href="#定理2-3"></a> 定理2-3</h5>
<p>​	左线性文法与右线性文法等价</p>
<h5 id="定理2-4"><a class="markdownIt-Anchor" href="#定理2-4"></a> 定理2-4</h5>
<p>​	左线性文法的产生式与右线性文法的产生式混用所得到的文法不是RG</p>
<h3 id="空语句"><a class="markdownIt-Anchor" href="#空语句"></a> 空语句</h3>
<h5 id="定理2-5"><a class="markdownIt-Anchor" href="#定理2-5"></a> 定理2-5</h5>
<p>​		设G=(V，T，P，S)为一文法，则存在与G同类型的文法G′=(V′，T，P′，S′)，使得L(G)=L(G′)，但G′的开始符号S′不出现在G′的任何产生式的右部</p>
<h5 id="定义2-10"><a class="markdownIt-Anchor" href="#定义2-10"></a> 定义2-10</h5>
<p>​		设G=(V，T，P，S)是一个文法，如果S不出现在G的任何产生式的右部，则：</p>
<ul>
<li>
<p>如果G是CSG，则仍然称G=(V，T，P∪{S→ε}，S)为CSG；G产生的语言仍然称为CSL</p>
</li>
<li>
<p>如果G是CFG，则仍然称G=(V，T，P∪{S→ε}，S)为CFG；G产生的语言仍然称为CFL</p>
</li>
<li>
<p>如果G是RG，则仍然称G=(V，T，P∪{S→ε}，S)为RG。G产生的语言仍然称为RL</p>
<p>对于G中的任何变量A，在需要的时候，可以出现形如A→ε的产生式</p>
</li>
</ul>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 正则语言的性质</title>
    <url>/2020/10/23/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC5%E7%AB%A0%20%E6%AD%A3%E5%88%99%E8%AF%AD%E8%A8%80%E7%9A%84%E6%80%A7%E8%B4%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="正则语言的性质"><a class="markdownIt-Anchor" href="#正则语言的性质"></a> 正则语言的性质</h2>
<h3 id="51-正则语言的泵引理"><a class="markdownIt-Anchor" href="#51-正则语言的泵引理"></a> 5.1 正则语言的泵引理</h3>
<a id="more"></a>
<h4 id="引理5-1泵引理"><a class="markdownIt-Anchor" href="#引理5-1泵引理"></a> 引理5-1：泵引理</h4>
<p>设L为一个 RL ，则存在仅依赖于L的正整数N，对于∀z∈L，如果|z|≥N，则存在u、v、w，满足<br />
⑴ z=uvw；<br />
⑵ |uv|≤N；<br />
⑶ |v|≥1；<br />
⑷ 对于任意的整数i≥0，uv<sup>i</sup>w∈L；<br />
⑸ N不大于接受L的最小DFA M的状态数。</p>
<ul>
<li>泵引理是一个语言是RL的必要条件，所以利用该引理不能证明一个语言是RL，但是可以证明一个语言不是RL</li>
</ul>
<h5 id="例5-1-证明0n1nn1不是-rl"><a class="markdownIt-Anchor" href="#例5-1-证明0n1nn1不是-rl"></a> 例5-1 证明{0<sup>n</sup>1<sup>n</sup>|n≥1}不是 RL</h5>
<p><img src="https://i.loli.net/2021/10/09/XP6dSDrTAmJ3nfk.png" alt="29.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/xe2dpAcoaylFmMg.png" alt="30.png" /></p>
<h3 id="52-正则语言的封闭性"><a class="markdownIt-Anchor" href="#52-正则语言的封闭性"></a> 5.2 正则语言的封闭性</h3>
<h4 id="定义5-1封闭性"><a class="markdownIt-Anchor" href="#定义5-1封闭性"></a> 定义5-1：封闭性</h4>
<p>如果任意的、属于同一语言类的语言在某一特定运算下所得的结果仍然是该类语言，则称该语言类对此运算是<strong>封闭的</strong></p>
<h4 id="有效封闭性"><a class="markdownIt-Anchor" href="#有效封闭性"></a> 有效封闭性</h4>
<p>给定一个语言类的若干个语言的描述，如果存在一个算法，它可以构造出这些语言在给定运算下所获得的运算结果的相应形式的语言描述，则称此语言类对相应的运算是<strong>有效封闭</strong>的。</p>
<h4 id="定理5-2-rl在补运算下封闭"><a class="markdownIt-Anchor" href="#定理5-2-rl在补运算下封闭"></a> 定理5-2 RL在补运算下封闭</h4>
<p><img src="https://i.loli.net/2021/10/09/bP7KM5krG6n8pxt.png" alt="31.png" /></p>
<h4 id="定理5-3-rl在交运算下封闭"><a class="markdownIt-Anchor" href="#定理5-3-rl在交运算下封闭"></a> 定理5-3 RL在交运算下封闭</h4>
<p><img src="https://i.loli.net/2021/10/09/CYexIT5fuVHo6bG.png" alt="32.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/E4sak8pceJg6TFB.png" alt="33.png" /></p>
<h4 id="定义5-2-正则代换"><a class="markdownIt-Anchor" href="#定义5-2-正则代换"></a> 定义5-2 正则代换</h4>
<p>设∑、Δ是两个字母表，映射</p>
<img src="https://i.loli.net/2021/10/09/Me43Zw2qVvxiaKI.png" alt="34.png" style="zoom:50%;" />
<p>被称为是从∑到Δ的<strong>代换</strong>。如果对于∀a∈∑，f(a)是Δ上的 RL ，则称f为<strong>正则代换</strong>。</p>
<p>⑴ f(Φ)=Φ；<br />
⑵ f(ε)=ε；<br />
⑶ 对于∀a∈∑，f(a)是Δ上的RE；<br />
⑷ 如果r，s是∑上的RE，则<br />
f(r+s)=f®+f(s)<br />
f(rs)=f®f(s)<br />
f(r<sup>*</sup>)=f®<sup>*</sup><br />
是Δ上的RE。</p>
<h5 id="例5-4"><a class="markdownIt-Anchor" href="#例5-4"></a> 例5-4</h5>
<p><img src="https://i.loli.net/2021/10/09/UMZRpFyVbeYQkwL.png" alt="35.png" /></p>
<h4 id="定义5-4-同态映射"><a class="markdownIt-Anchor" href="#定义5-4-同态映射"></a> 定义5-4 同态映射</h4>
<p><img src="https://i.loli.net/2021/10/09/Nntezh7pxfMHQs1.png" alt="36.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/gkTICtPUqyn5rbE.png" alt="37.png" /></p>
<h5 id="例5-6"><a class="markdownIt-Anchor" href="#例5-6"></a> 例5-6</h5>
<p><img src="https://i.loli.net/2021/10/09/rS5iJUCo7mwGA8N.png" alt="38.png" /></p>
<h4 id="定义5-5-商"><a class="markdownIt-Anchor" href="#定义5-5-商"></a> 定义5-5 商</h4>
<p><img src="https://i.loli.net/2021/10/09/xGSEK8NbY2Bh3j7.png" alt="39.png" /></p>
<h5 id="例5-6-2"><a class="markdownIt-Anchor" href="#例5-6-2"></a> 例5-6</h5>
<p><img src="https://i.loli.net/2021/10/09/ne6QELb2h1mgaGH.png" alt="40.png" /></p>
<h3 id="53-myhill-nerode定理与dfa的极小化"><a class="markdownIt-Anchor" href="#53-myhill-nerode定理与dfa的极小化"></a> 5.3 Myhill-Nerode定理与DFA的极小化</h3>
<h4 id="531-myhill-nerode定理"><a class="markdownIt-Anchor" href="#531-myhill-nerode定理"></a> 5.3.1 Myhill-Nerode定理</h4>
<h5 id="定义5-6-rm关系"><a class="markdownIt-Anchor" href="#定义5-6-rm关系"></a> 定义5-6 R<sub>M</sub>关系</h5>
<p><img src="https://i.loli.net/2021/10/09/GcSDwCRPtynLUaf.png" alt="41.png" /></p>
<h5 id="定义5-7-rl关系"><a class="markdownIt-Anchor" href="#定义5-7-rl关系"></a> 定义5-7 R<sub>L</sub>关系</h5>
<p><img src="https://i.loli.net/2021/10/09/CDX8Glrtf4TpmHP.png" alt="42.png" /></p>
<h5 id="定义5-8-右不变的等价关系"><a class="markdownIt-Anchor" href="#定义5-8-右不变的等价关系"></a> 定义5-8 右不变的等价关系</h5>
<p>设R是∑<sup>*</sup>上的等价关系，对于∀x，y∈∑<sup>*</sup>，如果x R y，则必有xz R yz对于∀z∈∑<sup>*</sup>成立，则称R是右不变的等价关系。</p>
<ul>
<li>R<sub>M</sub>、R<sub>L</sub>都是右不变的等价关系</li>
</ul>
<h5 id="定义5-9-指数"><a class="markdownIt-Anchor" href="#定义5-9-指数"></a> 定义5-9 指数</h5>
<p><img src="https://i.loli.net/2021/10/09/9fDkvbPH1O6dm7y.png" alt="43.png" /></p>
<h5 id="等价类划分"><a class="markdownIt-Anchor" href="#等价类划分"></a> 等价类划分！！！</h5>
<p>P144</p>
<h5 id="定理5-7myhill-nerode定理"><a class="markdownIt-Anchor" href="#定理5-7myhill-nerode定理"></a> 定理5-7(Myhill-Nerode定理)</h5>
<p><img src="https://i.loli.net/2021/10/09/vt1hdijxHsC7LER.png" alt="44.png" /></p>
<h5 id="例5-10-用定理5-7证明0n1nn0不是-rl"><a class="markdownIt-Anchor" href="#例5-10-用定理5-7证明0n1nn0不是-rl"></a> 例5-10 用定理5-7证明{0<sup>n</sup>1<sup>n</sup>|n≥0}不是 RL</h5>
<p><img src="https://i.loli.net/2021/10/09/dpYfibK6rxROwFy.png" alt="45.png" /></p>
<h3 id="532-dfa的极小化"><a class="markdownIt-Anchor" href="#532-dfa的极小化"></a> 5.3.2 DFA的极小化</h3>
<h4 id="定义5-10-可以区分的"><a class="markdownIt-Anchor" href="#定义5-10-可以区分的"></a> 定义5-10 可以区分的</h4>
<p><img src="https://i.loli.net/2021/10/09/9WU4lhNug2FmTap.png" alt="46.png" /></p>
<h4 id="dfa的极小化算法"><a class="markdownIt-Anchor" href="#dfa的极小化算法"></a> DFA的极小化算法</h4>
<p>算法思想：扫描所有的状态对，找出所有的可区分的状态对，不可区分的状态</p>
<p>对一定是等价的。</p>
<p>输入：给定的DFA。</p>
<p>输出：可区分状态表。</p>
<p>主要数据结构：状态对的关联链表；可区分状态表</p>
<p><img src="https://i.loli.net/2021/10/09/w58JzksvcQTmfoD.png" alt="47.png" /></p>
<h5 id="算法主要步骤"><a class="markdownIt-Anchor" href="#算法主要步骤"></a> 算法主要步骤</h5>
<p><img src="https://i.loli.net/2021/10/09/MHjSEdVy8IkqOCi.png" alt="48.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/9gvW4C2mp6xHPOV.png" alt="49.png" /></p>
<h5 id="例5-12"><a class="markdownIt-Anchor" href="#例5-12"></a> 例5-12 ！！！</h5>
<p>P154 / P57</p>
<h3 id="54-正则语言的判定算法"><a class="markdownIt-Anchor" href="#54-正则语言的判定算法"></a> 5.4 正则语言的判定算法</h3>
<h4 id="定理5-10-l有穷"><a class="markdownIt-Anchor" href="#定理5-10-l有穷"></a> 定理5-10 L有穷</h4>
<p><img src="https://i.loli.net/2021/10/09/dQm5Ul6PxM8c7pA.png" alt="50.png" /></p>
<h4 id="定理5-11-l无穷"><a class="markdownIt-Anchor" href="#定理5-11-l无穷"></a> 定理5-11 L无穷</h4>
<p><img src="https://i.loli.net/2021/10/09/hBkNdS3AuZp9Gr5.png" alt="51.png" /></p>
<ul>
<li>定理5-12 存在判定M<sub>1</sub>与M<sub>2</sub>是否等价的算法</li>
<li>定理5-13 存在判定x是不是L的句子的算法</li>
</ul>
<h3 id="55-小结"><a class="markdownIt-Anchor" href="#55-小结"></a> 5.5 小结</h3>
<p>RL 对有关运算的封闭性。RL 在并、乘、闭包、补、交、正则代换、同态映射运算下是有效封闭的。RL 的同态原像是 RL</p>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 正则表达式</title>
    <url>/2020/10/22/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC4%E7%AB%A0%20%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第四章-正则表达式"><a class="markdownIt-Anchor" href="#第四章-正则表达式"></a> 第四章 正则表达式</h2>
<h3 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义</h3>
<a id="more"></a>
<p>⑴ Φ是∑上的RE，它表示语言Φ；<br />
⑵ ε是∑上的RE，它表示语言{ε}；<br />
⑶ 对于∀a∈∑，a是∑上的RE，它表示语言{a}；<br />
⑷ 如果r和s分别是∑上表示语言R和S的RE，则：<br />
r与s的“和” (r+s)是∑上的RE，(r+s)表达的语言为R∪S；<br />
r与s的“乘积” (rs)是∑上的RE，(rs)表达的语言为RS；<br />
r的克林闭包(r*)是∑上的RE，(r*)表达的语言为R*。<br />
⑸ 只有满足⑴、⑵、⑶、⑷的才是∑上的RE。</p>
<h4 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h4>
<p><img src="https://i.loli.net/2021/10/09/5FH2PAmv8WeQgNC.png" alt="20.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/PpVYd3xLFwkWq8j.png" alt="21.png" /></p>
<h3 id="re到fa的转换"><a class="markdownIt-Anchor" href="#re到fa的转换"></a> RE到FA的转换</h3>
<h4 id="r-r1-r2"><a class="markdownIt-Anchor" href="#r-r1-r2"></a> r = r1 + r2</h4>
<p><img src="https://i.loli.net/2021/10/09/oJ7p6TqtVFYNSlX.png" alt="22.png" /></p>
<h4 id="r-r1-r2-2"><a class="markdownIt-Anchor" href="#r-r1-r2-2"></a> r = r1 r2</h4>
<p><img src="https://i.loli.net/2021/10/09/6T8WXZUMD3JiztY.png" alt="23.png" /></p>
<h4 id="r-r1"><a class="markdownIt-Anchor" href="#r-r1"></a> r = r1*</h4>
<p><img src="https://i.loli.net/2021/10/09/8tOHoiRTf5KksLa.png" alt="24.png" /></p>
<h3 id="dfa转re"><a class="markdownIt-Anchor" href="#dfa转re"></a> DFA转RE</h3>
<p>⑴ 预处理：<br />
① 用标记为X和Y的状态将M“括起来”：<br />
在状态转移图中增加标记为X和Y的状态，从标记为X的状态到标记为q0的状态引一条标记为ε的弧；从标记为q(q∈F)的状态到标记为Y的状态分别引一条标记为ε的弧。<br />
② 去掉所有的不可达状态。<br />
(2)合并<br />
①并弧</p>
<p><img src="https://i.loli.net/2021/10/09/AmfrNObYKaMP5eL.png" alt="25.png" /></p>
<p>②去状态1</p>
<p><img src="https://i.loli.net/2021/10/09/HRO4SACdQFjqGLa.png" alt="26.png" /></p>
<p>③去状态2</p>
<p><img src="https://i.loli.net/2021/10/09/poqxB2ALfD4VQ7w.png" alt="27.png" /></p>
<p>④去状态3</p>
<p>​	如果图中只有三个状态，而且不存在从标记为X的状态到达标记为Y的状态的路，则将除标记为X的状态和标记为Y的状态之外的第3个状态及其相关的弧全部删除。</p>
<p>⑶ 从标记为X的状态到标记为Y的状态的弧的标记为所求的正则表达式。如果此弧不存在，则所求的正则表达式为Φ。</p>
<p><img src="https://i.loli.net/2021/10/09/axZzJMRrkLsVY1f.png" alt="28.png" /></p>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 有穷状态自动机</title>
    <url>/2020/10/21/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC3%E7%AB%A0%20%E6%9C%89%E7%A9%B7%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-有穷状态自动机"><a class="markdownIt-Anchor" href="#第三章-有穷状态自动机"></a> 第三章 有穷状态自动机</h2>
<h3 id="fa"><a class="markdownIt-Anchor" href="#fa"></a> FA</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2020/10/21/cGB23OlY1yRFhoW.png" alt="image-20201021152857025.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/e23o7Z5hNFmwOCb.png" alt="2.png" /></p>
<h3 id="dfa"><a class="markdownIt-Anchor" href="#dfa"></a> DFA</h3>
<p><img src="https://i.loli.net/2020/10/21/hKxHoELvje1l6yk.png" alt="3.png" /></p>
<h3 id="nfa"><a class="markdownIt-Anchor" href="#nfa"></a> NFA</h3>
<p><img src="https://i.loli.net/2020/10/21/uGthOYj98NlpQzg.png" alt="4.png" /></p>
<h4 id="nfa转dfa"><a class="markdownIt-Anchor" href="#nfa转dfa"></a> NFA转DFA！！！</h4>
<p><img src="https://i.loli.net/2020/10/21/Xb9ZPt2c4YBlq38.png" alt="5.png" /></p>
<h3 id="ε-nfa"><a class="markdownIt-Anchor" href="#ε-nfa"></a> ε-NFA</h3>
<p><img src="https://i.loli.net/2020/10/21/yClZ25FvRA3BqDi.png" alt="6.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/yOPLgCShQfi9tkd.png" alt="7.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/kZCf2gcYjStKsBe.png" alt="8.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/nZh73wQlx2ozXmI.png" alt="9.png" /></p>
<h4 id="ε-nfa转nfa"><a class="markdownIt-Anchor" href="#ε-nfa转nfa"></a> ε-NFA转NFA！！！</h4>
<p><img src="https://i.loli.net/2020/10/21/6GqYkyUoenj8wsK.png" alt="10.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/UcFgklAiwzPjxNR.png" alt="11.png" /></p>
<h3 id="fa是正则语言的识别器"><a class="markdownIt-Anchor" href="#fa是正则语言的识别器"></a> FA是正则语言的识别器</h3>
<h4 id="dfa转正则语言"><a class="markdownIt-Anchor" href="#dfa转正则语言"></a> DFA转正则语言！！！</h4>
<p><img src="https://i.loli.net/2020/10/21/jRyeFSAa2XxB7If.png" alt="12.png" /></p>
<p>记得删除DFA的陷阱状态</p>
<h4 id="正则语言右线性文法转fa"><a class="markdownIt-Anchor" href="#正则语言右线性文法转fa"></a> 正则语言/右线性文法转FA！！！</h4>
<p><img src="https://i.loli.net/2020/10/21/nOil6x7vMIRzQYL.png" alt="13.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/a7QcpXFZzxonKef.png" alt="14.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/7H3EQKlWITnVmu5.png" alt="15.png" /></p>
<h4 id="左线性文法转fa"><a class="markdownIt-Anchor" href="#左线性文法转fa"></a> 左线性文法转FA</h4>
<ul>
<li>G的开始符号对应的状态就是相应FA的终止状态</li>
</ul>
<p><img src="https://i.loli.net/2020/10/21/UsF1XqDeQGaWJkH.png" alt="16.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/yd7BnfPMSrHDEvp.png" alt="17.png" /></p>
<h4 id="dfa转左线性文法"><a class="markdownIt-Anchor" href="#dfa转左线性文法"></a> DFA转左线性文法</h4>
<p>⑴ 删除DFA的陷阱状态(包括与之相关的弧)；<br />
⑵ 在图中加一个识别状态z，即为文法的开始变量；<br />
⑶ “复制”一条原来到达终止状态的弧，使它从原来的起点出发，到达新添加的识别状态。<br />
(4)如果启动状态是终止状态，则增加产生式z→ε</p>
<p><img src="https://i.loli.net/2020/10/21/ZIRwSQ5UevNMBzr.png" alt="18.png" /></p>
<p><img src="https://i.loli.net/2020/10/21/uZedqiAj8zOYova.png" alt="19.png" /></p>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 上下文无关语言</title>
    <url>/2020/10/24/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC6%E7%AB%A0%20%E4%B8%8A%E4%B8%8B%E6%96%87%E6%97%A0%E5%85%B3%E8%AF%AD%E8%A8%80/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-上下文无关语言"><a class="markdownIt-Anchor" href="#第六章-上下文无关语言"></a> 第六章 上下文无关语言</h2>
<h3 id="61-上下文无关文法"><a class="markdownIt-Anchor" href="#61-上下文无关文法"></a> 6.1 上下文无关文法</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/10/09/GB4JPuCWOY2QbEm.png" alt="52.png" /></p>
<h4 id="611-派生树"><a class="markdownIt-Anchor" href="#611-派生树"></a> 6.1.1 派生树</h4>
<p><img src="https://i.loli.net/2021/10/09/kuFwYKxvEzHUfJD.png" alt="53.png" /><br />
<img src="https://i.loli.net/2021/10/09/maUvL3oTjuhqXeM.png" alt="54.png" /></p>
<h5 id="顺序"><a class="markdownIt-Anchor" href="#顺序"></a> 顺序</h5>
<p><img src="https://i.loli.net/2021/10/09/oUnMJYSIjs2hyxW.png" alt="55.png" /></p>
<h5 id="派生"><a class="markdownIt-Anchor" href="#派生"></a> 派生</h5>
<p><img src="https://i.loli.net/2021/10/09/uvMl2PDKk9IciQq.png" alt="56.png" /></p>
<h5 id="规范派生"><a class="markdownIt-Anchor" href="#规范派生"></a> 规范派生</h5>
<p><img src="https://i.loli.net/2021/10/09/vdfR1k7FBDAoMGq.png" alt="57.png" /></p>
<h4 id="612-二义性"><a class="markdownIt-Anchor" href="#612-二义性"></a> 6.1.2 二义性</h4>
<p><img src="https://i.loli.net/2021/10/09/pbEHexVTdIOfLzK.png" alt="58.png" /></p>
<h5 id="固有二义性"><a class="markdownIt-Anchor" href="#固有二义性"></a> 固有二义性</h5>
<p><img src="https://i.loli.net/2021/10/09/njEobOmQfi2ywkq.png" alt="59.png" /></p>
<h4 id="613-自顶向下的分析和自底向上的分析"><a class="markdownIt-Anchor" href="#613-自顶向下的分析和自底向上的分析"></a> 6.1.3 自顶向下的分析和自底向上的分析</h4>
<h5 id="自顶向下"><a class="markdownIt-Anchor" href="#自顶向下"></a> 自顶向下</h5>
<p><img src="https://i.loli.net/2021/10/09/xy5Qbrk7UwZu9OA.png" alt="60.png" /></p>
<h5 id="自底向上"><a class="markdownIt-Anchor" href="#自底向上"></a> 自底向上</h5>
<p><img src="https://i.loli.net/2021/10/09/LU8I9wYibRVC715.png" alt="61.png" /></p>
<h3 id="62-上下文无关文法的化简"><a class="markdownIt-Anchor" href="#62-上下文无关文法的化简"></a> 6.2 上下文无关文法的化简</h3>
<h4 id="621-去无用符号"><a class="markdownIt-Anchor" href="#621-去无用符号"></a> 6.2.1 去无用符号</h4>
<p><img src="https://i.loli.net/2021/10/09/OYUP6xL1V5ceBDv.png" alt="62.png" /><br />
<img src="https://i.loli.net/2021/10/09/6WwknIhDlsFXZi4.png" alt="63.png" /></p>
<h5 id="算法6-1-删除派生不出终极符号行的变量"><a class="markdownIt-Anchor" href="#算法6-1-删除派生不出终极符号行的变量"></a> 算法6-1 删除派生不出终极符号行的变量</h5>
<p><img src="https://i.loli.net/2021/10/09/QIszhLWnjedTHRt.png" alt="64.png" /></p>
<h5 id="算法6-2-删除不出现在任何句型中的语法符号"><a class="markdownIt-Anchor" href="#算法6-2-删除不出现在任何句型中的语法符号"></a> 算法6-2 删除不出现在任何句型中的语法符号</h5>
<p><img src="https://i.loli.net/2021/10/09/oTvQgHGysfbkFXe.png" alt="65.png" /><br />
<img src="https://i.loli.net/2021/10/09/43GaRbwreTFBtQK.png" alt="66.png" /></p>
<h4 id="622-去-ε-产生式"><a class="markdownIt-Anchor" href="#622-去-ε-产生式"></a> 6.2.2 去 ε- 产生式</h4>
<p><img src="https://i.loli.net/2021/10/09/8yGLc4Xfu1ps9wb.png" alt="67.png" /><br />
<img src="https://i.loli.net/2021/10/09/swt9K5E7Q3F8IYR.png" alt="68.png" /><br />
<img src="https://i.loli.net/2021/10/09/fDLyRJBM2isQE9W.png" alt="69.png" /></p>
<h4 id="623-去单一产生式组"><a class="markdownIt-Anchor" href="#623-去单一产生式组"></a> 6.2.3 去单一产生式组</h4>
<p><img src="https://i.loli.net/2021/10/09/HpRsonv2lhE4bQi.png" alt="70.png" /><br />
<img src="https://i.loli.net/2021/10/09/9ZRKQPgboAG8j4C.png" alt="71.png" /></p>
<h4 id="624-cfg化简方法"><a class="markdownIt-Anchor" href="#624-cfg化简方法"></a> 6.2.4 CFG化简方法</h4>
<p><img src="https://i.loli.net/2021/10/09/U7lc6J9yCZBeLpK.png" alt="72.png" /></p>
<h3 id="63-乔姆斯基范式"><a class="markdownIt-Anchor" href="#63-乔姆斯基范式"></a> 6.3 乔姆斯基范式</h3>
<p><img src="https://i.loli.net/2021/10/09/JLSfBR2krb9zaMs.png" alt="73.png" /></p>
<p><font color='red'>  <strong>将右部长度大于等于2的产生式中的终极符号用新的变量替代</strong></font></p>
<h5 id="例-6-6"><a class="markdownIt-Anchor" href="#例-6-6"></a> 例 6-6</h5>
<p><img src="https://i.loli.net/2021/10/09/K4k9pcP5uUd7DmY.png" alt="74.png" /><br />
<img src="https://i.loli.net/2021/10/09/F2OCjVvtGbf94zU.png" alt="75.png" /><br />
<img src="https://i.loli.net/2021/10/09/MrDleQx5o8df3KY.png" alt="76.png" /></p>
<h3 id="64-格雷巴赫范式"><a class="markdownIt-Anchor" href="#64-格雷巴赫范式"></a> 6.4 格雷巴赫范式</h3>
<p><img src="https://i.loli.net/2021/10/09/T169MA2EkgDQGfz.png" alt="77.png" /></p>
<h5 id="定义6-13-递归"><a class="markdownIt-Anchor" href="#定义6-13-递归"></a> 定义6-13 递归</h5>
<p><img src="https://i.loli.net/2021/10/09/NxafKOu8lp4mjPo.png" alt="78.png" /><br />
<img src="https://i.loli.net/2021/10/09/Sj3xpMdTE1qytrl.png" alt="79.png" /></p>
<h4 id="gnf转化"><a class="markdownIt-Anchor" href="#gnf转化"></a> GNF转化</h4>
<p>①引入变量B和C，对文法进行改造，将文法产生式右侧不在最左侧的终结符号替换为变量</p>
<p><img src="https://i.loli.net/2021/10/09/lQFofnz47AxiMy5.png" alt="81.png" /></p>
<p>②对于每个A<sub>k</sub>→A<sub>j</sub>α (k &gt; j)的产生式，进行替换</p>
<p><img src="https://i.loli.net/2021/10/09/C3X2FRLaVkxPnO9.png" alt="82.png" /></p>
<p>按照定义6-12(上面)进行改造</p>
<p><img src="https://i.loli.net/2021/10/09/2x5bf14GqXkdVnT.png" alt="83.png" /></p>
<p>③具有最大下标的产生式A<sub>3</sub>已经满足GNF要求，将这些产生式代入还不满足要求的前面的产生式A<SUB>2</SUB>中</p>
<p><img src="https://i.loli.net/2021/10/09/YgzTq9xU314oi6Z.png" alt="84.png" /></p>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第七章 下推自动机</title>
    <url>/2020/10/25/%E5%BD%A2%E5%BC%8F%E8%AF%AD%E8%A8%80%E4%B8%8E%E8%87%AA%E5%8A%A8%E6%9C%BA/%E7%AC%AC7%E7%AB%A0%20%E4%B8%8B%E6%8E%A8%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-下推自动机"><a class="markdownIt-Anchor" href="#第七章-下推自动机"></a> 第七章 下推自动机</h2>
<h3 id="71-基本定义"><a class="markdownIt-Anchor" href="#71-基本定义"></a> 7.1 基本定义</h3>
<a id="more"></a>
<p>每个CFG都可以化成与其等价的GNF文法。<br />
GNF文法的产生式形如：A→aα ，其中，A∈V，a∈T，α∈V*</p>
<p>​		考虑引入一个栈来存放这个变量后缀，最左边的变量最先分析，可以放在栈的最上面；最右边的变量最后分析，放在栈的最下面。<br />
​		分析开始时，只有文法的开始符号在栈中，在分析过程中，一旦栈空，句子就被产生了。</p>
<p><img src="https://i.loli.net/2021/10/09/d3gLCHWQYUbN92E.png" alt="85.png" /></p>
<p>(1)根据有穷状态控制器的当前状态、栈顶符号以及当前的输入符号选择动作：将状态改变为新状态；修改栈顶，用新的语法符号串代替当前的栈顶符号；向右移动读头，使读头指向下一个输入符号；<br />
(2)根据有穷状态控制器的当前状态、栈顶符号选择动作：将状态修改为新的状态；修改栈顶，用新的语法符号串代替当前的栈顶符号。不移动读头，是一次空移动。</p>
<p><img src="https://i.loli.net/2021/10/09/GsIjKRnc8u4zByZ.png" alt="86.png" /><br />
<img src="https://i.loli.net/2021/10/09/ICRZxoK6g5OczVM.png" alt="87.png" /></p>
<h4 id="711-接受的语言"><a class="markdownIt-Anchor" href="#711-接受的语言"></a> 7.1.1 接受的语言</h4>
<p><img src="https://i.loli.net/2021/10/09/Xmr4aKlS8gtRPHw.png" alt="89.png" /></p>
<h5 id="例7-1"><a class="markdownIt-Anchor" href="#例7-1"></a> 例7-1：</h5>
<p><img src="https://i.loli.net/2021/10/09/rMqEP1poJlZ67c3.png" alt="90.png" /></p>
<p><strong>空栈接受</strong></p>
<p><img src="https://i.loli.net/2021/10/09/veG9KDJkQcogYyC.png" alt="91.png" /></p>
<p><strong>终态接受</strong></p>
<p><img src="https://i.loli.net/2021/10/09/XFl7QPmiq8jDLcg.png" alt="92.png" /></p>
<p><strong>开始——记录——匹配</strong></p>
<p><img src="https://i.loli.net/2021/10/09/JHwCI7lz3ZxeuGQ.png" alt="93.png" /></p>
<h3 id="72-pda与cfg等价"><a class="markdownIt-Anchor" href="#72-pda与cfg等价"></a> 7.2 PDA与CFG等价</h3>
<h4 id="721-pda用空栈接受和用终止状态接受等价"><a class="markdownIt-Anchor" href="#721-pda用空栈接受和用终止状态接受等价"></a> 7.2.1 PDA用空栈接受和用终止状态接受等价</h4>
<p><img src="https://i.loli.net/2021/10/09/xw9d5MBYLAIKkzS.png" alt="96.png" /><br />
<img src="https://i.loli.net/2021/10/09/lIJ2ycuVXSAUpaH.png" alt="97.png" /></p>
<h4 id="722-pda与cfg等价"><a class="markdownIt-Anchor" href="#722-pda与cfg等价"></a> 7.2.2 PDA与CFG等价</h4>
<p><img src="https://i.loli.net/2021/10/09/6mTwtZCAGnFIQxX.png" alt="98.png" /></p>
<h5 id="例7-3构造与gnf等价的pda"><a class="markdownIt-Anchor" href="#例7-3构造与gnf等价的pda"></a> 例7-3：构造与GNF等价的PDA</h5>
<p><img src="https://i.loli.net/2021/10/09/McJplqw526mgVUB.png" alt="99.png" /><br />
<img src="https://i.loli.net/2021/10/09/KlVNFWn8wLfxbGt.png" alt="100.png" /></p>
<p><img src="https://i.loli.net/2021/10/09/p7mfxg4VFc2SAiD.png" alt="94.png" /><br />
<img src="https://i.loli.net/2021/10/09/oiV8RSIXrDAq7CY.png" alt="95.png" /></p>
<h5 id="例7-5-构造与pda等价的cfg"><a class="markdownIt-Anchor" href="#例7-5-构造与pda等价的cfg"></a> 例7-5 构造与PDA等价的CFG</h5>
<p><img src="https://i.loli.net/2021/10/09/XCjkvuqm5LlA9IP.png" alt="101.png" /><br />
<img src="https://i.loli.net/2021/10/09/FdTlzUJDY9pavHR.png" alt="102.png" /><br />
<img src="https://i.loli.net/2021/10/09/I7FpuY2HUa81dTg.png" alt="103.png" /></p>
]]></content>
      <categories>
        <category>形式语言与自动机</category>
      </categories>
  </entry>
  <entry>
    <title>第一章 数据库简介</title>
    <url>/2021/03/26/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter1%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第一章-数据库简介"><a class="markdownIt-Anchor" href="#第一章-数据库简介"></a> 第一章 数据库简介</h2>
<h3 id="12传统的基于文件的系统"><a class="markdownIt-Anchor" href="#12传统的基于文件的系统"></a> 1.2传统的基于文件的系统</h3>
<h4 id="122-基于文件方法的局限性"><a class="markdownIt-Anchor" href="#122-基于文件方法的局限性"></a> 1.2.2 基于文件方法的局限性</h4>
<a id="more"></a>
<ul>
<li>
<p>数据分离和孤立</p>
</li>
<li>
<p>数据冗余</p>
</li>
<li>
<p>数据依赖</p>
</li>
<li>
<p>文件不兼容、固定查询/增殖的应用程序</p>
</li>
</ul>
<h3 id="13-数据库方法"><a class="markdownIt-Anchor" href="#13-数据库方法"></a> 1.3 数据库方法</h3>
<h4 id="131-数据库"><a class="markdownIt-Anchor" href="#131-数据库"></a> 1.3.1 数据库</h4>
<p><strong>|数据库|</strong>：为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集。</p>
<h4 id="132-数据库管理系统dbms"><a class="markdownIt-Anchor" href="#132-数据库管理系统dbms"></a> 1.3.2 数据库管理系统(DBMS)</h4>
<p><strong>|DBMS|</strong>:一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统</p>
<p>DBMS = DDL + DML</p>
<ul>
<li>Data Definition Language：指定数据类型、数据结构，约束数据</li>
<li>Data Manipulation Language(DML)：Insert, update, delete, retrieve数据</li>
</ul>
<p>与基于文件的系统相比，数据的物理结构和存储是由DBMS控制的</p>
<h4 id="133-数据库应用程序"><a class="markdownIt-Anchor" href="#133-数据库应用程序"></a> 1.3.3 （数据库）应用程序</h4>
<p><strong>|应用程序|</strong>：通过向DBMS提出合适的请求(通常是一个SQL语句)而与数据库交互作用的计算机程序</p>
<p><strong>视图</strong></p>
<ul>
<li>视图提供了一个保密级别。</li>
<li>视图有助于提高数据独立性——当基本数据库改变时，视图可能不变。</li>
</ul>
<h4 id="134-dbms环境的组成部分"><a class="markdownIt-Anchor" href="#134-dbms环境的组成部分"></a> 1.3.4 DBMS环境的组成部分</h4>
<img src="https://i.loli.net/2021/05/05/mCYNRD1B7yhkJMr.png" alt="1.png" style="zoom:80%;" />
<p><strong>硬件</strong>：硬件支撑DBMS和应用的运行，它可以是一台PC机或是多台计算机连接的网络。</p>
<p><strong>软件</strong>：软件包含DBMS软件本身以及应用程序和操作系统。</p>
<p><strong>数据</strong>：数据是原始事务的集合。数据在机器和人中间起到了桥梁作用。数据库同时包含了操作数据和元数据，数据库结构称为模式。</p>
<p><strong>过程</strong>：过程是对数据库的设计和使用进行控制的一组命令和规则。</p>
<p><strong>人</strong>：可以是DA、DBA、数据库设计人员、应用开发人员和终端用户。他们收集数据，把它们编成程序并使用。</p>
<h3 id="14-数据库环境中的各种角色"><a class="markdownIt-Anchor" href="#14-数据库环境中的各种角色"></a> 1.4 数据库环境中的各种角色</h3>
<h4 id="141-da和dba"><a class="markdownIt-Anchor" href="#141-da和dba"></a> 1.4.1 DA和DBA</h4>
<p><strong>DA</strong>：管理数据资源，数据库规划，概念/逻辑数据库设计</p>
<p><strong>DBA</strong>：数据库的物理实现，包括物理数据库设计和实现、安全性和完整性控制</p>
<h4 id="142-数据库设计人员"><a class="markdownIt-Anchor" href="#142-数据库设计人员"></a> 1.4.2 数据库设计人员</h4>
<p><strong>逻辑数据库设计人员</strong>：负责标识数据、数据之间的联系、对将存储到数据库的数据的约束。概念数据库设计、逻辑数据库设计(例：员工不能管理超过10处房产)</p>
<p><strong>物理数据库设计人员</strong>：将逻辑数据库设计映射为一组表和一组完整性约束；选择特定的数据存储结构来得到最佳性能</p>
<h3 id="16-dbms的优点和缺点"><a class="markdownIt-Anchor" href="#16-dbms的优点和缺点"></a> 1.6 DBMS的优点和缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>
<p>受控的数据冗余</p>
</li>
<li>
<p>数据一致性</p>
</li>
<li>
<p>数据共享</p>
</li>
<li>
<p>增强的数据完整性</p>
</li>
<li>
<p>增强的安全性</p>
</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>复杂性</li>
<li>DBMS的费用</li>
<li>性能相对较低</li>
<li>故障带来的影响较大</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<p><img src="https://i.loli.net/2021/05/05/l6oGHxIXvCFqasB.png" alt="2.png" /></p>
<ol>
<li>
<p>a)数据是原始事务的集合</p>
<p>b)数据库是为满足某个组织机构的信息要求而设计的一个逻辑相关数据及其描述的共享集</p>
<p>c)一个支持用户对数据库进行定义、创建、维护及控制访问的软件系统</p>
<p>d)数据独立性是对数据库模式中较低层的修改不会对较高层产生影响。有两种数据独立性，物理数据独立性和逻辑数据独立性</p>
</li>
<li>
<p>数据方法的特性有数据独立性、受控的数据冗余、数据共享、数据完整性和安全性。而基于文件的方法则有数据被分离与孤立、数据冗余、数据依赖、文件格式不相容、固定查询/应用程序需不断翻新的缺点。</p>
</li>
<li>
<p><strong>硬件</strong>：硬件支撑DBMS和应用的运行，它可以是一台PC机或是多台计算机连接的网络。</p>
</li>
</ol>
<p><strong>软件</strong>：软件包含DBMS软件本身以及应用程序和操作系统。</p>
<p><strong>数据</strong>：数据是原始事务的集合。数据在机器和人中间起到了桥梁作用。数据库同时包含了操作数据和元数据，数据库结构称为模式。</p>
<p><strong>过程</strong>：过程是对数据库的设计和使用进行控制的一组命令和规则。</p>
<p><strong>人</strong>：可以是DA、DBA、数据库设计人员、应用开发人员和终端用户。他们收集数据，把它们编成程序并使用。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第十一章 查询处理</title>
    <url>/2021/06/17/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter11%20%E6%9F%A5%E8%AF%A2%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十一章-查询处理"><a class="markdownIt-Anchor" href="#第十一章-查询处理"></a> 第十一章 查询处理</h2>
<a id="more"></a>
<p>本章大部分内容cv自wht同学的笔记</p>
<h3 id="111-查询处理概述"><a class="markdownIt-Anchor" href="#111-查询处理概述"></a> 11.1 查询处理概述</h3>
<p><strong>|查询处理|</strong>：包括语法分析、正确性验证、查询优化以及查询执行等活动。</p>
<p><strong>|查询优化|</strong>：为查询处理选择一个高效的执行策略。通常采取的策略是寻找一种近似最优解。</p>
<h4 id="查询处理的四个主要阶段"><a class="markdownIt-Anchor" href="#查询处理的四个主要阶段"></a> 查询处理的四个主要阶段</h4>
<ul>
<li>分解</li>
<li>优化</li>
<li>代码生成</li>
<li>代码执行</li>
</ul>
<img src="https://i.loli.net/2021/06/18/4RMXLsxbjO6Tn1g.png" alt="1.png" style="zoom:67%;" />
<h3 id="112-查询解析"><a class="markdownIt-Anchor" href="#112-查询解析"></a> 11.2 查询解析</h3>
<p><strong>step 1 验证语法是否正确，若否，拒绝执行</strong></p>
<p><strong>step 2 创建查询树：</strong></p>
<ul>
<li>为查询中的每一个基础关系创建一个叶子节点</li>
<li>为每个关系代数运算产生的中间关系创建一个非叶子节点</li>
<li>最终查询结构作为根节点，连接各个节点</li>
<li>这样就形成了关系代数查询树 relational algebra tree，语句的运算按照从叶到根的顺序执行</li>
</ul>
<p><strong>step 3 规范化</strong> 将表达式里的谓词（SQL中的WHERE子句）转换为以下两种范式之一：</p>
<ul>
<li>合取范式 (a ∧ b) ∨ (c ∧ d) ∨ …</li>
<li>析取范式 (a ∨ b) ∧ (c ∨ d) ∧ …</li>
</ul>
<p>**step 4 语义分析：**判断是否有自相矛盾的谓词，简化它们为True或False</p>
<p>**step 5 化简：**检测冗余条件，去除公共子表达式</p>
<h3 id="113-查询优化"><a class="markdownIt-Anchor" href="#113-查询优化"></a> 11.3 查询优化</h3>
<p>查询优化的目标：选择资源占用最少的等价查询形式，资源占用最少可以从<strong>所有运算执行时间的总和</strong>或<strong>查询的响应时间</strong>方面来量化。</p>
<h3 id="114-关系代数运算的转换规则"><a class="markdownIt-Anchor" href="#114-关系代数运算的转换规则"></a> 11.4 关系代数运算的转换规则</h3>
<ol>
<li>串联式规则，合取选择运算转换为单个选择的运算的串联</li>
<li>交换选择运算的顺序</li>
<li>投影运算的串联与只执行最后一个投影运算等价</li>
<li>选择运算和投影运算的交换律（谓词相同的情况下）</li>
<li>θ连接/笛卡尔积运算的交换律、结合律</li>
<li>选择运算和θ连接/笛卡尔积运算的分配律</li>
<li>投影运算和θ连接/笛卡尔积运算的分配律</li>
<li>交运算和并运算的交换律、结合律</li>
<li>选择运算和交/并/差运算的分配律</li>
<li>投影运算和并运算的分配律</li>
</ol>
<h3 id="115-启发式heuristic处理策略"><a class="markdownIt-Anchor" href="#115-启发式heuristic处理策略"></a> 11.5 启发式(Heuristic)处理策略</h3>
<ol>
<li>尽早执行选择运算和投影运算</li>
<li>合并笛卡尔积运算和其后的选择运算为连接运算</li>
<li>利用二元运算的结合律对叶子节点进行重排序，条件越严格的选择运算，越先执行</li>
<li>如果有公共表达式在计算中多次出现，只执行一次其值的计算</li>
</ol>
<h3 id="116-关系代数运算的代价估计"><a class="markdownIt-Anchor" href="#116-关系代数运算的代价估计"></a> 11.6 关系代数运算的代价估计</h3>
<p>前提：DBMS知道数据库的统计信息，即其中数据的规模<br />
参数：R-关系，A-属性，I-索引<br />
数据库的统计信息包含三类：（DBMS应周期性更新这些数据）</p>
<p><strong>基本关系统计信息</strong></p>
<ul>
<li>nTuples® ：关系R的元组数目（R的基数）</li>
<li>bFactor® ：关系R的块因子blocking factor，即一块可以存储R中元组的个数</li>
<li>nBlocks®：存储关系R需要的块数，即以上两个参数之商</li>
</ul>
<p><strong>关系中的属性的统计信息</strong></p>
<ul>
<li>nDistinct(A,R)：属性A在关系R中不同取值的个数</li>
<li>min(A,R)/max(A,R)：属性A在R中的可能最小值/最大值</li>
<li>SC(A,R)：属性A在关系R中的选择基数selection cardinality，即满足属性A的某个等值条件的平均元组个数，这需要DBMS根据实际情况估算</li>
</ul>
<p><strong>属性上多级索引的统计信息</strong></p>
<ul>
<li>nLevels(A,I)：I的索引级数</li>
<li>nLfBlocks(A,I)：I中叶子的块数</li>
</ul>
<p>通过这些数据，以及DBMS在各种关系运算操作中使用的算法，即可估算不同算法的运算代价的相对值</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第十章 事务管理</title>
    <url>/2021/06/09/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter10%20%E4%BA%8B%E5%8A%A1%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十章-事务管理"><a class="markdownIt-Anchor" href="#第十章-事务管理"></a> 第十章 事务管理</h2>
<p>数据库四大特性：一致、可靠、完整、安全</p>
<a id="more"></a>
<h3 id="101-事务支持"><a class="markdownIt-Anchor" href="#101-事务支持"></a> 10.1 事务支持</h3>
<p><strong>|事务|</strong>：由单个用户或者应用程序执行时，完成读取或者更新数据库内容的一个或者一串操作。</p>
<ul>
<li>事务是数据库的逻辑操作单位。</li>
<li>从数据库的角度看，应用程序的一次执行就是一个事务或者多个事务，在事务与事物之间只会出现非数据库操作(salary = salary * 1.1)。</li>
<li>事务应该总能将数据库从一种一致的状态转换到另一种一致的状态。</li>
</ul>
<p>已提交的事务不能被撤销，只能执行另一个补偿事务来消除影响。</p>
<p><img src="https://i.loli.net/2021/06/05/jTWxQh3yamHDbUt.png" alt="1.png" /></p>
<p>部分提交：最后一条语句执行后，处于部分提交状态。</p>
<h4 id="1011-事务的性质"><a class="markdownIt-Anchor" href="#1011-事务的性质"></a> 10.1.1 事务的性质</h4>
<p>事务应该具有四个基本性质(<strong>ACID</strong>)</p>
<ul>
<li>原子性：事务是一个不可分割的单元，要么全部执行，要么都不执行。</li>
<li>一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。</li>
<li>隔离性：事物的执行是相互独立的。未完成事务的中间结果对其他事务来说应该是不可见的。</li>
<li>持久性：成功提交的事务结果要永远地记录在数据库中，不能因为以后的故障而丢失。</li>
</ul>
<h4 id="1012-数据库体系结构"><a class="markdownIt-Anchor" href="#1012-数据库体系结构"></a> 10.1.2 数据库体系结构</h4>
<p><img src="https://i.loli.net/2021/06/05/qlWPD1w8TgeGxzb.png" alt="2.png" /></p>
<h3 id="102-并发控制"><a class="markdownIt-Anchor" href="#102-并发控制"></a> 10.2 并发控制</h3>
<p><strong>|并发控制|</strong>：管理数据库上的并发操作以使之互不冲突的过程。</p>
<h4 id="1021-并发控制的必要性"><a class="markdownIt-Anchor" href="#1021-并发控制的必要性"></a> 10.2.1 并发控制的必要性</h4>
<ul>
<li>阻止两个或更多用户同时访问数据库，并且至少有一个执行更新操作时的相互干扰。</li>
<li>虽然两个事务各自执行时是完全正确的，但操作的重叠可能产生不正确的结果。</li>
<li>三种可能导致的问题：
<ul>
<li>丢失更新问题</li>
<li>未提交依赖（脏读）问题</li>
<li>不一致分析（不可重复读）问题</li>
</ul>
</li>
</ul>
<p><strong>丢失更新问题</strong></p>
<p>一个用户的更新操作已经完成，但是结果却被另一个用户的操作结果取代了。</p>
<p><strong>未提交依赖问题</strong></p>
<p>如果允许一个事务看到另外一个未提交事务的中间结果，则会出现未提交依赖问题。</p>
<p><strong>不一致分析问题</strong></p>
<p>当某事物正从数据库中读取多个数据的值，但另一个事务却在其读取过程中修改了其中某些数据的值，就会出现不一致分析问题。</p>
<hr />
<p><strong>脏读</strong></p>
<p>脏读是指一个事务读取到其他事务没有提交的数据。</p>
<p><strong>不可重复读</strong></p>
<p>不可重复读是指一个事务内多次根据同一查询条件查询出来的同一行记录的值不一致。</p>
<p><strong>幻读</strong></p>
<p>幻读是指一个事务内多次根据同一条件查询出来的记录行数不一致。</p>
<h4 id="1022-可串行性与可恢复性"><a class="markdownIt-Anchor" href="#1022-可串行性与可恢复性"></a> 10.2.2 可串行性与可恢复性</h4>
<p><strong>|调度|</strong>：一组并发事务操作的序列，对于其中每个事务来说，该序列保留了该事务的所有操作的先后次序。</p>
<p><strong>|串行调度|</strong>：每一个事务的操作都按顺序执行且各事务之间的操作没有任何交叉的调度。</p>
<p><strong>|非串行调度|</strong>：一组并发事务的操作相互交叉执行的调度。</p>
<p><strong>|可串行化|</strong>：如果一组事务并发执行，当且仅当（非串行）调度能够产生和某些串行执行相同的结果时，调度才是正确的。</p>
<ul>
<li>两个事务读同一个数据项</li>
<li>两个事务读写不同数据项</li>
<li>两个事务读写同一个数据项（需要调度）</li>
</ul>
<p>冲突可串行化的检测：wait-for graph</p>
<p><strong>|可恢复调度|</strong>：如果T<sub>j</sub>读取了由T<sub>i</sub>修改过的数据项，那么事务T<sub>i</sub>的提交操作应该在事务T<sub>j</sub>的提交操作之前。若调度中的每一对事务T<sub>i</sub>和T<sub>j</sub>都能满足上述要求，则改调度称为可恢复调度。</p>
<h4 id="1023-加锁方法"><a class="markdownIt-Anchor" href="#1023-加锁方法"></a> 10.2.3 加锁方法</h4>
<p><strong>|加锁|</strong>：用来控制并发访问数据的过程。当一个事务正在访问数据库时，可以用锁拒绝其他事务的访问请求，从而避免产生不正确的结果。</p>
<p><strong>|共享锁|</strong>：读锁。</p>
<p><strong>|互斥锁|</strong>：写锁。</p>
<p><strong>|2PL(Two-phase locking)|</strong>：如果事务中所有的加锁操作都出现在第一个解锁操作之前，则该事务是遵循两段锁协议的。</p>
<ul>
<li>事务在对数据项进行操作之前，必须先获得该数据项的锁。根据访问的类型需要，可以是读锁或者写锁。</li>
<li>一旦事务开始释放锁，它就不能再获得任何新锁。</li>
</ul>
<p><strong>级联回滚</strong></p>
<p>若T<sub>14</sub>回滚，则T<sub>15</sub>、T<sub>16</sub>均需回滚</p>
<p><img src="https://i.loli.net/2021/06/05/P5ZI9vcCRfTGqbU.png" alt="3.png" /></p>
<p>严格2PL(rigorous 2PL)：直到事物的最后才释放所有的锁。</p>
<p>弱严格2PL(strict 2PL): 只要求互斥锁到事务的最后再释放。</p>
<h4 id="1024-死锁"><a class="markdownIt-Anchor" href="#1024-死锁"></a> 10.2.4 死锁</h4>
<p><strong>|死锁|</strong>：当两个（或多个）事务互相等待对方释放自己已经占有的锁时产生的僵局。</p>
<p><strong>死锁处理技术</strong></p>
<ul>
<li>
<p>超时</p>
</li>
<li>
<p>死锁预防</p>
</li>
<li>
<p>死锁检测和恢复</p>
<ul>
<li>
<p>wait-for graph</p>
<p>如果事务T<sub>i</sub>等待T<sub>j</sub>的锁，则创建一条有向边T<sub>i</sub>→T<sub>j</sub></p>
</li>
<li>
<p>周期性检测</p>
</li>
</ul>
</li>
</ul>
<h4 id="1025-时间戳方法"><a class="markdownIt-Anchor" href="#1025-时间戳方法"></a> 10.2.5 时间戳方法</h4>
<p><strong>|时间戳|</strong>：由DBMS创建的、标识事务的相对启动时间的、具有唯一性的标识符。</p>
<p><strong>|时间戳技术|</strong>：一种并发控制协议，它用以下方式确定事务的顺序——越早的事务，时间戳越小，在发生冲突时优先级更高。</p>
<ul>
<li>
<p>采用时间戳技术时，如果某事务要读或写一个数据项，则只有当该数据项最近的修改是由一个较早的事务执行时，才允许该事务进行读或写。</p>
</li>
<li>
<p>否则，请求读写的事务将被赋予一个新的时间戳后重启。</p>
</li>
<li>
<p>除了事务可以有时间戳，数据项也可以有读写时间戳。</p>
</li>
</ul>
<p>例：</p>
<ol>
<li>事务T发出写请求write(x)</li>
<li>事务T要求读或写数据项(x)，而该数据项已被一个较新的事务取代，即ts(T)&lt;read_ts(x)。将T回滚并用一个新的时间戳重启。</li>
<li>否则，写操作可以被执行，write_ts(x) = ts(T)</li>
</ol>
<p><img src="https://i.loli.net/2021/06/05/5McwHBs9OVRjGWE.png" alt="4.png" /></p>
<p><strong>托马斯写规则</strong></p>
<p>放宽对冲突可串行化的要求，拒绝过时的写操作以获得更高的并行性。</p>
<ol>
<li>事务T发出写请求write(x)</li>
<li>该数据项被一个较新的事务读过，即ts(T)&lt;read_ts(x)，则重启T。</li>
<li>该数据项被一个较新的事务写过，即ts(T)&lt;write_ts(x)，则忽略T。</li>
</ol>
<h4 id="1026-数据项的粒度"><a class="markdownIt-Anchor" href="#1026-数据项的粒度"></a> 10.2.6 数据项的粒度</h4>
<p><strong>|粒度|</strong>：受到保护的数据项的大小，是并发控制协议中受到保护的基本单位。</p>
<p>粗粒度：整个数据库、一个文件、一页、一条记录、记录的一个字段的值</p>
<p><strong>粒度的层次</strong></p>
<p>当一个节点被加锁时，其所有的子孙节点都被锁住。</p>
<p><strong>意向锁</strong></p>
<p>当一个节点被加锁时，该节点的所有祖先节点就都被加了意向锁。</p>
<p>意向锁可以是共享的(IS)或互斥的(IX)或共享意向互斥(SIX)。</p>
<p><img src="https://i.loli.net/2021/06/05/ITajJk179Fc68bR.png" alt="5.png" /></p>
<h3 id="103-数据库恢复"><a class="markdownIt-Anchor" href="#103-数据库恢复"></a> 10.3 数据库恢复</h3>
<p><strong>|数据库恢复|</strong>：在发生故障时，将数据库还原到正确状态的过程。</p>
<h4 id="1031-恢复的必要性"><a class="markdownIt-Anchor" href="#1031-恢复的必要性"></a> 10.3.1 恢复的必要性</h4>
<ul>
<li>主存：易失性存储器，若系统崩溃则数据全失。</li>
<li>磁盘：联机非易失存储器。</li>
<li>磁带：非联机非易失存储。</li>
<li>光盘：非易失性存储器。</li>
</ul>
<p><strong>|稳定存储|</strong>：已被复制到许多非易失性的、具有独立故障模式的存储介质（通常指磁盘）上的信息。</p>
<h4 id="1032-事务和恢复"><a class="markdownIt-Anchor" href="#1032-事务和恢复"></a> 10.3.2 事务和恢复</h4>
<p>事务是数据库系统进行恢复的基本单位。故障发生时，由恢复管理器负责保证事务ACID特性中的原子性和持久性。</p>
<p>数据库缓冲区位于内存，用于在内存和二级存储器之间传递数据。只有缓冲区中的数据被刷新到二级存储器中，更新操作才能被看作是永久的。缓冲区到二级存储器的显示写被称为强制写(force-writing)。</p>
<ul>
<li>如果写了没提交——<strong>redo</strong></li>
<li>如果提交了没写——<strong>undo</strong>
<ul>
<li>部分撤销：只有一个事务需要被撤销</li>
<li>全局撤销</li>
</ul>
</li>
</ul>
<p><strong>偷窃策略</strong></p>
<p>允许缓冲区管理器在事务提交前将缓冲区写回磁盘。对应非偷窃策略。</p>
<p>——不用undo<br />
<strong>强制策略</strong></p>
<p>保证在事务提交时，事务更新的所有页立即被写回磁盘。对应非强制策略。</p>
<p>——不用redo</p>
<h4 id="1033-恢复机制"><a class="markdownIt-Anchor" href="#1033-恢复机制"></a> 10.3.3 恢复机制</h4>
<ul>
<li>备份机制</li>
<li>日志机制</li>
<li>检查点机制</li>
<li>恢复管理器</li>
</ul>
<p><strong>备份机制</strong></p>
<p>定期备份数据库和日志文件。</p>
<p><strong>日志文件</strong></p>
<p>记录对数据库更新的所有操作。</p>
<ul>
<li>
<p>事务记录</p>
<p>标识符、类型(增删改查)、数据项前像、后像、日志管理信息</p>
</li>
<li>
<p>检查点记录</p>
</li>
</ul>
<p><img src="https://i.loli.net/2021/06/13/S6ou15RiCZFJlqx.png" alt="6.png" /></p>
<p>日志需要被两倍或三倍地复制(RAID)。</p>
<p>某些情况下，不可能总是将所有日志信息联机保存。一种处理日志文件脱机存储的方法是，将联机的日志文件分成两个独立的随机访问文件。日志记录被写入第一个文件，直到到达某个阈值，如70%。然后打开第二个文件，关闭第一个文件并写道脱机存储介质上。</p>
<p><strong>检查点</strong></p>
<p><strong>|检查点|</strong>：数据库与事务日志文件之间的同步点，在该点上所有的缓冲区都被强制写到二级存储器。</p>
<ul>
<li>将内存中所有日志记录写到二级存储器。</li>
<li>将数据库缓冲区所有被修改过的块写到二级存储器。</li>
<li>将一个检查点记录写到日志文件。该记录包含所有在检查点时刻活跃事务的标识符。</li>
</ul>
<h4 id="1034-恢复技术"><a class="markdownIt-Anchor" href="#1034-恢复技术"></a> 10.3.4 恢复技术</h4>
<ul>
<li>
<p>如果数据库遭到严重损毁——备份</p>
</li>
<li>
<p>如果数据库只是处于不一致状态——日志</p>
<p>使用日志文件中的前像和后像</p>
</li>
</ul>
<p>三种主要恢复技术：延迟(<strong>deferred</strong>)修改、立即修改、影页</p>
<p><strong>延迟修改</strong></p>
<p>直到事务提交以后，修改结果才会被写到数据库。</p>
<ul>
<li>事务启动，向日志写入事务启动记录</li>
<li>执行写操作，写入日志，不写入数据库缓冲区</li>
<li>提交前，写入事务提交记录，先将该事务所有日志写到磁盘，然后提交</li>
<li>根据日志完成对数据库的更新</li>
<li>如果事务被从撤销则忽略该事务的日志，不执行写操作</li>
</ul>
<p>如果发生了故障，根据日志对事务进行撤销或重做：</p>
<ul>
<li>redo所有出现了事务开始和事务提交日志记录的事务。</li>
<li>对所有出现你了事务开始和事务撤销日志记录的事务，不执行操作。因为这些事务并没有对数据库执行真正的写操作。</li>
</ul>
<p><strong>立即修改</strong></p>
<p>更新一旦发生就被施加到数据库，而无需等到提交时刻。</p>
<ul>
<li>事务启动，向日志写入事务启动记录</li>
<li>写入日志</li>
<li>写入数据库缓冲区</li>
<li>在下一次将缓冲区内容刷新到二级存储器时更新数据库</li>
<li>提交，向日志写入事务提交记录</li>
</ul>
<p>在事务的操作结果被写入数据库之前就先将日志记录写入数据库被称为<strong>先写日志协议</strong>。</p>
<p>如果发生了故障，根据日志对事务进行撤销或重做：</p>
<ul>
<li>redo所有事务开始和事务提交记录日志的事务</li>
<li>undo仅包含事务开始记录日志的事务</li>
</ul>
<p><strong>影像页(shadow paging)技术</strong></p>
<p>在事务的生存期中维持了两张页表：当前页表和影像页表。</p>
<p>事务启动时，两张页表相同，事务执行时，当前页表用于记录数据库的所有更新，影像页表用于恢复。事务完成时，当前页表转变为影像页表。</p>
<p><strong>Advantage</strong></p>
<ul>
<li>没有维持日志文件的开销</li>
<li>无需redo和undo，恢复速度更快</li>
</ul>
<p><strong>Disadvantage</strong></p>
<ul>
<li>
<p>数据分裂</p>
</li>
<li>
<p>周期性地进行无用单元回收（垃圾回收机制），开销大</p>
</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>Explain what is meant by a transaction.</p>
<p>由单个用户或者应用程序执行时，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位。事务应该总能将数据库从一种一致的状态转换到另一种一致的状态。事务要么就全执行，要么就应该被撤销。</p>
</li>
<li>
<p>The consistency and reliability aspects of transactions are due to the ‘ACIDity’ properties of transactions. Discuss each of these properties and how they relate to the concurrency control and recovery mechanisms. Give examples to illustrate your answer.</p>
<ul>
<li>原子性：事务是一个不可分割的单元，要么全部执行，要么都不执行。</li>
<li>一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。</li>
<li>隔离性：事物的执行是相互独立的。未完成事务的中间结果对其他事务来说应该是不可见的。</li>
<li>持久性：成功提交的事务结果要永远地记录在数据库中，不能因为以后的故障而丢失。</li>
</ul>
<p>一致性和隔离性确保数据库一致，并且不会有事务产生的错误。原子性和持久性确保数据库中的数据在任何时候都是可靠的。原子性和持久性是由恢复子系统负责保证的，隔离性和一致性是由并发控制子系统负责保证的。</p>
<p>自己举例吧，懒得打表格~~</p>
</li>
<li>
<p>Describe, with examples, the types of problem that can occur in a multi-user environment when concurrent access to the database is allowed.</p>
<p>三种类型的问题：丢失更新、未提交依赖、不一致分析，自己举例吧~~</p>
</li>
<li>
<p>Explain the concepts of serial, nonserial, and schedules.</p>
<p><strong>|调度|</strong>：一组并发事务操作的序列，对于其中每个事务来说，该序列保留了该事务的所有操作的先后次序。</p>
<p><strong>|串行调度|</strong>：每一个事务的操作都按顺序执行且各事务之间的操作没有任何交叉的调度。</p>
<p><strong>|非串行调度|</strong>：一组并发事务的操作相互交叉执行的调度。</p>
</li>
<li>
<p>Discuss the types of problem that can occur with locking-based mechanisms for concurrency control and the actions that can be taken by a DBMS to prevent them.</p>
<p>不能保证事务的可串行性，可能会导致数据不一致。有可能产生级联回滚。有可能会发生死锁和无限等待。</p>
</li>
<li>
<p>What is a timestamp?</p>
<p><strong>|时间戳|</strong>：由DBMS创建的、标识事务的相对启动时间的、具有唯一性的标识符。</p>
<p><strong>|时间戳技术|</strong>：一种并发控制协议，它用以下方式确定事务的顺序——越早的事务，时间戳越小，在发生冲突时优先级更高。</p>
<ul>
<li>
<p>采用时间戳技术时，如果某事务要读或写一个数据项，则只有当该数据项最近的修改是由一个较早的事务执行时，才允许该事务进行读或写。</p>
</li>
<li>
<p>否则，请求读写的事务将被赋予一个新的时间戳后重启。</p>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第十二章 数据库的安全性</title>
    <url>/2021/06/18/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter12%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84%E5%AE%89%E5%85%A8%E6%80%A7/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第十二章-数据库的安全性"><a class="markdownIt-Anchor" href="#第十二章-数据库的安全性"></a> 第十二章 数据库的安全性</h2>
<a id="more"></a>
<p>本章大部分内容cv自wht同学的笔记</p>
<h3 id="121-数据库安全"><a class="markdownIt-Anchor" href="#121-数据库安全"></a> 12.1 数据库安全</h3>
<p><strong>|数据库安全|</strong>：保护数据库免受威胁的机制。</p>
<h3 id="122-威胁"><a class="markdownIt-Anchor" href="#122-威胁"></a> 12.2 威胁</h3>
<p><strong>|威胁|</strong>：任何有意或无意的，对系统或组织造成负面影响的行为或事件。</p>
<h3 id="123-对策countermeasures"><a class="markdownIt-Anchor" href="#123-对策countermeasures"></a> 12.3 对策(Countermeasures)</h3>
<h4 id="1231-授权"><a class="markdownIt-Anchor" href="#1231-授权"></a> 12.3.1 授权</h4>
<p><strong>|授权（authorization）|</strong>：授予一个主体权利或权限，使其能实现对系统或系统对象的合法访问。</p>
<p><strong>|认证(Authentication)|</strong>：确认用户身份是否属实的机制。</p>
<p><strong>|权限|</strong>：包括访问特定数据库对象（如关系、视图和索引）以及运行不同的DBMS系统实体。</p>
<h4 id="1232-视图"><a class="markdownIt-Anchor" href="#1232-视图"></a> 12.3.2 视图</h4>
<p>通过向某些用户隐藏数据库的一部分信息来限制用户</p>
<h4 id="1233-备份和恢复"><a class="markdownIt-Anchor" href="#1233-备份和恢复"></a> 12.3.3 备份和恢复</h4>
<ul>
<li>备份Backup：周期性将数据库、日志文件、DBMS程序（可选）复制到脱机存储介质上</li>
<li>日志Log：日志文件包含数据库的所有变化记录。保存并维护日志文件，使得数据库出现故障时能够有效地进行恢复</li>
</ul>
<h4 id="1234-完整性约束"><a class="markdownIt-Anchor" href="#1234-完整性约束"></a> 12.3.4 完整性约束</h4>
<ul>
<li>必须有值的数据</li>
<li>域约束</li>
<li>实体完整性</li>
<li>引用完整性</li>
<li>一般性约束</li>
</ul>
<h4 id="1235-加密encryption"><a class="markdownIt-Anchor" href="#1235-加密encryption"></a> 12.3.5 加密(Encryption)</h4>
<p>使用特定算法对数据进行编码</p>
<ul>
<li>对称加密：加密和解密密钥相同，因此密钥的交换也要保证安全性。</li>
<li>非对称加密：使用公钥和私钥，并且加密算法可以公开。RSA。</li>
</ul>
<h4 id="1236-raid方法"><a class="markdownIt-Anchor" href="#1236-raid方法"></a> 12.3.6 RAID方法</h4>
<p>对运行DBMS的硬件，尤其是磁盘驱动器，构建独立磁盘冗余阵列，保障硬件系统的安全性。</p>
<h3 id="124-访问控制"><a class="markdownIt-Anchor" href="#124-访问控制"></a> 12.4 访问控制</h3>
<p><strong>自主访问控制（DAC）</strong></p>
<p>拥有权限的用户通过GRANT和REVOKE 命令来控制用户权限</p>
<p><strong>强制访问控制（MAC）</strong></p>
<p>对数据库对象赋予安全级别（security class），并对每一个用户赋予访问许可级别（clearance）。系统根据用户的级别和访问对象的安全级别，通过特定的规则判断是否允许用户的读写操作。</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第三章 关系模型</title>
    <url>/2021/04/09/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter3%20%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第三章-关系模型"><a class="markdownIt-Anchor" href="#第三章-关系模型"></a> 第三章 关系模型</h2>
<h3 id="32-基本术语"><a class="markdownIt-Anchor" href="#32-基本术语"></a> 3.2 基本术语</h3>
<h4 id="321-关系数据结构"><a class="markdownIt-Anchor" href="#321-关系数据结构"></a> 3.2.1 关系数据结构</h4>
<a id="more"></a>
<p><strong>|关系|</strong>：关系是由行和列组成的表</p>
<p><strong>|属性|</strong>：属性是关系中命名的列</p>
<p><strong>|域|</strong>：域是一个或多个属性的取值集合</p>
<ul>
<li>每一个关系中的属性都定义着一个域</li>
</ul>
<p><strong>|元组(Tuple)|</strong>：关系中的每一行称为元组</p>
<p><strong>|维数/度(Degree)|</strong>：关系的度是指关系所包含属性的个数</p>
<p><strong>|基数(Cardinality)|</strong>：关系的基数是指它所包含元组的个数</p>
<img src="https://i.loli.net/2021/05/05/iLKf6SmTFoDuMbO.png" alt="9.png" style="zoom:80%;" />
<img src="https://i.loli.net/2021/05/05/CRZqdUh5QDz2LAe.png" alt="10.png" />
<h4 id="323-数据库中的关系"><a class="markdownIt-Anchor" href="#323-数据库中的关系"></a> 3.2.3 数据库中的关系</h4>
<p><strong>|关系模式|</strong>：由一组属性和域名对定义的命名关系</p>
<p>设属性A<sub>1</sub>, A<sub>2</sub>, …, A<sub>n</sub>对应的域分别为D<sub>1</sub>, D<sub>2</sub>, …, D<sub>n</sub>。那么，集合{A<sub>1</sub>😄<sub>1</sub>, A<sub>2</sub>D<sub>2</sub>, …, A<sub>n</sub>D<sub>n</sub>}就是一个关系模式。</p>
<p><strong>|关系模式数据库|</strong>：关系模式的集合，集合中的每个关系都应有不同的名字</p>
<h4 id="324-关系的性质"><a class="markdownIt-Anchor" href="#324-关系的性质"></a> 3.2.4 关系的性质</h4>
<ul>
<li>
<p>关系模式中各关系不能重名</p>
</li>
<li>
<p>每个属性都有不同的名字</p>
</li>
<li>
<p>属性的值都来自同一个域</p>
</li>
<li>
<p>每个元组是不同的，没有重复的元组</p>
</li>
<li>
<p>属性的顺序并不重要</p>
</li>
<li>
<p>元组的顺序并不重要</p>
</li>
</ul>
<h4 id="325-关系键"><a class="markdownIt-Anchor" href="#325-关系键"></a> 3.2.5 关系键</h4>
<p><strong>|超键|</strong>：一个属性或<strong>属性集合</strong>，它能唯一地标识出关系中的每个元组。</p>
<p><strong>|候选键|</strong>：本身是超键但其任何子集都不再是超键。</p>
<p><strong>|主键|</strong>：被选用于唯一标识关系中各元组的候选键。</p>
<p><strong>|外部关键字|</strong>：当一个关系中的某个属性或属性集合与另一个关系（也可能就是自己）的候选键匹配时，就称这个属性或属性集合为外键。</p>
<h3 id="33-完整性约束"><a class="markdownIt-Anchor" href="#33-完整性约束"></a> 3.3 完整性约束</h3>
<p>关系数据模型有三个组成部分：数据结构、数据管理和完整性约束</p>
<h4 id="331-空"><a class="markdownIt-Anchor" href="#331-空"></a> 3.3.1 空</h4>
<p><strong>|空|</strong>：代表对一个元组当前取值还不知道或是不可用的属性值</p>
<h4 id="332-实体完整性"><a class="markdownIt-Anchor" href="#332-实体完整性"></a> 3.3.2 实体完整性</h4>
<p><strong>|实体完整性|</strong>：在基本关系中，主键的属性不能为空</p>
<p>针对基关系</p>
<ul>
<li>基关系：table	定义 + 数据</li>
<li>非基关系
<ul>
<li>view	定义</li>
<li>select    X</li>
</ul>
</li>
</ul>
<h4 id="333-参考完整性"><a class="markdownIt-Anchor" href="#333-参考完整性"></a> 3.3.3 参考完整性</h4>
<p><strong>|参考完整性|</strong>：如果在关系中存在某个外部关键字，则它的值或与主关系中某个元组的候选键取值相等，或者全为空</p>
<h4 id="334-用户完整性"><a class="markdownIt-Anchor" href="#334-用户完整性"></a> 3.3.4 用户完整性</h4>
<p><strong>|用户完整性|</strong>：由数据库用户或数据库管理员所指定的附加规则，它约束企业的某些方面。</p>
<h3 id="34-视图"><a class="markdownIt-Anchor" href="#34-视图"></a> 3.4 视图</h3>
<p>视图不完全是用户看到的外部模型，它指虚关系或导出关系，即无需单独存在，必要时可从一或多个基本关系中动态地将其导出。</p>
<h4 id="341-术语"><a class="markdownIt-Anchor" href="#341-术语"></a> 3.4.1 术语</h4>
<p><strong>|视图|</strong>：对一个或多个基本关系进行关系操作的得到的动态结果。视图是一个无需存在于数据库当中，但却可以根据某个特定用户需要在必要时在生成的虚关系。</p>
<h4 id="342-视图的用途"><a class="markdownIt-Anchor" href="#342-视图的用途"></a> 3.4.2 视图的用途</h4>
<ul>
<li>通过对特定用户隐藏部分数据库信息，提供了一个强大而灵活的安全机制。</li>
<li>允许用户根据自己的需求自定义访问数据的方法，因此不同的用户可以通过不同的途径同时看到相同的数据。</li>
<li>可以简化对基本关系的复杂操作。</li>
</ul>
<h4 id="343-视图的更新"><a class="markdownIt-Anchor" href="#343-视图的更新"></a> 3.4.3 视图的更新</h4>
<p>对某个基本关系的所有更新应该立即反应到涉及这个基本关系的视图中。</p>
<ul>
<li>如果视图由一个基本关系的简单查询生成，而且它还包含了基本关系中的主键或是候选键，则可以通过这个视图进行更新操作。</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<img src="https://i.loli.net/2021/05/05/ui3tyzSAe8Rrn7q.png" alt="11.png" style="zoom:80%;" />
<ol>
<li>a) 关系是由行和列组成的表</li>
</ol>
<p>b) 域是一个或多个属性的取值集合</p>
<p>c) 属性是关系中命名的列</p>
<p>d) 关系中的每一行称为元组</p>
<p>e) 本身是超键但其任何子集都不再是超键是候选键</p>
<p>f) 被选用于唯一标识关系中各元组的候选键。</p>
<p>g) 当一个关系中的某个属性或属性集合与另一个关系的候选键匹配时，就称这个属性或属性集合为外键。</p>
<ol start="2">
<li></li>
</ol>
<ul>
<li>
<p>关系模式中各关系不能重名</p>
</li>
<li>
<p>每个属性都有不同的名字</p>
</li>
<li>
<p>属性的值都来自同一个域</p>
</li>
<li>
<p>每个元组是不同的，没有重复的元组</p>
</li>
<li>
<p>属性的顺序并不重要</p>
</li>
<li>
<p>元组的顺序并不重要</p>
</li>
</ul>
<ol start="3">
<li>
<p>当一个关系中的某个属性或属性集合与另一个关系的候选键匹配时，就称这个属性或属性集合为外键。与其他关系的候选键的属性相匹配的就是外键。例如</p>
<p>Branch</p>
<p>BranchNo street</p>
<p>Staff</p>
<p>staffNo BranchNo</p>
<p>Staff表中的BranchNo与Branch表中的BranchNo相匹配，就是外键</p>
</li>
<li>
<p>视图是对一个或多个基本关系进行关系操作的得到的动态结果。视图是一个无需存在于数据库当中，但却可以根据某个特定用户需要在必要时再生成的虚关系。与基本关系相比，视图是一个虚关系，从基本关系中导出得到。视图用于提供安全机制，而基本关系无法提供。基本关系有定义和数据，而视图只有定义没有数据。</p>
</li>
<li>
<p>hotelNo和guestNo是模式中的外键，hotelNo是Hotel表中的主键也是Room表中的外键；guestNo是Guest表中的主键也是Booking表中的外键。根据实体完整性规则，主键中的属性不能为空，如hotelNo, roomNo不能为空。根据引用完整性规则，Booking表中的HotelNo与Hotel表中的hotelNo相匹配，因此Booking表中的HotelNo的取值应在Hotel表中的hotelNo属性的域内。guestNo也与之类似。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第二章 数据库环境</title>
    <url>/2021/04/02/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter2%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第二章-数据库环境"><a class="markdownIt-Anchor" href="#第二章-数据库环境"></a> 第二章 数据库环境</h2>
<h3 id="21-ansi-sparc三层体系结构"><a class="markdownIt-Anchor" href="#21-ansi-sparc三层体系结构"></a> 2.1 ANSI-SPARC三层体系结构</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/05/05/tiply8ef9kZP4SJ.png" alt="3.png" /></p>
<p>用户从外部层观察数据，DBMS和OS从内部层观察数据。概念层提供内、外部层的映射和必要的独立性。</p>
<ul>
<li>每个用户都能访问相同数据，但可用各自定制的数据视图。</li>
<li>用户与数据库的交互应该独立与存储细节</li>
<li>DBA能在不影响用户视图的情况下修改数据库存储结构</li>
<li>数据库的内部结构不受存储的物理变化影响，例如转移数据</li>
<li>DBA能在不影响所有用户的情况下修改数据库的概念结构</li>
</ul>
<h4 id="211-外部层"><a class="markdownIt-Anchor" href="#211-外部层"></a> 2.1.1 外部层</h4>
<p><strong>|外部层|</strong>：数据库的用户视图。这一层描述与每一个用户相关的数据库部分。</p>
<ul>
<li>外部层由数据库的若干不同视图组成。</li>
<li>描述数据库中与特定用户相关的部分。</li>
</ul>
<h4 id="212-概念层"><a class="markdownIt-Anchor" href="#212-概念层"></a> 2.1.2 概念层</h4>
<p><strong>|概念层|</strong>：数据库的整体视图。这一层描述了哪些数据被存储在数据库中，以及这些数据之间的联系。</p>
<p>这一层包含DBA看到的整个数据库的逻辑结构。概念层描述:</p>
<ul>
<li>所有实体、实体的属性和实体间的联系;</li>
<li>数据的约束;</li>
<li>数据的语义信息;</li>
<li>安全性和完整性信息。</li>
</ul>
<p>例：对于实体的描述只包含属性的数据类型，以及它们的长度，但是不包括实际所占用的字节数。</p>
<h4 id="213-内部层"><a class="markdownIt-Anchor" href="#213-内部层"></a> 2.1.3 内部层</h4>
<p><strong>|内部层|</strong>：数据库在计算机上的物理表示。这一层描述数据是如何存储在数据库中的。</p>
<ul>
<li>内部层包括为了得到数据库运行时的最佳性能而采用的物理实现方法。它通过与OS的访问方法交互，完成在存储设备上存放数据等操作：
<ul>
<li>数据和索引的存储空间分配;</li>
<li>记录存储的描述(带有数据项的存储大小);</li>
<li>记录位置;</li>
<li>数据压缩与加密技术。</li>
</ul>
</li>
<li>在内部层之下有一个物理层，可以在DBMS的指导下由操作系统控制。</li>
</ul>
<h4 id="214-模式-映射和实例"><a class="markdownIt-Anchor" href="#214-模式-映射和实例"></a> 2.1.4 模式、映射和实例</h4>
<p>对数据库的整体描述成为数据库模式，在任一时间点上，数据库中的数据构成一个数据库实例。</p>
<p>外部模式：与不同的数据视图相对应。</p>
<p>概念模式：描述所有的实体、属性和联系及其上的完整性约束。</p>
<p>内部模式：内部模型的完整描述。</p>
<h4 id="215-数据独立性"><a class="markdownIt-Anchor" href="#215-数据独立性"></a> 2.1.5 数据独立性</h4>
<p><strong>|逻辑数据独立性|</strong>：逻辑数据独立性指的是外部模式不受概念模式变化的影响。</p>
<p><strong>|物理数据独立性|</strong>：物理数据独立性指的是概念模式不受内部模式变化的影响</p>
<h3 id="22-数据库语言"><a class="markdownIt-Anchor" href="#22-数据库语言"></a> 2.2 数据库语言</h3>
<p>数据库语言包括两个部分：Data Definition Language(DDL)和Data Manipulation Language(DML)，DDL用来说明数据库模式，DML用来读取和更新数据库。</p>
<h4 id="221-ddl"><a class="markdownIt-Anchor" href="#221-ddl"></a> 2.2.1 DDL</h4>
<p><strong>|DDL|</strong>：一种供DBA或用户描述和命名应用所需实体、属性和联系及其相关的完整性约束和安全约束的语言。</p>
<ul>
<li>DDL可用于定义模式或修改已存在的模式，但不能用来操作数据。</li>
</ul>
<h4 id="222-dml"><a class="markdownIt-Anchor" href="#222-dml"></a> 2.2.2 DML</h4>
<p><strong>|DML|</strong>：提供了一组基本操作，支持对数据库中存储数据进行各种处理操作的语言。</p>
<ul>
<li>增、删、改、查</li>
</ul>
<h5 id="过程化dml"><a class="markdownIt-Anchor" href="#过程化dml"></a> 过程化DML</h5>
<p><strong>|过程化DML|</strong>：要求用户既告诉系统需要什么数据又说明如何检索这些数据的语言。</p>
<h5 id="非过程化dml"><a class="markdownIt-Anchor" href="#非过程化dml"></a> 非过程化DML</h5>
<p><strong>|非过程化DML|</strong>：只要求用户告诉系统需要哪些数据而不需说明如何检索它们的语言。也成为说明性语言。</p>
<h3 id="23-数据模型和概念建模"><a class="markdownIt-Anchor" href="#23-数据模型和概念建模"></a> 2.3 数据模型和概念建模</h3>
<p><strong>|数据模型|</strong>：一组集成的概念，用于描述和操纵组织机构内的数据、数据间联系以及对数据的约束。</p>
<p>数据模型含下列三个组件：</p>
<ul>
<li>结构部分，由一组创建数据库的规则构成。</li>
<li>操纵部分，定义允许对数据进行的操作的种类。</li>
<li>一组完整性约束，确保数据的准确性。</li>
</ul>
<h4 id="231-基于对象的数据模型"><a class="markdownIt-Anchor" href="#231-基于对象的数据模型"></a> 2.3.1 基于对象的数据模型</h4>
<p>基于对象的数据模型用到实体、属性和联系等概念。</p>
<ul>
<li>ER模型</li>
<li>语义模型</li>
</ul>
<h4 id="232-基于记录的数据模型"><a class="markdownIt-Anchor" href="#232-基于记录的数据模型"></a> 2.3.2 基于记录的数据模型</h4>
<p>在基于记录的数据模型中，数据库由若干不同类型的固定格式记录组成。</p>
<p>关系系统对数据库处理采用说明性的方法，而网状和层次系统采用导航的方法。</p>
<h5 id="关系数据模型"><a class="markdownIt-Anchor" href="#关系数据模型"></a> 关系数据模型</h5>
<p>在关系模型中，数据和联系均以表格的形式表示，每个表格有若干具有唯一名称的列。</p>
<h5 id="网状数据模型"><a class="markdownIt-Anchor" href="#网状数据模型"></a> 网状数据模型</h5>
<p>在网络数据模型中，数据被表示成一组记录，联系被表示成络(set)，具体实现时一般使用指针。</p>
<ul>
<li>记录是节点而洛是边</li>
</ul>
<h5 id="层次数据模型"><a class="markdownIt-Anchor" href="#层次数据模型"></a> 层次数据模型</h5>
<p>层次数据模型是一种受限的网状模型，层次数据模型规定一个节点只能有一个父节点。</p>
<h4 id="233-物理数据模型"><a class="markdownIt-Anchor" href="#233-物理数据模型"></a> 2.3.3 物理数据模型</h4>
<p>物理数据模型描述数据是如何存储在计算机中的，涉及记录结构、记录顺序及访问路径等信息。</p>
<h3 id="24-dbms的功能"><a class="markdownIt-Anchor" href="#24-dbms的功能"></a> 2.4 DBMS的功能</h3>
<p><strong>数据存储、检索和更新</strong></p>
<p>DBMS必须为用户提供在数据库中存储、检索和更新数据的能力。</p>
<p><strong>用户可访问的目录</strong></p>
<p>DBMS必须提供一个目录，内存各类数据项的描述并允许用户访问。</p>
<p><strong>事务支持</strong></p>
<p>DBMS必须提供一个机制，确保给定事务的所有更新操作或者完全做完或者一个都不做。</p>
<p><strong>并发控制服务</strong></p>
<p>DBMS必须提供一个机制，确保当多个用户并行地更新数据库时，数据库被正确更新。</p>
<p><strong>恢复服务</strong></p>
<p>DBMS必须提供一个机制，无论数据库因何种原因受到破坏时，都能恢复数据库。</p>
<p><strong>授权服务</strong></p>
<p>DBMS必须提供一个机制，确保只有经过授权的用户才可以访问数据库。</p>
<p><strong>支持数据通信</strong></p>
<p>DBMS必须能够与通信软件集成。</p>
<p><strong>完整性服务</strong></p>
<p>DBMS必须提供一种方法， 确保数据库中的数据和对数据的修改遵循一定的规则。</p>
<p><strong>提高数据独立性的服务</strong></p>
<p>DBMS必须提供机制，使程序独立于数据库的实际结构。</p>
<p><strong>实用服务程序</strong></p>
<p>DBMS应该提供一组实用服务程序</p>
<h3 id="25-dbms的组件"><a class="markdownIt-Anchor" href="#25-dbms的组件"></a> 2.5 DBMS的组件</h3>
<img src="https://i.loli.net/2021/05/05/vNy5OaECrMeZHhD.png" alt="4.png" style="zoom:80%;" />
<ul>
<li>查询处理器：将所有的查询转换成一系列指导数据库管理器运行的低层指令</li>
<li>DML预处理器：将嵌入应用程序中的DML语句转换成宿主语言中标准的函数调用</li>
<li>DDL编译器：将DDL语句转换成一组包含元数据的表格</li>
<li>目录管理器：控制对系统目录的访问</li>
<li>DM: DM与用户提交的应用程序和查询处理器接口</li>
</ul>
<img src="https://i.loli.net/2021/05/05/GHo8bUM2xgZEqsT.png" alt="5.png" style="zoom:80%;"  />
<ul>
<li>授权控制：这个模块检查用户是否具有必要的操作权限。</li>
<li>命令处理器：若有权限，则控制权交给命令管理器。</li>
<li>完整性检查其：兑与每个修改数据库的操作，检查请求的操作是否满足所有必要的完整性约束。</li>
<li>查询优化器：确定执行查询的最优策略。</li>
<li>事务管理器：执行从事务接收到的操作序列。</li>
<li>调度程序：确保当前数据库中并发运行的操作不相互冲突。</li>
</ul>
<h3 id="26-多用户dbms结构"><a class="markdownIt-Anchor" href="#26-多用户dbms结构"></a> 2.6 多用户DBMS结构</h3>
<h4 id="261-远程处理"><a class="markdownIt-Anchor" href="#261-远程处理"></a> 2.6.1 远程处理</h4>
<p>一台计算机和若干终端</p>
<h4 id="262-文件服务器结构"><a class="markdownIt-Anchor" href="#262-文件服务器结构"></a> 2.6.2 文件服务器结构</h4>
<p><strong>|文件服务器|</strong>：在网络上的一台计算机，其主要用途是为文档、电子表格、图像和数据库之类的计算机文件提供共享存储。</p>
<img src="https://i.loli.net/2021/05/05/xrIlnRZdUN5QfaK.png" alt="6.png" style="zoom:80%;" />
<ul>
<li>数据库在文件服务器上</li>
<li>应用程序和DBMS运行在各个工作站点上</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>
<p>网络拥塞</p>
</li>
<li>
<p>每台工作站上都要求有一个DBMS的完整副本</p>
</li>
<li>
<p>并发、恢复和完整性控制变得相当复杂，因为可能有多个DBMS访问同一个文件</p>
</li>
</ul>
<h4 id="263-传统的两层客户-服务器结构"><a class="markdownIt-Anchor" href="#263-传统的两层客户-服务器结构"></a> 2.6.3 传统的两层客户-服务器结构</h4>
<img src="https://i.loli.net/2021/05/05/391HQhwDjlytOvx.png" alt="7.png" style="zoom:80%;" />
<ul>
<li>客户端管理用户界面和处理应用逻辑</li>
<li>数据库和DBMS在服务器上</li>
</ul>
<p><strong>优点</strong>：</p>
<ul>
<li>广泛支持对现存数据库的访问</li>
<li>增强性能</li>
<li>降低硬件费用</li>
<li>降低通信费用</li>
<li>增强一致性</li>
</ul>
<h4 id="264-事务处理监视器tpm"><a class="markdownIt-Anchor" href="#264-事务处理监视器tpm"></a> 2.6.4 事务处理监视器(TPM)</h4>
<p><strong>|事务处理监视器|</strong>：控制客户端和服务器之间数据传输的程序，旨在为应用提供一致的环境，尤其是为联机事务处理(OLTP)一类的应用。</p>
<p>复杂的应用程序经常建立在多个资源管理器之上。TP监视器是一个中间件，能访问各种资源管理器提供的服务，同时为事务型软件的开发者提供一个统一的接口。TP监视器作为三层结构中的中间层。</p>
<img src="https://i.loli.net/2021/05/05/exN5bjSI8uVgqvK.png" alt="8.png" style="zoom:80%;" />
<h3 id="27-系统目录"><a class="markdownIt-Anchor" href="#27-系统目录"></a> 2.7 系统目录</h3>
<p><strong>|系统目录|</strong>：描述数据库中数据的信息存储库，即元数据</p>
<p>目录必须是用户可访问的</p>
<ul>
<li>授权控制模块</li>
<li>完整性检查器模块</li>
<li>存放授权用户</li>
<li>每个数据项的约束</li>
</ul>
<p>信息资源字典系统是一个ISO标准，定义了一组访问数据字典的方法。这样就允许共享字典，并且可以从一个系统转换到另一个系统。</p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>To address the issue of data independence, the ANSI-SPARC three-level architecture was proposed. Compare and contrast the three levels of this model.怎么解决数据独立性的问题</p>
<p>外部层由若干不同的用户视图组成，概念层是数据库的整体视图，描述了哪些数据被存储在数据库中，以及这些数据之间的联系。内部层是数据库在计算机上的物理表示。描述数据是如何存储在数据库中的。三层体系结构通过两段映射，外部层到概念层的映射和概念层到内部层的映射，保证对低层次的修改不会影响到高层次，提供了更强的数据独立性。</p>
</li>
<li>
<p>What is a data model? Discuss three components of data model and the main types of data model.</p>
<p>数据模型是一组集成的概念，用于描述和操纵组织机构内的数据、数据间联系以及对数据的约束。数据模型的三个组成部分有结构部分，由一组创建数据库的规则构成；操纵部分，定义允许对数据进行的操作的种类；一组完整性约束，确保数据的准确性。主要的数据模型有关系数据模型、网状数据模型、层次数据模型、实体-联系模型等等。</p>
</li>
<li>
<p>What is meant by the term ‘client-server architecture’ and what are the advantages of this approach? Compare the client-server architecture with other architecture.</p>
<p>客户-服务器指的是软组件相互作用形成系统的一个方式。这种方法中存在一个请求资源的客户进程和一个提供资源的服务器。优点有广泛支持对现存数据库的访问、增强性能、降低硬件费用、降低通信费用和增强一致性。与远程处理和文件服务器结构相比，客户-服务器与文件-服务器的客户端与服务器都通过LAN进行通信，但文件-服务器的应用程序和DBMS都在客户端而客户-服务器的应用程序在客户端，数据库和DBMS在服务器。远程处理结构中终端没有处理能力，要交由中央计算机处理，中心计算机要运行应用程序和DBMS。</p>
</li>
<li>
<p>Discuss the function and importance of the system catalog.</p>
<p>系统目录存放元数据，存放授权用户，存放每个数据项的约束，用户可以查询系统目录。设立系统目录，数据的信息可以被集中保存。由于数据被集中保存，冗余和一致性的问题可以被识别和控制。增强了安全性和完整性。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第四章 关系代数</title>
    <url>/2021/04/16/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter4%20%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第四章-关系代数"><a class="markdownIt-Anchor" href="#第四章-关系代数"></a> 第四章 关系代数</h2>
<h3 id="41-一元运算"><a class="markdownIt-Anchor" href="#41-一元运算"></a> 4.1 一元运算</h3>
<h4 id="411-选择"><a class="markdownIt-Anchor" href="#411-选择"></a> 4.1.1 选择</h4>
<a id="more"></a>
<p><strong>|σ<sub>predicate</sub>®|</strong>：选择运算作用于单个关系R，得到一个新关系，它由R中满足特定条件的元组组成。</p>
<p>例：σ<sub>salary &gt; 10000 </sub>(Staff)</p>
<h4 id="412-投影运算"><a class="markdownIt-Anchor" href="#412-投影运算"></a> 4.1.2 投影运算</h4>
<p><strong>|∏col<sub>1</sub>, … , col<sub>n</sub>®|</strong>：投影运算作用于单个关系R，得到由R的一个垂直子集构成的新关系，该垂直子集抽取R中指定属性上的值并<strong>去掉了重复元组</strong>。</p>
<h3 id="42-集合运算"><a class="markdownIt-Anchor" href="#42-集合运算"></a> 4.2 集合运算</h3>
<h4 id="421-并"><a class="markdownIt-Anchor" href="#421-并"></a> 4.2.1 并</h4>
<p><strong>|R∪S|</strong>：两个关系R和S的并，定义了一个包含R、S中所有不同元组的新关系。R和S必须具有<strong>并相容性</strong>。</p>
<p>例：∏<sub>city</sub>(Branch)∪Π<sub>city</sub>(PropertyForRent)</p>
<h4 id="422-差"><a class="markdownIt-Anchor" href="#422-差"></a> 4.2.2 差</h4>
<p><strong>|R - S |</strong>：集合差运算定义了一个新的关系，它由所有属于R但不属于S的元组构成。R和S必须具有并相容性。</p>
<p>列出有分公司但待租房产的城市清单：∏<sub>city</sub>(Branch) - Π<sub>city</sub>(PropertyForRent)</p>
<h4 id="423-交"><a class="markdownIt-Anchor" href="#423-交"></a> 4.2.3 交</h4>
<p><strong>|R∩S|</strong>：交运算定义了一个关系，它由既属于R又属于S的元组构成。R和S必须具备<strong>并相容性</strong>。</p>
<h4 id="424-笛卡尔乘积"><a class="markdownIt-Anchor" href="#424-笛卡尔乘积"></a> 4.2.4 笛卡尔乘积</h4>
<p><strong>|R × S|</strong>：笛卡尔乘积运算定义了一个关系，它是关系R中每个元组与关系S中每个元组并联的结果。</p>
<h3 id="43-连接运算"><a class="markdownIt-Anchor" href="#43-连接运算"></a> 4.3 连接运算</h3>
<p>将两个关系结合起来组成一个新的关系。相当于对两个参与运算关系的笛卡尔乘积执行一次选择运算。</p>
<h4 id="431-θ连接"><a class="markdownIt-Anchor" href="#431-θ连接"></a> 4.3.1 θ连接</h4>
<p><strong>|R ⋈<sub>F</sub> S|</strong>：θ连接运算定义一个关系，它包含R和S的笛卡尔乘积中所有满足谓词F的元组。谓词F的格式为R.a<sub>i</sub> θ S.b<sub>i</sub>, 其中θ为6个比较运算符之一。</p>
<p>​	R⋈<sub>F</sub>S = σ<sub>F</sub>(R × S)</p>
<h4 id="432-等接运算"><a class="markdownIt-Anchor" href="#432-等接运算"></a> 4.3.2 等接运算</h4>
<p>在谓词F仅包含等号(=)的情况下，θ连接就变成了等接。</p>
<h4 id="433-自然连接"><a class="markdownIt-Anchor" href="#433-自然连接"></a> 4.3.3 自然连接</h4>
<p><strong>|R ⋈ S|</strong>：自然连接是关系R和S在所有公共属性x上的等接。但在得到的结果中每个公共属性只保留一次，其余删除。</p>
<img src="https://i.loli.net/2021/05/05/li2zGxt69XHsk4N.png" alt="1.png" style="zoom:80%;" />
<h4 id="434-外连接"><a class="markdownIt-Anchor" href="#434-外连接"></a> 4.3.4 外连接</h4>
<p><strong>|R ⋊ S|</strong>：(左)外连接是这样一种连接，它将R中的所有元组都保留在结果关系中，包括那些公共属性与S不匹配的，不过，结果关系中来自S的所有非公共属性均取空。</p>
<h4 id="435-半连接"><a class="markdownIt-Anchor" href="#435-半连接"></a> 4.3.5 半连接</h4>
<p><strong>|R<img src="https://i.loli.net/2021/05/05/MUHVFwZqfDliu26.png" alt="2.png" />S|</strong>：半连接运算定义的关系包含<strong>R中的这样一些元组</strong>，它们参与了R与S满足谓词F的连接。</p>
<p>​		半连接运算执行了两个关系的连接后，再将结果投影到第一个参与运算的关系的所有属性上。</p>
<p>R<img src="https://i.loli.net/2021/05/05/MUHVFwZqfDliu26.png" alt="2.png" />S = Π<sub>A</sub>(R ⋈<sub>F</sub> S)	A是R中所有属性的集合</p>
<h3 id="44-除法运算"><a class="markdownIt-Anchor" href="#44-除法运算"></a> 4.4 除法运算</h3>
<p>假设关系R定义在属性集合A上，关系S定义在属性集合B上，并且B ⊆ A。C = A - B，即C是属于R但不属于S的属性集合。</p>
<p><strong>|R ÷ S|</strong>：除法运算定义了属性集合C上的一个关系，该关系的元组与S中每个元组的组合都能在R中找到匹配元组。</p>
<p>除法运算的步骤：</p>
<ul>
<li>T<sub>1</sub> ⬅ Π<sub>c</sub>®</li>
<li>T<sub>2</sub> ⬅ Π<sub>c</sub>( (T<sub>1</sub> × S) - R )</li>
<li>T ⬅ T<sub>1</sub> - T<sub>2</sub></li>
</ul>
<img src="https://i.loli.net/2021/05/05/pzS2DgOT1vXARek.png" alt="3.png" style="zoom:80%;" />
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>Define the five basic relational algebra operations. Define the Join, Intersection, and Division operations in terms of these five basic operations.</p>
<p><strong>|σ<sub>predicate</sub>®|</strong>：选择运算作用于单个关系R，得到一个新关系，它由R中满足特定条件的元组组成。</p>
<p><strong>|∏col<sub>1</sub>, … , col<sub>n</sub>®|</strong>：投影运算作用于单个关系R，得到由R的一个垂直子集构成的新关系，该垂直子集抽取R中指定属性上的值并<strong>去掉了重复元组</strong>。</p>
<p><strong>|R∪S|</strong>：两个关系R和S的并，定义了一个包含R、S中所有不同元组的新关系。R和S必须具有<strong>并相容性</strong>。</p>
<p><strong>|R × S|</strong>：笛卡尔乘积运算定义了一个关系，它是关系R中每个元组与关系S中每个元组并联的结果。</p>
<p><strong>|R - S |</strong>：集合差运算定义了一个新的关系，它由所有属于R但不属于S的元组构成。R和S必须具有并相容性。</p>
<p><strong>|R∩S|</strong>：交运算定义了一个关系，它由既属于R又属于S的元组构成。R和S必须具备<strong>并相容性</strong>。</p>
<p>连接关系：将两个关系结合起来组成一个新的关系。相当于对两个参与运算关系的笛卡尔乘积执行一次选择运算。</p>
<p>假设关系R定义在属性集合A上，关系S定义在属性集合B上，并且B ⊆ A。C = A - B，即C是属于R但不属于S的属性集合。</p>
<p><strong>|R ÷ S|</strong>：除法运算定义了属性集合C上的一个关系，该关系的元组与S中每个元组的组合都能在R中找到匹配元组。</p>
<p>除法运算的步骤：</p>
<ul>
<li>T<sub>1</sub> ⬅ Π<sub>c</sub>®</li>
<li>T<sub>2</sub> ⬅ Π<sub>c</sub>( (T<sub>1</sub> × S) - R )</li>
<li>T ⬅ T<sub>1</sub> - T<sub>2</sub></li>
</ul>
</li>
<li>
<p>Discuss the difference between the five Join operations: Theta join, Equijoin, Natural join, Outer join, and Semijoin. Give examples to illustrate your answer.<br />
Use the Hotel schema defined at the Exercises at the end of Chapter 3, finish exercises 4 and 5.</p>
</li>
</ol>
<p><strong>|R ⋈<sub>F</sub> S|</strong>：θ连接运算定义一个关系，它包含R和S的笛卡尔乘积中所有满足谓词F的元组。谓词F的格式为R.a<sub>i</sub> θ S.b<sub>i</sub>, 其中θ为6个比较运算符之一。</p>
<p>等接运算是特殊的θ运算。在谓词F仅包含等号(=)的情况下，θ连接就变成了等接。</p>
<p>​	自然连接是特殊的等接运算。自然连接是关系R和S在所有公共属性x上的等接，得到结果后要去重。</p>
<p>外连接将R中的所有元组都保留在结果关系中，包括那些公共属性与S不匹配的，不过，结果关系中来自S的所有非公共属性均取空。</p>
<p>半连接运算执行了两个关系的连接后，再将结果投影到第一个参与运算的关系的所有属性上。</p>
<p><img src="https://i.loli.net/2021/05/05/f1wbWg5rZ3l9RFX.png" alt="4.png" /></p>
<ol start="3">
<li>
<p>Describe the relations that would be produced by the following relational algebra operations:</p>
<p>a) 列出所有房间价格高于50的酒店号列表</p>
<p>b) 列出所有酒店的所有房间</p>
<p>c) 列出所有房间价格高于50的酒店名</p>
<p>d) 列出所有客人的详细资料，并显示预定结束时间在2007年1月1日后的客人的预定资料</p>
<p>e) 列出所有房间价格高于50的酒店的详细资料</p>
<p>f) 列出预定了伦敦的酒店的所有客人的姓名</p>
</li>
<li>
<p>Generate the relational algebra for the following queries:</p>
</li>
</ol>
<p>(a) List all hotels</p>
<p>Hotel∨</p>
<p>(b) List all single rooms with a price below £20 per night.</p>
<p>σ<sub>type = “single” ∧ price &lt; 20 </sub>(Room)</p>
<p>© List the names and cities of all guests.</p>
<p>Π<sub>guestName, guestAddress</sub>(Guest)</p>
<p>(d) List the price and type of all rooms at the Grosvenor Hotel.</p>
<p>Π<sub>price, type</sub>(Room 半连接<sub>Room.hotelNo = Hotel.hotelNo</sub>(σ<sub>hotelName = ‘Grosvenor’</sub>(Hotel)))</p>
<p>(e) List all guests currently staying at the Grosvenor Hotel.</p>
<p>TempBooking(hotelNo, guestNo, dateFrom, dateTo, roomNo) ⬅ Booking半连接<sub>Booking.hoteltNo = Hotel.hotelNo</sub>(σ<sub>hotelName = ‘Grosvenor’</sub>(Hotel))</p>
<p>Guest 半连接<sub>Guest.guestNo = TempBooking.guestNo</sub>(σ<sub>currentDate &gt;= dateFrom ∧ currentDate &lt;= dateTo</sub>(TempBooking)</p>
<p>(f) List the details of all rooms at the Grosvenor Hotel, including the name of the guest staying in the room, if the room is occupied.</p>
<p><img src="https://i.loli.net/2021/05/05/f1wbWg5rZ3l9RFX.png" alt="4.png" /></p>
<p>房间 外接 客人姓名</p>
<p>TempBooking(hotelNo, guestNo, dateFrom, dateTo, roomNo) ⬅ Booking半连接<sub>Booking.hoteltNo = Hotel.hotelNo</sub>(σ<sub>hotelName = ‘Grosvenor’</sub>(Hotel))</p>
<p>(Room 半连接<sub>Room.hotelNo = Hotel.hotelNo</sub>(σ<sub>hotelName = ‘Grosvenor’</sub>(Hotel)) )左外接</p>
<p>(Π<sub>hotelNo, roomNo, guestName</sub>(Guest 连接<sub>Guest.guestNo = TempBooking.guestNo</sub> TempBooking))</p>
<p>(g) List the guest details (guestNo, guestName, and guestAddress) of all guests staying at the Grosvenor Hotel.</p>
<p>TempBooking(hotelNo, guestNo, dateFrom, dateTo, roomNo) ⬅ Booking半连接<sub>Booking.hoteltNo = Hotel.hotelNo</sub>(σ<sub>hotelName = ‘Grosvenor’</sub>(Hotel))</p>
<p>Π<sub>guestNo, guestName, guestAddress</sub>(Guest 半连接<sub>Guest.guestNo = TempBooking.guestNo</sub> TempBooking)</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 数据操作</title>
    <url>/2021/04/23/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter5%20%E6%95%B0%E6%8D%AE%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第五章-数据操作"><a class="markdownIt-Anchor" href="#第五章-数据操作"></a> 第五章 数据操作</h2>
<h3 id="51-简介"><a class="markdownIt-Anchor" href="#51-简介"></a> 5.1 简介</h3>
<a id="more"></a>
<p>SQL是一种<strong>面向转换语言</strong>，它由两个主要部分组成：</p>
<p><strong>DDL</strong>：用于定义数据库结构和数据库的访问控制。</p>
<p><strong>DML</strong>：用于检索和更新数据。</p>
<h3 id="52-书写sql命令"><a class="markdownIt-Anchor" href="#52-书写sql命令"></a> 5.2 书写SQL命令</h3>
<p><strong>扩展的巴克斯范式</strong></p>
<ul>
<li>
<p>大写字母用于表示保留字。</p>
</li>
<li>
<p>小写字母用于表示用户自定义字。</p>
</li>
<li>
<p>竖线(|)表示从选项中进行<strong>选择</strong>，例如a|b|c。</p>
</li>
<li>
<p>大括号表示<strong>所需元素</strong>，例如{ a }。</p>
</li>
<li>
<p>中括号表示<strong>可选择元素</strong>，例如[a]。</p>
</li>
<li>
<p>省略号(…)表示某一项<strong>可选择重复</strong>零到多次。</p>
</li>
</ul>
<h3 id="53-数据操作"><a class="markdownIt-Anchor" href="#53-数据操作"></a> 5.3 数据操作</h3>
<h4 id="531-简单查询"><a class="markdownIt-Anchor" href="#531-简单查询"></a> 5.3.1 简单查询</h4>
<p><strong>SELECT</strong> 		   [<strong>DISTINCT</strong> | <strong>ALL</strong>]<br />
{* | [columnExpression [<strong>AS</strong> newName]] [,…] }<br />
<strong>FROM</strong> 		     TableName [alias] [, …]<br />
[<strong>WHERE</strong> 		  condition]<br />
[<strong>GROUP BY</strong> 	columnList] [<strong>HAVING</strong> condition]<br />
[<strong>ORDER BY</strong> 	 columnList].</p>
<p><strong>处理过程顺序</strong></p>
<p><strong>FROM</strong>				给出将用到的表</p>
<p><strong>WHERE</strong>			  过滤满足条件的行</p>
<p><strong>GROUP BY</strong>        将具有相同属性值的行分成组</p>
<p><strong>HAVING</strong>			 过滤满足条件的组</p>
<p><strong>SELECT</strong>  			 指定查询结果中出现的列</p>
<p><strong>ORDER BY</strong>		 指定查询结果的顺序</p>
<hr />
<p><strong>DISTINCT</strong></p>
<p>去掉重复的元组</p>
<p><strong>计算字段</strong></p>
<p>SELECT staffNo, fName, lName, salary/12 AS monthlySalary</p>
<p>FROM	Staff;</p>
<p><strong>WHERE</strong></p>
<ul>
<li>
<p>比较运算、复合比较运算(NOT/ADD/OR)</p>
</li>
<li>
<p>范围(BETWEEN/NOT BETWEEN)</p>
</li>
<li>
<p>成员关系(IN/NOT IN)</p>
<img src="https://i.loli.net/2021/05/05/lWcMUs5FXrZkLhS.png" alt="1.png" style="zoom:80%;" />
</li>
<li>
<p>模式匹配(LIKE/NOT LIKE)</p>
<ul>
<li><strong>%</strong>：百分号表示零或多个字符序列。</li>
<li><strong>_</strong>：下划线表示任意单个字符。</li>
</ul>
<hr />
<ul>
<li>address LIKE ‘<strong>H%</strong>’ 意味着字符串第一个字符必须是H</li>
<li>address LIKE '<strong>H_ _ _</strong>'意味着字符串正好有四个字符，第一个字符为H</li>
<li>address LIKE '<strong>%e</strong>’意味着一个字符序列，长度最小为1，最后一个字符为e</li>
<li>address LIKE '<strong>%H%</strong>'意味着一个包含字符串H的任意长度序列</li>
<li>address NOT LIKE '<strong>H%</strong>'意味着字符串第一个字符不能为H</li>
</ul>
</li>
<li>
<p>空查找(IS NULL/IS NOT NULL)</p>
<p>SELECT 	clientNo</p>
<p>FROM 	   Viewing</p>
<p>WHERE	  comment IS NULL</p>
</li>
</ul>
<h4 id="532-查询结果排序order-by"><a class="markdownIt-Anchor" href="#532-查询结果排序order-by"></a> 5.3.2 查询结果排序(ORDER BY)</h4>
<p><strong>单列排序</strong></p>
<p>ORDER BY 子句包括所需排序的<strong>列标识符</strong>的列表。<strong>列标识符</strong>可能是列名字或列序号，如“1”标识列表中第一个元素。</p>
<p>SELECT 	  staffNo, fName, IName, salary</p>
<p>FROM	     Staff</p>
<p>ORDER BY  salary|4 DESC;</p>
<p><strong>多列排序</strong></p>
<p>ORDER BY 子句可能包含多个元素，<strong>主排序键</strong>决定查询结果总体的排序。<strong>次排序键</strong>控制主排序键相同行的顺序。</p>
<p>SELECT 		propertyNo, type, rooms, rent</p>
<p>FROM		    PropertyForRent</p>
<p>ORDER BY	 type, rent DESC;</p>
<p>查询结果首先以房产类型升序排列（默认值为ASC），对于相同的房产类型，以rent降序排列。</p>
<h4 id="533-sql聚集函数"><a class="markdownIt-Anchor" href="#533-sql聚集函数"></a> 5.3.3 SQL聚集函数</h4>
<p>COUNT、SUM、AVG、MIN、MAX</p>
<p>​		SUM和AVG只能用于数值字段，除了COUNT(*)外，每一个函数首先要去掉空值，然后计算其非空值。</p>
<p>​		聚集函数只能用于SELECT列表和HAVING子句中，用在其他地方都是不正确的。如果SELECT列表包括聚集函数，却没有使用GROUP BY子句分组，那么SELECT列表的任何项都不能引用列，除了作为聚集函数的参数。</p>
<p>​		例：SELECT staffNo, COUNT(salary)</p>
<p>​				FROM Staff</p>
<p>​		是非法的</p>
<p><strong>COUNT、SUM</strong></p>
<p>SELECT 				COUNT(DISTINCT propertyNo) AS myCount, 							  							  SUM(salary) AS mySalary</p>
<p>FROM 				  Staff</p>
<p>WHERE				 position = ‘Manager’;</p>
<p><strong>MIN、MAX、AVG</strong></p>
<p>SELECT				  MIN(salary), MAX(salary), AVG(salary)</p>
<p>FROM					Staff;</p>
<h4 id="534-查询结果分组group-by"><a class="markdownIt-Anchor" href="#534-查询结果分组group-by"></a> 5.3.4 查询结果分组(GROUP BY)</h4>
<p>GROUP BY 按SELECT列表中的列进行分组，每一组产生一个综合查询结果。当使用GROUP BY时，SELECT列表中的项必须每组都有单一值。SELECT子句中的所有列除非用在聚集函数上，否则必须在GROUP BY子句中出现。当WHERE子句和GROUP BY子句同时使用时，必须首先使用WHERE子句。应用GROUP BY子句时，两个空值被认为是相等的。</p>
<img src="https://i.loli.net/2021/05/05/DBQCkuFxegm6n94.png" alt="2.png" style="zoom:80%;" />
<h5 id="分组约束having"><a class="markdownIt-Anchor" href="#分组约束having"></a> 分组约束（HAVING）</h5>
<p>限定哪些<strong>分组</strong>将出现在最终查询结果中。</p>
<img src="https://i.loli.net/2021/05/05/1YTeauwd24ZVhFX.png" alt="3.png" style="zoom:80%;" />
<p><strong>HAVING和WHERE的差别</strong></p>
<p>​		WHERE子句将单个行过滤到查询结果中，而HAVING子句则将分组过滤到查询结果表中。HAVING子句使用的列名必须出现在GROUP BY子句列表中，或包含在聚集函数中。</p>
<h4 id="535-子查询"><a class="markdownIt-Anchor" href="#535-子查询"></a> 5.3.5 子查询</h4>
<ul>
<li>标量子查询</li>
<li>行子查询</li>
<li>表子查询</li>
</ul>
<p><strong>用于相等判断的子查询</strong></p>
<p>列出在位于“163 Main St”的分公司中工作的员工的情况。</p>
<p>SELECT 	staffNo, fName, lName, position<br />
FROM 	  Staff<br />
WHERE     branchNo = (SELECT    branchNo<br />
FROM       Branch<br />
WHERE     street = ‘163 Main St’);</p>
<p><strong>用于聚集函数的子查询</strong></p>
<p>列出个人工资高于平均工资的所有员工，并求出多于平均数的值。</p>
<p>SELECT 		staffNo, fName, lName, position,<br />
salary – (SELECT AVG(salary) FROM Staff) As SalDiff<br />
FROM 		  Staff<br />
WHERE         salary &gt;(SELECT AVG(salary)<br />
FROM Staff);</p>
<p><strong>子查询规则</strong></p>
<ul>
<li>
<p>ORDER BY子句不能用于子查询。</p>
</li>
<li>
<p>子查询SELECT列表必须由单个列名或表达式组成，除非子查询使用了关键词<strong>EXISTS</strong>。</p>
</li>
<li>
<p>默认情况下，子查询中列名取自子查询的FROM子句中给出的表。</p>
</li>
<li>
<p>当子查询是比较表达式中的一个操作数时，子查询必须出现在表达式的右边。</p>
<ul>
<li>
<p>例：WHERE (SELECT AVG(salary) FROM Staff) &lt; salary</p>
<p>是不正确的</p>
</li>
</ul>
</li>
</ul>
<p><strong>嵌套子查询：IN</strong></p>
<p>当子查询结果为行时，使用<strong>IN</strong>关键字</p>
<img src="https://i.loli.net/2021/05/05/yFVXqPkOih9BjsN.png" alt="4.png" style="zoom:80%;" />
<h4 id="536-any和all"><a class="markdownIt-Anchor" href="#536-any和all"></a> 5.3.6 ANY和ALL</h4>
<p>用于产生单个列的子查询</p>
<p><strong>ANY/SOME</strong></p>
<p>列出工资高于分公司B003中至少一位员工的工资的所有员工</p>
<p>SELECT 			staffNo, fName, lName, position, salary<br />
FROM 			  Staff<br />
WHERE 		    salary &gt; SOME (SELECT salary<br />
FROM Staff<br />
WHERE branchNo = ‘B003’);</p>
<p><img src="https://i.loli.net/2021/05/05/GQ9SuXpVmKA5nYs.png" alt="5.png" style="zoom:80%;" /><img src="https://i.loli.net/2021/05/05/1edubHYRnNExQq8.png" alt="6.png" /></p>
<p><strong>ALL</strong></p>
<p>列出工资高于分公司B003中任何员工的工资的所有员工</p>
<img src="https://i.loli.net/2021/05/05/1edubHYRnNExQq8.png" alt="6.png" style="zoom:80%;" />
<h4 id="537-多表查询"><a class="markdownIt-Anchor" href="#537-多表查询"></a> 5.3.7 多表查询</h4>
<p>如果最终结果表包括了多个表中的列，则必须用连接操作。</p>
<h5 id="5371-简单连接"><a class="markdownIt-Anchor" href="#5371-简单连接"></a> 5.3.7.1 简单连接</h5>
<ul>
<li>
<p>FROM	Client c	JOIN    Viewing v	ON	c.clientNo = v.clientNo</p>
</li>
<li>
<p>FROM    Client c    JOIN    Viewing    Using    clientNo</p>
</li>
<li>
<p>FROM    Client c NATURAL JOIN    Viewing</p>
</li>
</ul>
<p>后两种是自然连接</p>
<h5 id="5372-三表连接"><a class="markdownIt-Anchor" href="#5372-三表连接"></a> 5.3.7.2 三表连接</h5>
<p>FROM    (Branch b     JOIN    Staff s    USING    branchNo)    AS  bs</p>
<p>​				JOIN    PropertyForRent p    USING    staffNo</p>
<h5 id="5373-外连接"><a class="markdownIt-Anchor" href="#5373-外连接"></a> 5.3.7.3 外连接</h5>
<p>SELECT b.*, p.*</p>
<p>FROM	Branch b    LEFT JOIN    PropertyForRent p    ON    b.city = p.city</p>
<h5 id="5374-全外连接"><a class="markdownIt-Anchor" href="#5374-全外连接"></a> 5.3.7.4 全外连接</h5>
<p>FULL JOIN</p>
<h4 id="538-exists-和-not-exists"><a class="markdownIt-Anchor" href="#538-exists-和-not-exists"></a> 5.3.8 EXISTS 和 NOT EXISTS</h4>
<p>仅用于子查询中，返回结果为真/假。</p>
<p>仅检查子查询结果表中是否存在行。</p>
<p>SELECT staffNo FROM Staff s</p>
<p>WHERE EXISTS(SELECT * FROM Branch b</p>
<p>​							WHERE s.branchNo = b.branchNo);</p>
<h4 id="539-合并结果表"><a class="markdownIt-Anchor" href="#539-合并结果表"></a> 5.3.9 合并结果表</h4>
<p><strong>UNION</strong>、<strong>INTERSECT</strong>、<strong>EXCEPT</strong></p>
<p>operator [ALL] [CORRESPONDING [BY {col}]]</p>
<p><strong>例：</strong></p>
<ul>
<li>
<p>(SELECT city FROM Branch WHERE city IS NOT NULL)</p>
<p>​	        UNION</p>
<p>​				(SELECT city FROM PropertyForRent)</p>
</li>
<li>
<p>(SELECT * FROM Branch WHERE city IS NOT NULL)</p>
<p>​			UNION CORRESPONDING BY city</p>
<p>​					(SELECT * FROM PropertyForRent)</p>
</li>
</ul>
<h4 id="5310-数据库更新"><a class="markdownIt-Anchor" href="#5310-数据库更新"></a> 5.3.10 数据库更新</h4>
<p><strong>INSERT</strong>、<strong>UPDATE</strong>、<strong>DELETE</strong></p>
<h5 id="53101-insert"><a class="markdownIt-Anchor" href="#53101-insert"></a> 5.3.10.1 INSERT</h5>
<p><strong>默认插入</strong></p>
<p>INSERT INTO TableName[(col)]</p>
<p>VALUES(dataValue)</p>
<p><strong>批量插入</strong></p>
<p>INSERT INTO TableName[{col}]</p>
<p>​	SELECT …</p>
<h5 id="53102-update"><a class="markdownIt-Anchor" href="#53102-update"></a> 5.3.10.2 UPDATE</h5>
<p>UPDATE TableName</p>
<p>SET [col = value], [col2 = value2]</p>
<h5 id="53103-delete"><a class="markdownIt-Anchor" href="#53103-delete"></a> 5.3.10.3 DELETE</h5>
<p><strong>删除指定行</strong></p>
<p>DELETE FROM TableName WHERE</p>
<p><strong>删除所有行</strong></p>
<p>DELETE FROM Viewing</p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>What are the advantages and disadvantages of SQL?</p>
<p>优点：</p>
<ol>
<li>
<p>安全性，只允许授权的用户进行访问</p>
</li>
<li>
<p>唯一一个得到普遍认可的数据库标准语言</p>
</li>
<li>
<p>可移植性高</p>
</li>
</ol>
<p>缺点：</p>
<ol>
<li>sql查询语句需要知道有关数据库结构的详细信息</li>
<li>处理聚合函数中的空值</li>
</ol>
</li>
<li>
<p>What restrictions apply to the use of the aggregate functions within the SELECT statement? How do nulls affect the aggregate functions?</p>
<p>​		聚集函数只能用于SELECT列表和HAVING子句中，用在其他地方都是不正确的。如果SELECT列表包括聚集函数，却没有使用GROUP BY子句分组，那么SELECT列表的任何项都不能引用列，除了作为聚集函数的参数。除了COUNT(*)外，每一个函数首先要去掉空值，然后计算其非空值。</p>
</li>
<li>
<p>Explain how the GROUP BY clause works. What is the difference between the WHERE and HAVING clauses?</p>
<p>​		GROUP BY 按SELECT列表中的列进行分组，每一组产生一个综合查询结果。当使用GROUP BY时，SELECT列表中的项必须每组都有单一值。SELECT子句中的所有列除非用在聚集函数上，否则必须在GROUP BY子句中出现。当WHERE子句和GROUP BY子句同时使用时，必须首先使用WHERE子句。应用GROUP BY子句时，两个空值被认为是相等的。</p>
<p>​		WHERE子句将单个行过滤到查询结果中，而HAVING子句则将分组过滤到查询结果表中。HAVING子句使用的列名必须出现在GROUP BY子句列表中，或包含在聚集函数中。</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/05/05/f1wbWg5rZ3l9RFX.png" alt="4.png" /></p>
<p>For the following exercises, use the Hotel schema defined at the start of the Exercises at the end of Chapter 3.</p>
<p><strong>Simple Queries</strong></p>
<ol start="4">
<li>
<p>List all double or family rooms with a price below £40.00 per night, in ascending order of price.</p>
<p>SELECT * FROM Room</p>
<p>WHERE price &lt; 40000 AND type in (‘double’, ‘family’)</p>
<p>ORDER BY price;</p>
</li>
<li>
<p>List the bookings for which no dateTo has been specified.</p>
<p>SELECT * FROM Booking</p>
<p>WHERE dateTo IS NULL;</p>
</li>
</ol>
<p><strong>Aggregate Functions</strong></p>
<ol start="6">
<li>
<p>How many different guests have made bookings for August?</p>
<p>SELECT COUNT(DISTINCT guestNo) FROM Booking</p>
<p>WHERE (dateFrom &gt;= ‘2021-08-01’ and dateTo &lt;= ‘2021-08-31’);</p>
</li>
</ol>
<p><strong>Subqueries and Joins</strong></p>
<ol start="7">
<li>
<p>List the details of all rooms at the Grosvenor Hotel, including the name of the guest staying in the room, if the room is occupied.</p>
<p>SELECT * from Room r LEFT JOIN</p>
<p>​		(SELECT b.hotelNo, g.guestNo FROM Hotel h,Booking b, Guest g</p>
<p>​		 WHERE h.hotelNo = b.hotelNo and b.guestNo = g.guestNo</p>
<p>​		 AND h.hotelName = ‘Grosvenor’</p>
<p>​    	 AND dateFrom &lt;= currentDate AND dateTo &gt;= currentDate</p>
<p>​		 ) AS t</p>
<p>ON r.hotelNo = t.hotelNo AND r.roomNo = t.roomNo</p>
</li>
<li>
<p>What is the total income from bookings for the Grosvenor Hotel today?</p>
<p>SELECT SUM(price) From Room r, Booking b</p>
<p>WHERE r.roomNo = b.roomNo</p>
<p>AND dateFrom &lt;= currentDate AND dateTo  &gt;= currentDate</p>
<p>AND r.hotelNo IN (SELECT h.hotelNo FROM Hotel h</p>
<p>​								  WHERE h.hotelName = ‘Grosvenor’)</p>
</li>
<li>
<p>What is the lost income from unoccupied rooms at the Grosvenor Hotel?</p>
<p>SELECT SUM(price) From Room r</p>
<p>WHERE r.roomNo NOT IN(SELECT b.roomNo</p>
<p>​											   FROM Hotel h, Booking b</p>
<p>​                                               WHERE h.hotelName = ‘Grosvenor’</p>
<p>​											   AND dateFrom &lt;= currentDate</p>
<p>​                                               AND dateTo  &gt;= currentDate</p>
<p>​                                               AND h.hotelNo = b.hotelNo)</p>
</li>
</ol>
<p><strong>Grouping</strong></p>
<ol start="10">
<li>
<p>What is the average number of bookings for each hotel in August?</p>
<p>SELECT hotelNo, COUNT(roomNo)/31 AS CNT</p>
<p>FROM Booking b</p>
<p>WHERE dateFrom &gt;= ‘2021-08-01’ AND dateTo  &lt;=‘2021-08-31’	GROUP BY hotelNo</p>
</li>
<li>
<p>What is the most commonly booked room type for each hotel in London?</p>
<p>SELECT t.hotelNo, MAX(CNT) FROM</p>
<p>​	(SELECT hotelNo,type,COUNT(type) AS CNT</p>
<p>​	FROM Hotel h, Room r, Booking b</p>
<p>​	WHERE h.city = ‘London’</p>
<p>​	AND h.hotelNo = r.hotelNo AND r.roomNo = b.roomNo</p>
<p>​	GROUP BY hotelNo, type) AS t</p>
<p>GROUP BY t.hotelNo</p>
</li>
</ol>
<p><strong>Creating and Populating Tables</strong></p>
<ol start="12">
<li>
<p>Insert records into each of these tables.</p>
<p>INSERT INTO Hotel VALUES(‘H01’, ‘Grosvenor’, ‘London’);</p>
<p>INSERT INTO Room VALUES(‘101’, ‘H01’, ‘small’, 100);</p>
<p>INSERT INTO Booking VALUES(‘H01’, ‘G01’, ‘2021-4-14’, ‘2021-4-15’, ‘101’);</p>
<p>INSERT INTO Guest VALUES(‘G01’, ‘ZHANG SAN’, ‘London’);</p>
</li>
<li>
<p>Update the price of all rooms by 5%.</p>
<p>UPDATE Room SET price = price * 1.05;</p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第八章 实体-联系建模</title>
    <url>/2021/05/20/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter8%20%E5%AE%9E%E4%BD%93-%E8%81%94%E7%B3%BB%E5%BB%BA%E6%A8%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第八章-实体-联系建模"><a class="markdownIt-Anchor" href="#第八章-实体-联系建模"></a> 第八章 实体-联系建模</h2>
<a id="more"></a>
<p><strong>|ER建模|</strong>：ER建模是一种自上而下的数据库设计方法， 该方法首先确定那些被称为实体的重要数据和这些数据之间的联系，实体和联系是ER模型中必备的元素。然后再添加更多的细节信息，例如描述实体和联系的属性信息，以及施加在实体、联系和属性上的约束。</p>
<p>我们采用的图形化符号集是一种日益流行的面向对象建模语言的符号集，称为<strong>统一建模语言(Unified Modeling Language, UML)</strong>。</p>
<p><img src="https://i.loli.net/2021/05/22/yJxDh3CHKY8FArN.png" alt="1.png" /></p>
<h3 id="81-实体类型"><a class="markdownIt-Anchor" href="#81-实体类型"></a> 8.1 实体类型</h3>
<p><strong>|实体类型|</strong>：能够独立存在的具有相同属性的一组对象。</p>
<p>例：Staff</p>
<p><strong>|实体出现|</strong>：实体类型中可唯一标识的一个对象。（实例）</p>
<p>例：S01</p>
<p><strong>实体类型的图形化表示</strong></p>
<p>实体类型用标有名字的矩形表示。</p>
<h3 id="82-联系类型"><a class="markdownIt-Anchor" href="#82-联系类型"></a> 8.2 联系类型</h3>
<p><strong>|联系类型|</strong>：实体类型间的一组有意义的关联。</p>
<p>例：POwns</p>
<p><strong>|联系出现|</strong>：由参与该联系的各个实体类型的一个出现组成的可被唯一标识的关联。</p>
<p>例：B01	Has	S01</p>
<p><strong>|语义网|</strong>：●表示实体，◈表示联系。</p>
<p><strong>联系类型的图形化表示</strong></p>
<p>用线将相关的实体类型联系起来，并在线上标上联系的名字，通常为一个动词，并标记有方向。</p>
<p><img src="https://i.loli.net/2021/05/22/63HeyMZS1XQNOnl.png" alt="2.png" /></p>
<h4 id="821-联系类型的度"><a class="markdownIt-Anchor" href="#821-联系类型的度"></a> 8.2.1 联系类型的度</h4>
<p><strong>|联系类型的度|</strong>：参与联系的实体类型的个数。</p>
<p><strong>复杂联系的图形化表示</strong></p>
<p>UML用菱形符号表示大于2的联系，联系的名字放在菱形内部。</p>
<p><img src="https://i.loli.net/2021/05/22/859n4HZ1uoILKJd.png" alt="3.png" /></p>
<h4 id="822-递归联系"><a class="markdownIt-Anchor" href="#822-递归联系"></a> 8.2.2 递归联系</h4>
<p><strong>|递归联系|</strong>：同一个实体类型以不同的角色多次参与了同一个联系类型。</p>
<p>递归联系有时又叫一元联系。</p>
<p><img src="https://i.loli.net/2021/05/22/wur4jWQ3LncDUJl.png" alt="4.png" /></p>
<p>可以添加<strong>角色名称</strong>来表明每一个参与联系的实体类型在该联系中的意义，当两个实体之间存在多于一种联系时也可以使用角色名称。</p>
<img src="https://i.loli.net/2021/05/22/lAJCFO7e413kWoP.png" alt="5.png" style="zoom:80%;" />
<h3 id="83-属性"><a class="markdownIt-Anchor" href="#83-属性"></a> 8.3 属性</h3>
<p><strong>|属性|</strong>：实体或联系类型所具有的某一特性。</p>
<p><strong>|属性域|</strong>：单个属性或多个属性所允许的取值集合。</p>
<h4 id="831-简单属性和组合属性"><a class="markdownIt-Anchor" href="#831-简单属性和组合属性"></a> 8.3.1 简单属性和组合属性</h4>
<p><strong>|简单属性|</strong>：由独立存在的单个部分组成的属性。</p>
<p>简单属性不能再被划分为更小的部分，有时又称为原子属性。</p>
<p><strong>|组合属性|</strong>：由多个部分组成的属性，每个部分都可独立存在。</p>
<p>例：address（163 Main St, Bei jing, 100083）</p>
<p>可以拆分为street, city和postcode三个属性</p>
<h4 id="832-单值属性和多值属性"><a class="markdownIt-Anchor" href="#832-单值属性和多值属性"></a> 8.3.2 单值属性和多值属性</h4>
<p><strong>|单值属性|</strong>：在实体类型的每个实例出现都只取一个单值的属性。</p>
<p><strong>|多值属性|</strong>：对于实体类型的某些实例出现可能取多个值的属性。</p>
<p>例：电话号码可能有多个值</p>
<h4 id="833-导出属性"><a class="markdownIt-Anchor" href="#833-导出属性"></a> 8.3.3 导出属性</h4>
<p><strong>|导出属性|</strong>：属性的值是从相关的一个或一组属性（不一定来自同一个实体类型）的值导出来的属性。</p>
<p>例：age从Date中导出</p>
<h4 id="834-键"><a class="markdownIt-Anchor" href="#834-键"></a> 8.3.4 键</h4>
<p><strong>|候选键|</strong>：能够唯一标识每个实体的实例出现的最小属性组。</p>
<p><strong>|主键|</strong>：被指定用来唯一标识实体类型的每个实例出现的候选关键字。</p>
<p>实体主键的选择要考虑属性的长度，以及该属性在以后是否仍具有唯一性。</p>
<p><strong>|合成键|</strong>：包括两个或两个以上属性的候选键。</p>
<p><strong>属性的图形化表示</strong></p>
<p>如果要在一个实体类型中显示它的属性，可以将表示实体的矩形分成两部分。上面部分是实体的名字，下面部分列出属性的名字。</p>
<p><img src="https://i.loli.net/2021/05/22/FvSiJA3bEYwcC4L.png" alt="6.png" /></p>
<ul>
<li>
<p>在UML中，属性名字用小驼峰。</p>
</li>
<li>
<p>在ER图中只显示主键属性（属性组）时，可以省略{PK}标记。</p>
</li>
<li>
<p>对于组合属性，可以在紧跟组合属性名的下一行开始以右缩进格式列出子属性名。</p>
</li>
<li>
<p>对于多值属性，要知名属性取值的个数范围。</p>
</li>
<li>
<p>对于导出属性，在属性名前加上符号“/”。</p>
</li>
</ul>
<h3 id="84-强实体类型与弱实体类型"><a class="markdownIt-Anchor" href="#84-强实体类型与弱实体类型"></a> 8.4 强实体类型与弱实体类型</h3>
<p><strong>|强实体类型|</strong>：该实体类型的存在不依赖于其他的实体类型。</p>
<p><strong>|弱实体类型|</strong>：该实体类型的存在依赖于其他实体类型的存在。</p>
<p>强实体类型可以使用该实体类型的主键唯一标识每个实体的实例出现，弱实体类型没有主键，仅使用该实体类型的属性无法唯一标识每个实体的实例出现。</p>
<p><img src="https://i.loli.net/2021/05/22/RzbhlNsSyEem6pT.png" alt="7.png" /></p>
<h3 id="85-联系的属性"><a class="markdownIt-Anchor" href="#85-联系的属性"></a> 8.5 联系的属性</h3>
<p><strong>联系的属性的图形化表示</strong></p>
<p>采用与实体类型相同的符号，将表示属性的矩形和联系用虚线连接起来。</p>
<p><img src="https://i.loli.net/2021/05/22/z4vmxJHFteVqkAj.png" alt="8.png" /></p>
<h3 id="86-结构化约束"><a class="markdownIt-Anchor" href="#86-结构化约束"></a> 8.6 结构化约束</h3>
<p>联系的主要约束称为多重性。</p>
<p><strong>|多重性|</strong>：指一个参与实体类型通过某一联系与另一参与实体类型的某个出现发生关联的数目。</p>
<p>多重性约束了实体间关联的方式，最常见的联系的度是二元的。</p>
<h4 id="861-一对一11联系"><a class="markdownIt-Anchor" href="#861-一对一11联系"></a> 8.6.1 一对一(1:1)联系</h4>
<p><img src="https://i.loli.net/2021/05/22/rdhzoSxgFEMl2fc.png" alt="9.png" /></p>
<h4 id="862-一对多1联系"><a class="markdownIt-Anchor" href="#862-一对多1联系"></a> 8.6.2 一对多(1:*)联系</h4>
<p><img src="https://i.loli.net/2021/05/22/sGVOD2HTXeUycuW.png" alt="10.png" /></p>
<h4 id="863-多对多联系"><a class="markdownIt-Anchor" href="#863-多对多联系"></a> 8.6.3 多对多(*😗)联系</h4>
<p><img src="https://i.loli.net/2021/05/22/bz4JD2LaHI53tfn.png" alt="11.png" /></p>
<h4 id="864-复杂联系的多重性"><a class="markdownIt-Anchor" href="#864-复杂联系的多重性"></a> 8.6.4 复杂联系的多重性</h4>
<p><strong>|多重性(复杂联系)|</strong>：在一个n元联系中，当其他(n - 1)个实体类型的值固定以后，另外一个实体类型可能参与联系的实例出现的个数。</p>
<p><img src="https://i.loli.net/2021/05/22/Kco8zY4pZh6f7Gn.png" alt="13.png" /></p>
<h4 id="865-基数约束和参与性约束"><a class="markdownIt-Anchor" href="#865-基数约束和参与性约束"></a> 8.6.5 基数约束和参与性约束</h4>
<p><strong>|基数|</strong>：在指定的联系类型中，一个实体可能参与的联系出现的最大数目。</p>
<ul>
<li>多重性范围中的最大值</li>
</ul>
<p><strong>|参与性|</strong>：说明所有实体出现是否都参与了联系。</p>
<ul>
<li>多重性范围中的最小值</li>
</ul>
<p>参与性约束表示在一个联系中，时所有实体出现都参与了该联系（<strong>强制参与</strong>），还是只有一部分实体出现参与（<strong>可选参与</strong>）。</p>
<p>要注意的是，某个实体的参与性是由在联系中另外一方实体的多重性的最小值决定的。</p>
<p><img src="https://i.loli.net/2021/05/22/PNXKHrkYZlGyF21.png" alt="14.png" /></p>
<p>例：Staff是可选的，Branch是强制的</p>
<h3 id="87-将er转换关系"><a class="markdownIt-Anchor" href="#87-将er转换关系"></a> 8.7 将ER转换关系</h3>
<p><strong>|将ER转换为关系数据模型|</strong>：为逻辑数据模型创建关系，用来表示已确定的实体、联系和属性。</p>
<h4 id="871-强实体类型"><a class="markdownIt-Anchor" href="#871-强实体类型"></a> 8.7.1 强实体类型</h4>
<p>创建一个包含这个实体所有简单属性的关系</p>
<p>例：Staff(staffNo, sex, DOB)</p>
<h4 id="872-弱实体类型"><a class="markdownIt-Anchor" href="#872-弱实体类型"></a> 8.7.2 弱实体类型</h4>
<p>创建一个包含该实体所有简单属性的关系，其中部分主关键字甚至全部都是从所有者实体中获取的。（主键要等到该弱实体与每一个父实体的联系转化完成后才能确定）</p>
<p>例：Preference(staffNo, prefType)</p>
<h4 id="873-1二元联系模型"><a class="markdownIt-Anchor" href="#873-1二元联系模型"></a> 8.7.3 1:*二元联系模型</h4>
<p>左边作为父实体，右边作为子实体。将父实体的主键属性副本放到对应于子实体的关系中，作为该关系的外键。</p>
<p><img src="https://i.loli.net/2021/05/22/soMGDHW6yjAKXOP.png" alt="15.png" /></p>
<h4 id="834-11-二元联系模型"><a class="markdownIt-Anchor" href="#834-11-二元联系模型"></a> 8.3.4 1:1 二元联系模型</h4>
<p><strong>双方都强制参与的1:1联系</strong></p>
<p>将联系中的两个实体合并到一个关系里，并选择原实体的一个主键作为新关系的主键。</p>
<p>例：Client (clientNo, fName, lName, telNo, prefType, maxRent, staffNo)</p>
<p>主键：clientNo</p>
<p>外键：staffNo references Staff(staffNo)</p>
<p><strong>一方强制参与的1:1联系</strong></p>
<p>联系中可选参与的实体被指定为父实体，强制参与的实体被指定为子实体。将父实体的主键副本放到子实体的关系中。如果这个联系本身还有一个或多个属性，则这些属性也应该放到子实体中。</p>
<p><img src="https://i.loli.net/2021/05/22/iN9mpRXLIlHca4q.png" alt="16.png" /></p>
<p><strong>双方都可选参与的1:1联系</strong></p>
<p>可以随意指定谁是父实体谁是子实体。</p>
<h4 id="875-11递归联系类型"><a class="markdownIt-Anchor" href="#875-11递归联系类型"></a> 8.7.5 1:1递归联系类型</h4>
<p>与上述方法一样，区别在于需要重命名</p>
<h4 id="876-二元联系类型"><a class="markdownIt-Anchor" href="#876-二元联系类型"></a> 8.7.6 *:*二元联系类型</h4>
<p>为每个*:*二元联系 创建一个关系，关系中包含了*:*二元联系的所有属性以及参与这个联系的实体的主键属性的副本，主键属性的副本作为外键。</p>
<p><img src="https://i.loli.net/2021/05/22/LhfMlC12yZ4sum5.png" alt="17.png" /></p>
<h4 id="877-复杂联系类型"><a class="markdownIt-Anchor" href="#877-复杂联系类型"></a> 8.7.7 复杂联系类型</h4>
<p>为每一个复杂联系都创建一个关系，该关系包含了属于这个联系的所有属性，并将参与该联系的实体的主键属性也复制到这个关系中，作为关系的外键。</p>
<p><img src="https://i.loli.net/2021/05/22/BkyZ9azKPLY2onp.png" alt="18.png" /></p>
<h4 id="878-多值属性"><a class="markdownIt-Anchor" href="#878-多值属性"></a> 8.7.8 多值属性</h4>
<p>对于实体中的每一个多值属性，都创建一个新的关系来表示这个多值属性，并且将实体的主键也复制到新建立的关系中，作为新关系的外键。除非多值属性本身是实体的可替换键，否则新关系的主键就是多值属性和实体的主键的组合。</p>
<p><img src="https://i.loli.net/2021/05/22/1mnO5SxZyJX3esc.png" alt="19.png" /></p>
<h4 id="879-将实体和联系转化为关系小结"><a class="markdownIt-Anchor" href="#879-将实体和联系转化为关系小结"></a> 8.7.9 将实体和联系转化为关系小结</h4>
<p><img src="https://i.loli.net/2021/05/22/jscHvZ25L7NUnF6.png" alt="20.png" /></p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>Describe what entity types represent in an ER model and provide examples of entities with a physical or conceptual existence.</p>
<p>实体类型是能够独立存在的具有相同属性的一组对象。实体类型可以是物理存在的对象，也可以是概念存在的对象。物理存在的对象有学生、货物，概念存在的对象有工作经验、熟练程度。</p>
</li>
<li>
<p>Describe what relationship types represent in an ER model and provide examples of unary, binary, ternary, and quaternary relationships.</p>
<p>联系类型是实体类型间的一组有意义的关联。一元联系也被称为递归联系，只有一个实体类型参与。如员工（监管者）管理员工（被监管者）。二元联系如分公司雇有员工。三元联系如员工在某分公司登记了一名客户。四元联系如买主在法律顾问和金融机构的支持下进行投标。（画图）</p>
</li>
<li>
<p>Describe what attributes represent in an ER model and provide examples of simple, composite, single-value, multi-value, and derived attributes.</p>
<p>属性是实体或联系类型所具有的某一特性。简单属性是由独立存在的单个部分组成的属性，如staffNo是关系Staff的简单属性。复合属性是由多个部分组成的属性，每个部分都可独立存在。如name属性可以由fname和lname组成。单值属性是在实体类型的每个实例都只取一个单值的属性，如Staff关系的staffNo属性在每个实例中只有一个值。多值属性是在实体类型的某些实例可能取多个值的属性，如一个人员工可能有多个电话，telNo属性在每个实例中有可能有多于一个的值。导出属性是从相关的一个或一组属性的值导出来的属性，如age属性可以从birthDate属性中导出。</p>
</li>
<li>
<p>Describe what the multiplicity constraint represents for a relationship type.</p>
<p>多重性指一个参与实体类型通过某一联系与另一参与实体类型的某个出现发生关联的数目。多重性约束了实体间关联的方式。最常见的联系的度是二元的。二元联系通常又可以分为一对一、一对多或多对多的。</p>
</li>
<li>
<p>What are enterprise constraints and how does multiplicity model these constraints?</p>
<p>企业级约束是由数据库用户或数据库管理员所指定的附加规则，它约束企业的某些方面。多重性约束了实体间关联的方式，它是用户或企业建立的策略的一种表示。</p>
</li>
<li>
<p>Describe the rules for deriving relations that represent:<br />
strong entity types;</p>
</li>
</ol>
<p>创建一个包含这个实体所有简单属性的关系</p>
<p>weak entity types;</p>
<p>创建包含所有简单属性的关系（主键要等到该弱实体与每一个父实体的联系转化完成后才能确定）</p>
<p>one-to-many (1:*) binary relationship types;</p>
<p>将“一方”作为父实体，将“多方”作为子实体，将父实体的主键属性副本放到对应子实体的关系中，作为该关系的外键，该联系的所有属性也放到子实体的关系中。</p>
<p>one-to-one (1:1) binary relationship types;</p>
<p>(a)双方都为强制参与</p>
<p>​	将两个实体组合起来，用一个关系表示</p>
<p>(b)一方强制参与</p>
<p>​	将可选参与的实体作为父实体，将强制参与的实体作为子实体，将父实体的逐渐属性副本放到对应子实体的关系中，作为该关系的外键，该联系的所有属性也放到子实体的关系中。</p>
<p>©双方都为可选参与</p>
<p>​	可以随意选择父实体和子实体，并按照上述方法进行转换。</p>
<p>one-to-one (1:1) recursive relationship types;</p>
<p>​	与1:1二元关系转换一样，区别在于需要重命名</p>
<p>many-to-many (*😗) binary relationship types;</p>
<p>​	为每个*:*二元联系 创建一个关系，关系中包含了*:*二元联系的所有属性以及参与这个联系的实体的主键属性的副本，主键属性的副本作为外键。</p>
<p>complex relationship types;</p>
<p>​	为每一个复杂联系都创建一个关系，该关系包含了属于这个联系的所有属性，并将参与该联系的实体的主键属性也复制到这个关系中，作为关系的外键。</p>
<p>multi-valued attributes.</p>
<p>​	对于实体中的每一个多值属性，都创建一个新的关系来表示这个多值属性，并且将实体的主键也复制到新建立的关系中，作为新关系的外键。</p>
<ol start="7">
<li>Create an ER diagram for each of the following descriptions:<br />
(a) Each company operates four departments, and each department belongs to one company.<br />
(b) Each department in part (a) employs one or more employees, and each employee works for one department.<br />
© Each of the employees in part (b) may or may not have one or more dependents, and each dependent belongs to one employee.<br />
(d) Each employee in part © may or may not have an employment history.<br />
(e) Represent all the ER diagrams described in (a), (b), ©, and (d) as a single ER diagram.</li>
</ol>
<p><img src="https://i.loli.net/2021/05/22/PvDw73jOpdlFSm9.png" alt="22.png" /></p>
<p>​	注：Employment History是0…*不是1…*</p>
<ol start="8">
<li>
<p>You are required to create a conceptual data model of the data requirements for a company that specializes in IT training. The Company has 30 instructors and can handle up to 100 trainees per training session. The Company offers five advanced technology courses, each of which is taught by a teaching team of two or more instructors. Each instructor is assigned to a maximum of two teaching teams or may be assigned to do research. Each trainee undertakes one advanced technology course per training session.<br />
(a) Identify the main entity types for the company.<br />
(b) Identify the main relationship types and specify the multiplicity for each relationship. State any assumptions you make about the data.<br />
© Using your answers for (a) and (b), draw a single ER diagram to represent the data requirements for the company.</p>
</li>
<li>
<p>Derive relations for the following conceptual data model:</p>
</li>
</ol>
<p><img src="https://i.loli.net/2021/05/22/KhPxSC9I6tTUQvr.png" alt="21.png" /></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第七章 数据库系统开发生命周期</title>
    <url>/2021/05/13/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter7%20%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%BC%80%E5%8F%91%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-数据库系统开发生命周期"><a class="markdownIt-Anchor" href="#第七章-数据库系统开发生命周期"></a> 第七章 数据库系统开发生命周期</h2>
<h3 id="71-信息系统生命周期"><a class="markdownIt-Anchor" href="#71-信息系统生命周期"></a> 7.1 信息系统生命周期</h3>
<a id="more"></a>
<p><strong>|信息系统|</strong>：在组织机构内用于收集、管理、控制和分发信息的一种资源。</p>
<p>基于计算机的信息系统包括数据库、数据库软件、应用程序、计算机硬件，还包括人的使用和开发活动。</p>
<h3 id="72-数据库系统开发生命周期"><a class="markdownIt-Anchor" href="#72-数据库系统开发生命周期"></a> 7.2 数据库系统开发生命周期</h3>
<ul>
<li>数据库规划</li>
<li>系统定义</li>
<li>需求收集与分析</li>
<li>数据库设计</li>
<li>DBMS选型</li>
<li>应用程序设计</li>
<li>建立原型系统（可选）</li>
<li>实现</li>
<li>数据转换与加载</li>
<li>测试</li>
<li>运行维护</li>
</ul>
<p><img src="https://i.loli.net/2021/05/22/RCSVs6rPZQmG7XE.png" alt="1.png" /></p>
<h3 id="73-数据库规划"><a class="markdownIt-Anchor" href="#73-数据库规划"></a> 7.3 数据库规划</h3>
<p><strong>|数据库规划|</strong>：数据库规划是一种管理活动，目的是尽可能高效及有效地展开数据库系统开发生命周期的各个阶段。</p>
<p>数据库规划中重要的第一步是清晰定义项目的<strong>任务描述(mission statement)</strong>，任务描述定义了数据库系统的主要目标。</p>
<h3 id="74-系统定义"><a class="markdownIt-Anchor" href="#74-系统定义"></a> 7.4 系统定义</h3>
<p><strong>|系统定义|</strong>:定义数据库应用程序的范围和边界，以及主要的用户视图。</p>
<p><img src="https://i.loli.net/2021/05/22/EfLP8zIxm3NKTBu.png" alt="2.png" /></p>
<h4 id="用户视图"><a class="markdownIt-Anchor" href="#用户视图"></a> 用户视图</h4>
<p><strong>|用户视图|</strong>：从一个特定的角色或特定的企业应用领域的角度来定义数据库系统的需求。</p>
<p><img src="https://i.loli.net/2021/05/22/tWKGV5rnLHJRUhE.png" alt="3.png" /></p>
<h3 id="75-需求收集与分析"><a class="markdownIt-Anchor" href="#75-需求收集与分析"></a> 7.5 需求收集与分析</h3>
<p><strong>|需求收集与分析|</strong>：收集与分析数据库系统的需求</p>
<hr />
<p>针对每个主要用户视图，应采集的信息包括：</p>
<ul>
<li>使用或产生的数据</li>
<li>这些数据是如何使用或产生的</li>
<li>对新数据库系统的其他需求</li>
</ul>
<hr />
<p>处理多个用户视图通常有三种主要的方法：</p>
<ul>
<li>集中式方法(centralized approach)</li>
<li>视图集成方法(view integration approach)</li>
<li>两种方法的组合</li>
</ul>
<h4 id="751-集中式方法"><a class="markdownIt-Anchor" href="#751-集中式方法"></a> 7.5.1 集中式方法</h4>
<p><strong>|集中式方法|</strong>：合并所有用户视图的需求，形成对新系统的一组需求。在数据库设计阶段创建一个表示了所有用户需求的数据模型。</p>
<p><img src="https://i.loli.net/2021/05/22/wXF7vCJlAzISPoq.png" alt="4.png" /></p>
<h4 id="752-视图集成方法"><a class="markdownIt-Anchor" href="#752-视图集成方法"></a> 7.5.2 视图集成方法</h4>
<p><strong>|视图集成方法|</strong>：每个用户视图的需求都独立列出。在数据库设计阶段，首先针对每个用户视图的需求建立各自的数据模型，然后再加以整合。</p>
<p><img src="https://i.loli.net/2021/05/22/Nti4M6ms8cLoZ5P.png" alt="5.png" /></p>
<h3 id="76-数据库设计"><a class="markdownIt-Anchor" href="#76-数据库设计"></a> 7.6 数据库设计</h3>
<p><strong>|数据库设计|</strong>：完成数据库的概念设计、逻辑设计和物理设计</p>
<h4 id="761-数据库设计方法"><a class="markdownIt-Anchor" href="#761-数据库设计方法"></a> 7.6.1 数据库设计方法</h4>
<ul>
<li>自下而上：规范化过程，首先确定所需属性，然后基于属性之间的函数依赖将属性聚集成规范化的关系。</li>
<li>自上而下：建立ER模型，开始仅包含少量的高层实体以及实体之间的联系，进一步确定低层的实体、实体之间的联系以及相关属性。</li>
<li>由里向外：首先建立主要实体的集合，然后向外扩展，确定与已建立实体相关的其他实体、联系和属性。</li>
<li>混合策略</li>
</ul>
<h4 id="762-数据建模"><a class="markdownIt-Anchor" href="#762-数据建模"></a> 7.6.2 数据建模</h4>
<p>ER模型</p>
<h4 id="763-数据库设计的阶段划分"><a class="markdownIt-Anchor" href="#763-数据库设计的阶段划分"></a> 7.6.3 数据库设计的阶段划分</h4>
<p><strong>|概念数据库设计|</strong>：建立概念数据模型的过程、该模型与所有物理因素无关。</p>
<p>概念模型不涉及类似目标DBMS软件的选择，应用程序的编制、编程语言的选择等。</p>
<p><img src="https://i.loli.net/2021/05/22/ECLvemFd7jgnoYT.png" alt="6.png" /></p>
<p><strong>|逻辑数据库设计|</strong>：根据概念数据模型，建立逻辑数据模型，该模型与具体的DBMS以及其他物理因素无关。</p>
<p>我们需要确定目标DBMS是关系的、网状的、层次的还是面向对象的。在这一阶段，引入规范化技术来验证逻辑数据库模型的正确性。</p>
<p><img src="https://i.loli.net/2021/05/22/9XGEzPDo3SWR1Ba.png" alt="7.png" /></p>
<p><strong>|物理数据库设计|</strong>：产生数据库在辅存上的实现描述的过程。物理数据库设计定义了基础关系、文件组织方式和能够提高数据访问效率的索引，以及所有的完整性约束和安全措施。</p>
<p><img src="https://i.loli.net/2021/05/22/YtVJfNSyQOzLT8e.png" alt="8.png" /></p>
<p><img src="https://i.loli.net/2021/05/22/K1lhw67sGAzxEBT.png" alt="9.png" /></p>
<h3 id="77-dbms选型"><a class="markdownIt-Anchor" href="#77-dbms选型"></a> 7.7 DBMS选型</h3>
<p><strong>|DBMS选型|</strong>：选择适合的DBMS以支持相应的数据库系统。</p>
<h3 id="78-应用程序设计"><a class="markdownIt-Anchor" href="#78-应用程序设计"></a> 7.8 应用程序设计</h3>
<p><strong>|应用程序设计|</strong>：完成用户界面和数据库应用程序的总体设计。</p>
<p><strong>|事务|</strong>：由单个用户或应用程序执行的访问或修改数据库的一个或一组动作。</p>
<h3 id="79-建立原型系统"><a class="markdownIt-Anchor" href="#79-建立原型系统"></a> 7.9 建立原型系统</h3>
<p><strong>|建立原型系统|</strong>:建立数据库的一个工作模型。</p>
<h3 id="710-实现"><a class="markdownIt-Anchor" href="#710-实现"></a> 7.10 实现</h3>
<p><strong>|实现|</strong>：数据库和应用程序设计的物理实现。</p>
<h3 id="711-数据转换与加载"><a class="markdownIt-Anchor" href="#711-数据转换与加载"></a> 7.11 数据转换与加载</h3>
<p><strong>|数据转换与加载|</strong>：将已有的数据转移到新数据库中。</p>
<h3 id="714-case工具"><a class="markdownIt-Anchor" href="#714-case工具"></a> 7.14 CASE工具</h3>
<img src="https://i.loli.net/2021/05/22/YaqMObcgjSfNiuK.png" alt="10.png" style="zoom:67%;" />
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 数据定义</title>
    <url>/2021/05/06/%E6%95%B0%E6%8D%AE%E5%BA%93/Chpater6%20%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-数据定义"><a class="markdownIt-Anchor" href="#第六章-数据定义"></a> 第六章 数据定义</h2>
<h3 id="61-iso数据类型"><a class="markdownIt-Anchor" href="#61-iso数据类型"></a> 6.1 ISO数据类型</h3>
<a id="more"></a>
<p><img src="https://i.loli.net/2021/05/05/l8u6EwZv4BzpS9d.png" alt="1.png" /></p>
<ul>
<li>
<p>CHAR: CHAR [VARYING] [length]</p>
</li>
<li>
<p>定点数：DEC(5, 3)</p>
</li>
</ul>
<h3 id="62-完整性增强特性"><a class="markdownIt-Anchor" href="#62-完整性增强特性"></a> 6.2 完整性增强特性</h3>
<ul>
<li>必须有值的数据</li>
<li>域约束</li>
<li>实体完整性</li>
<li>引用完整性</li>
<li>企业级约束</li>
</ul>
<h4 id="621-必须有值的数据"><a class="markdownIt-Anchor" href="#621-必须有值的数据"></a> 6.2.1 必须有值的数据</h4>
<p>某些列的值必须为有效值，不允许为空</p>
<h4 id="622-域约束"><a class="markdownIt-Anchor" href="#622-域约束"></a> 6.2.2 域约束</h4>
<h5 id="check"><a class="markdownIt-Anchor" href="#check"></a> CHECK</h5>
<p>CHECK子句只能引用已定义列。</p>
<p>CHECK(searchCondition)</p>
<p>例：</p>
<p>​	sex CHAR NOT NULL CHECK(sex IN(‘M’, ‘F’));</p>
<h5 id="create-domain"><a class="markdownIt-Anchor" href="#create-domain"></a> CREATE DOMAIN</h5>
<p>可以创造值域</p>
<p>CREATE DOMAIN DomainName [AS] dataType</p>
<p>[DEFAULT defaultOption]</p>
<p>[CHECK(searchCondition)];</p>
<p>sex sexType NOT NULL;</p>
<h5 id="drop-domain"><a class="markdownIt-Anchor" href="#drop-domain"></a> DROP DOMAIN</h5>
<p>撤销域约束</p>
<p>DROP DOMAIN DomainName[RESTRICT | CASCADE]</p>
<p>如果指定为RESTRICT，而该域正在被用于某个现存的表、视图或断言的定义，那么撤销失败。若指定为CASCADE，则任一表中基于该域的列都会自动地变为用该域的基类型定义。</p>
<h4 id="623-实体完整性"><a class="markdownIt-Anchor" href="#623-实体完整性"></a> 6.2.3 实体完整性</h4>
<p>PRIMARY KEY(clientNo, propertyNo);</p>
<p><strong>UNIQUE</strong></p>
<p>每个表中只能使用一个PRIMARY KEY子句。但是，可用关键字UNIQUE保证列的唯一性。UNIQUE子句中出现的每个列必须被声明为NOT NULL。</p>
<p>UNIQUE(clientNo, propertyNo);</p>
<h4 id="624-引用完整性"><a class="markdownIt-Anchor" href="#624-引用完整性"></a> 6.2.4 引用完整性</h4>
<p>FOREIGN KEY(branchNo) REFERENCES Branch[(branchNo)]</p>
<p><strong>UPDATE / DELETE</strong></p>
<ul>
<li>CASCADE: 删除父表中的行并且自动删除子表中匹配的行。</li>
<li>SET NULL: 删除父表中的元组且设置子表中的外键为NULL。</li>
<li>SET DEFAULT: 删除父表中的元组且设子表中的外键为默认值。</li>
<li>NO ACTION: 拒绝对父表进行删除操作。ON DELETE规则的默认设置为ON ACTION。</li>
</ul>
<p>FOREIGN KEY(branchNo) REFERENCES Branch[(branchNo)] ON UPDATE CASCADE；</p>
<h4 id="625-企业级约束"><a class="markdownIt-Anchor" href="#625-企业级约束"></a> 6.2.5 企业级约束</h4>
<p><strong>|断言|</strong>：跨表约束</p>
<p>CREATE ASSERTION AssertionName</p>
<p>CHECK(searchCondition)</p>
<h3 id="63-数据定义"><a class="markdownIt-Anchor" href="#63-数据定义"></a> 6.3 数据定义</h3>
<ul>
<li>
<p>CREATE SCHEMA / DOMAIN / TABLE / VIEW / INDEX</p>
</li>
<li>
<p>DROP SCHEMA / DOMAIN / TABLE / VIEW / INDEX</p>
</li>
<li>
<p>ALTER DOMAIN / TABLE</p>
</li>
</ul>
<h4 id="631-创建数据库"><a class="markdownIt-Anchor" href="#631-创建数据库"></a> 6.3.1 创建数据库</h4>
<p>CREATE SCHEMA[Name | AUTHORIZATION Creatorldentifier]</p>
<p>DROP SCHEMA Name[RESTRICT | CASCADE]</p>
<p>如果指定了RESTRICT，则模式必须为空才能删除。</p>
<h4 id="632-创建表"><a class="markdownIt-Anchor" href="#632-创建表"></a> 6.3.2 创建表</h4>
<p>CREATE TABLE TableName<br />
({colName dataType [NOT NULL] [UNIQUE] [PRIMARY KEY]<br />
[DEFAULT defaultOption]<br />
[CHECK searchCondition] [,…]}<br />
[PRIMARY KEY (listOfColumns),]<br />
{[UNIQUE (listOfColumns),] […,]}<br />
{[FOREIGN KEY (listOfFKColumns)<br />
REFERENCES ParentTableName<br />
[(listOfCKColumns)],<br />
[ON UPDATE referentialAction]<br />
[ON DELETE referentialAction ]] [,…]}<br />
{[CHECK (searchCondition)] [,…] })</p>
<p><strong>表约束可以用CONSTRAINT ConstraintName作为前缀</strong></p>
<h4 id="633-修改表定义"><a class="markdownIt-Anchor" href="#633-修改表定义"></a> 6.3.3 修改表定义</h4>
<ul>
<li>添加/删除列</li>
<li>添加/删除表约束</li>
<li>设置/删除列默认值</li>
</ul>
<p>ALTER TABLE TabName<br />
[ADD [COLUMN] columnName dataType<br />
[NOT NULL][UNIQUE]<br />
[DEFAULT defaultOption][CHECK (searchCondition)]]<br />
[DROP [COLUMN] columnName [RESTRICT | CASCADE ]]<br />
[ADD [CONSTRAINT [constraintName]] tableConstraintDefinition]<br />
[DROP CONSTRAINT constraintName [RESTRICT | CASCADE ]]<br />
[ALTER [COLUMN] SET DEFAULT defaultOption]<br />
[ALTER [COLUMN] DROP DEFAULT]</p>
<h4 id="634-删除表"><a class="markdownIt-Anchor" href="#634-删除表"></a> 6.3.4 删除表</h4>
<p>DROP TABLE TableName [RESTRICT | CASCADE];</p>
<h4 id="635-创建索引"><a class="markdownIt-Anchor" href="#635-创建索引"></a> 6.3.5 创建索引</h4>
<p><strong>|索引|</strong>：索引是一种结构，它提供了基于一个或多个列值快速访问表中元组的方法。</p>
<p>CREATE [UNIQUE] INDEX IndexName ON TableName (columnName [ASC |DESC][,…])</p>
<p>索引只能基于基表建立，而不能基于视图。对于每个列，可以指定升序或降序排列。</p>
<h4 id="636-删除索引"><a class="markdownIt-Anchor" href="#636-删除索引"></a> 6.3.6 删除索引</h4>
<p>DROP INDEX IndexName;</p>
<h3 id="64-视图"><a class="markdownIt-Anchor" href="#64-视图"></a> 6.4 视图</h3>
<p><strong>|视图|</strong>：为了得到另一个关系而对际关系进行一次或多次关系操作所得到的动态结果。视图是虚关系，即在数据库中不存在，需要时根据特定用户的要求临时生成。</p>
<p>​		当DBMS遇到视图引用时，一种方法是查找视图定义，并且将请求转换为对于视图源表的等价请求，然后完成等价的请求操作。这个转换的过程称为<strong>试图分解</strong>。</p>
<p>​		另一种可供选择的方法称为<strong>视图物化</strong>，即把视图存储在数据库的临时表中，并在基表变化时更新临时表以及时维护试图。</p>
<h4 id="641-创建视图"><a class="markdownIt-Anchor" href="#641-创建视图"></a> 6.4.1 创建视图</h4>
<p>CREATE VIEW ViewName [ (newColumnName [,…]) ]<br />
AS subselect [WITH [CASCADED | LOCAL] CHECK OPTION]</p>
<ul>
<li>subselect称为定义查询。如果说明WITH CHECK POTION， SQL将确保那些不满足定义查询中WHERE子句的行不会被添加到视图的基表中。</li>
</ul>
<p>例：</p>
<p>CREATE VIEW StaffPropCnt (branchNo, staffNo, cnt)<br />
AS SELECT s.branchNo, s.staffNo, COUNT(*)<br />
FROM Staff s, PropertyForRent p<br />
WHERE s.staffNo = p.staffNo<br />
GROUP BY s.branchNo, s.staffNo;</p>
<h4 id="642-删除视图"><a class="markdownIt-Anchor" href="#642-删除视图"></a> 6.4.2 删除视图</h4>
<p>DROP VIEW ViewName [RESTRICT| CASCADE]</p>
<h4 id="643-视图分解"><a class="markdownIt-Anchor" href="#643-视图分解"></a> 6.4.3 视图分解</h4>
<p>例：</p>
<p>SELECT staffNo, cnt<br />
FROM StaffPropCnt<br />
WHERE branchNo = ‘B003’<br />
ORDER BY staffNo;</p>
<p>​			↓</p>
<p>SELECT s.staffNo, COUNT(*)<br />
FROM staff s, PropertyForRent p<br />
WHERE s.staffNo = p.staffNo AND branchNo = ‘B003’<br />
GROUP BY s.branchNo, s.staffNo<br />
ORDER BY s.staffNo;</p>
<h4 id="644-视图的局限性"><a class="markdownIt-Anchor" href="#644-视图的局限性"></a> 6.4.4 视图的局限性</h4>
<p>如果视图中某个列是基于聚集函数的，那么在访问该视图的查询语句中，该列只能出现在SELECT和ORDER BY子句里。具体地说，在基于该视图的查询语句中，该列不能出现在WHERE子句中，也不能作为任何聚集函数的参数。</p>
<h4 id="645-视图的可更新性"><a class="markdownIt-Anchor" href="#645-视图的可更新性"></a> 6.4.5 视图的可更新性</h4>
<p><strong>|可更新视图|</strong>：为了使视图可更新，对于任何一个行或列，DBMS必须都能追溯到其源表中相应的行或列。</p>
<h4 id="646-with-check-option"><a class="markdownIt-Anchor" href="#646-with-check-option"></a> 6.4.6 WITH CHECK OPTION</h4>
<p><strong>|行迁移|</strong>：视图中的行均满足定义查询中的WHERE条件。如果某行被修改后不再满足这种条件，那么它应当从视图中取出。进入或离开视图的行称为迁移行。通常来说，CREATE VIEW语句中的WITH CHECK POTION子句用于禁止行迁移出视图。</p>
<p>例：</p>
<p>CREATE VIEW LowSalary<br />
AS SELECT * FROM Staff WHERE salary &gt; 9000;</p>
<p>CREATE VIEW HighSalary<br />
AS SELECT * FROM LowSalary<br />
WHERE salary &gt; 10000<br />
WITH LOCAL CHECK OPTION;</p>
<p>CREATE VIEW Manager3Staff<br />
AS SELECT * FROM HighSalary<br />
WHERE branchNo = ‘B003’;</p>
<p>失败</p>
<p>UPDATE Manager3Staff SET salary = 9500<br />
WHERE staffNo = ‘SG37’;</p>
<p>成功</p>
<p>UPDATE Manager3Staff SET salary = 8000<br />
WHERE staffNo = ‘SG37’;</p>
<p>因为该行也会从LowSalary中去除。</p>
<h4 id="647-视图的优缺点"><a class="markdownIt-Anchor" href="#647-视图的优缺点"></a> 6.4.7 视图的优缺点</h4>
<p>优点：</p>
<ul>
<li>数据独立性</li>
<li>实时性</li>
<li>提高了安全性</li>
<li>降低了复杂性</li>
<li>方便</li>
<li>用户化</li>
<li>数据完整性</li>
</ul>
<p>缺点：</p>
<ul>
<li>更新局限性</li>
<li>结构局限性</li>
<li>性能开销</li>
</ul>
<h4 id="648-视图物化"><a class="markdownIt-Anchor" href="#648-视图物化"></a> 6.4.8 视图物化</h4>
<p><strong>|视图物化|</strong>：把第一次访问视图的结果存储为数据库的临时表。</p>
<h3 id="65-事务"><a class="markdownIt-Anchor" href="#65-事务"></a> 6.5 事务</h3>
<h4 id="651-结束事务四种方式"><a class="markdownIt-Anchor" href="#651-结束事务四种方式"></a> 6.5.1 结束事务四种方式</h4>
<ul>
<li>COMMIT语句成功提交事务</li>
<li>ROLLBACK语句撤销事务</li>
<li>程序成功终止</li>
<li>不正常的程序终止撤销事务</li>
</ul>
<h4 id="652-格式"><a class="markdownIt-Anchor" href="#652-格式"></a> 6.5.2 格式</h4>
<p>SET TRANSACTION<br />
[READ ONLY | READ WRITE] |<br />
[ISOLATION LEVEL READ UNCOMMITTED<br />
|READ COMMITTED|REPEATABLE READ<br />
|SERIALIZABLE ]</p>
<p>隔离级表明事务执行过程中允许其他事务交互的程度。只有SERIALIZABLE隔离级是安全的。</p>
<h3 id="66-自主访问控制"><a class="markdownIt-Anchor" href="#66-自主访问控制"></a> 6.6 自主访问控制</h3>
<p><strong>授权标识符和所有权</strong></p>
<p>​		授权标识符是SQL用于辨别用户的一般标识符。每个数据库用户都由数据库管理员分配一个授权标识符。为了安全起见，授权标识符都和一个密码相关联。可用授权标识符来确定用户可访问哪些数据库对象，以及对哪些对象进行什么操作。</p>
<p>​		SQL中创建的每个对象都有一个所有者。所有者就是创建该对象所属的模式时AUTHORIZATION子句定义的授权标识符。最初只有所有者知道对象存在，并能对其进行任何操作。</p>
<p><strong>权限</strong></p>
<p>允许用户对指定基表或视图进行的操作。</p>
<ul>
<li>
<p>SELECT</p>
</li>
<li>
<p>INSERT</p>
</li>
<li>
<p>UPDATE</p>
</li>
<li>
<p>DELETE</p>
</li>
<li>
<p>REFERENCES</p>
</li>
<li>
<p>USAGE</p>
</li>
</ul>
<p>​        INSERT和UPDATE权限可以限制表中指定的列，允许改变这些列但不允许改变其他列。相似地，REFERENCES权限可以限制表中指定的列。</p>
<p>​		当用户用CREATE VIEW创建视图时，他自动成为视图的所有者但并不一定具有视图的所有权限。创建视图时，用户必须具有对组成视图的所有表的SELECT权限，以及视图中列的REFERENCES权限等。</p>
<h4 id="661-授予其他用户权限grant"><a class="markdownIt-Anchor" href="#661-授予其他用户权限grant"></a> 6.6.1 授予其他用户权限(GRANT)</h4>
<p>GRANT {PrivilegeList | ALL PRIVILEGES}<br />
ON ObjectName<br />
TO {AuthorizationIdList | PUBLIC}<br />
[WITH GRANT OPTION]</p>
<p>PrivilegeList由下列用逗号分开的一个或多个权限组成：<br />
SELECT</p>
<p>DELETE</p>
<p>INSERT		[{cloName{…}}]</p>
<p>UPDATE		[{cloName{…}}]</p>
<p>REFERENCES	[{cloName{…}}]</p>
<p>USAGE</p>
<p>PUBLIC允许所有现在或未来授权用户访问数据，而不局限于DBMS系统当前已有的用户。</p>
<p>WITH GRANT OPTION子句允许AuthorizationIdList中的用户讲他们拥有的对指定对象的权限传递给其他用户。</p>
<h4 id="662-撤销用户权限revoke"><a class="markdownIt-Anchor" href="#662-撤销用户权限revoke"></a> 6.6.2 撤销用户权限(REVOKE)</h4>
<p>REVOKE takes away privileges granted with GRANT.<br />
REVOKE [GRANT OPTION FOR]<br />
{PrivilegeList | ALL PRIVILEGES}<br />
ON ObjectName<br />
FROM {AuthorizationIdList | PUBLIC}<br />
[RESTRICT | CASCADE]</p>
<p>​		可选的子句GRANT OPTION FOR允许通过GRANT语句中的WITH GRANT OPTION传递的那些权限被独立地撤销。</p>
<p>​		用户从其他用户那里获得的权限不受这个REVOKE语句的影响。</p>
<p>例：</p>
<p>A→B→C→D			E→D</p>
<p>A撤销给B的权限后C、D不受影响</p>
<p><img src="https://i.loli.net/2021/05/05/heclxiAfvDZE1OK.png" alt="2.png" /></p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>Discuss the functionality and importance of the Integrity Enhancement Feature (IEF).</p>
<p>完整性约束共有五种类型：必须有值的数据、域约束、实体完整性、引用完整性和企业级约束。必须有值的数据让某些列的值必须为有效值，不允许为空。域约束限制每列合法值的集合。实体完整性让表中每一行的主关键字必须是唯一的非空值。引用完整性让外键必须是父表中已存在的有效的元组。企业级约束用来约束表的更新。</p>
</li>
<li>
<p>Discuss the advantages and disadvantages of views.</p>
<p>优点：</p>
<ul>
<li>数据独立性</li>
<li>实时性</li>
<li>提高了安全性</li>
<li>降低了复杂性</li>
<li>方便</li>
<li>用户化</li>
<li>数据完整性</li>
</ul>
<p>缺点：</p>
<ul>
<li>更新局限性</li>
<li>结构局限性</li>
<li>性能开销</li>
</ul>
</li>
<li>
<p>What restrictions are necessary to ensure that a view is updatable?</p>
<ul>
<li>没有指定DISTINCT，即重复元组未从查询结果中消除。</li>
<li>定义查询的SELECT列表中的每个元素均为列名，且列名出现的次数不多于一次。</li>
<li>FROM子句只指定一个表，即视图只有一个源表且用户对该表有要求的权限。</li>
<li>WHERE子句不能包括任何引用了FROM子句中的表的嵌套SELECT操作。</li>
<li>定义查询中不能有GROUP BY或HAVING子句。</li>
</ul>
</li>
<li>
<p>Discuss how the Access Control mechanism of SQL works.</p>
<p>SQL通过GRANT和REVOKE语句来支持自主访问控制。该机制基于授权标识符、所有权和权限的概念。</p>
<p>授权标识符：授权标识符是SQL用于辨别用户的一般标识符。每个数据库用户都由数据库管理员分配一个授权标识符。为了安全起见，授权标识符都和一个密码相关联。可用授权标识符来确定用户可访问哪些数据库对象，以及对哪些对象进行什么操作。</p>
<p>所有权：SQL中创建的每个对象都有一个所有者。所有者就是创建该对象所属的模式时AUTHORIZATION子句定义的授权标识符。最初只有所有者知道对象存在，并能对其进行任何操作。</p>
<p>权限：允许用户对指定基表或视图进行的操作。有SELECT、INSERT、UPDATE、DELETE、REFERENCES和USAGE。其中，INSERT和UPDATE权限可以限制表中指定的列，允许改变这些列但不允许改变其他列。相似地，REFERENCES权限可以限制表中指定的列。</p>
</li>
</ol>
<p>Answer the following questions using the relational schema from the Exercises at the end of Chapter 3.</p>
<p><img src="https://i.loli.net/2021/05/05/f1wbWg5rZ3l9RFX.png" alt="4.png" /></p>
<ol start="5">
<li>
<p>Create the Hotel table using the integrity enhancement features of SQL.</p>
<p>CREATE DOMAIN HotelNoType AS CHAR(4);</p>
<p>CREATE TABLE Hotel(</p>
<p>hotelNo HotelNoType NOT NULL PRIMARY KEY,</p>
<p>hotelName VARCHAR(15) NOT NULL,</p>
<p>city VARCHAR(30) NOT NULL</p>
<p>);</p>
</li>
<li>
<p>Now create the Room, Booking, and Guest tables using the integrity enhancement features of SQL with the following constraints:<br />
(a) Type must be one of Single, Double, or Family.<br />
(b) Price must be between £10 and £100.<br />
© roomNo must be between 1 and 100.<br />
(d) dateFrom and dateTo must be greater than today’s date.<br />
(e) The same room cannot be double booked.<br />
(f) The same guest cannot have overlapping bookings.</p>
<p>CREATE TABLE Guest(</p>
<p>guestNo INTEGER(10) NOT NULL PRIMARY KEY,</p>
<p>guestName VARCHAR(20) NOT NULL,</p>
<p>guestAddress VARCHAR(30) NOT NULL</p>
<p>)</p>
<p>CREATE TABLE Room(</p>
<p>roomNo INTEGER(4) NOT NULL CHECK(roomNo BETWEEN 1 AND 100),</p>
<p>hotelNo INTEGER(5) NOT NULL,</p>
<p>type VARCHAR(10) CHECK(type IN(‘Single’, ‘Double’, ‘Family’)),</p>
<p>price DECIMAL(8, 2) CHECK(price BETWEEN 10 AND 100),</p>
<p>PRIMARYR KEY(roomNo, hotelNo),</p>
<p>FOREIGN KEY(hotelNo) REFERENCES Hotel(hotelNo)</p>
<p>ON DELETE CASCADE ON UPDATE CASCADE</p>
<p>);</p>
<p>CREATE TABLE Booking(</p>
<p>hotelNo INTEGER(5) NOT NULL,</p>
<p>guestNo INTEGER(10) NOT NULL,</p>
<p>dateFrom DATE NOT NULL CHECK(VALUE &gt; currentDate),</p>
<p>dateTo DATE NOT NULL CHECK(VALUE &gt; currentDate),</p>
<p>roomNo INTEGER(4) NOT NULL,</p>
<p>PRIMARY KEY(hotelNo, guestNo, dateFrom),</p>
<p>FOREIGN KEY(hotelNo) REFERENCES Hotel(hotelNo) ON DELETE CASCADE ON UPDATE CASCADE,</p>
<p>FOREIGN KEY(roomNo, hotelNo) REFERENCES Room(roomNo, hotelNo) ON DELETE CASCADE ON UPDATE CASCADE,</p>
<p>FOREIGN KEY(guestNo) REFERENCES Guest(guestNo) ON DELETE CASCADE ON UPDATE CASCADE,</p>
<p>CHECK(NOT EXISTS(SELECT * FROM Booking b WHERE b.dateTo &gt; Booking.dateFrom AND b.dateFrom &lt; Booking.dateTo AND</p>
<p>b.roomNo = Booking.roomNo AND b.hotelNo = Booking.hotelNo)),</p>
<p>CHECK(NOT EXISTS(SELECT * FROM Booking b WHERE b.dateTo &gt; Booking.dateFrom AND b.dateFrom &lt; Booking.dateTo AND b.guestNo = Booking.guestNo))</p>
<p>) ;</p>
</li>
<li>
<p>Consider the following view defined on the Hotel schema:<br />
CREATE VIEW HotelBookingCount (hotelNo, bookingCount)<br />
AS SELECT h.hotelNo, COUNT(*)<br />
FROM Hotel h, Room r, Booking b<br />
WHERE h.hotelNo = r.hotelNo AND r.roomNo = b.roomNo<br />
GROUP BY h.hotelNo;<br />
For each of the following queries, state whether the query is valid and for the valid ones should how each of the queries would be mapped onto a query on the underling base tables.<br />
(a) SELECT * FROM HotelBookingCount;</p>
</li>
</ol>
<p>​	有效，视图分解为</p>
<p>​	SELECT h.hotelNo, COUNT(*)</p>
<p>​		FROM Hotel h, Room r, Booking b</p>
<p>​		WHERE h.hotelNo = r.hotelNo AND r.roomNo = b.roomNo</p>
<p>​		GROUP BY h.hotelNo;</p>
<p>(b) SELECT hotelNo FROM HotelBookingCount WHERE hotelNo = ‘H001’;</p>
<p>​	有效，视图分解为</p>
<p>​	SELECT h.hotelNo</p>
<p>​		FROM Hotel h, Room r, Booking b</p>
<p>​		WHERE h.hotelNo = r.hotelNo AND r.roomNo = b.roomNo</p>
<p>​		AND hotelNo = ‘H001’</p>
<p>​		GROUP BY h.hotelNo;</p>
<p>© SELECT MIN(bookingCount) FROM HotelBookingCount;</p>
<p>​	无效，bookingCount是基于聚集函数的，所以不能作为聚集函数的参数</p>
<p>(d) SELECT COUNT(*) FROM HotelBookingCount;</p>
<p>​	无效，视图中的bookingCount是基于聚集函数的，不能作为聚集函数的参数</p>
<p>(e) SELECT hotelNo FROM HotelBookingCount WHERE bookingCount &gt; 1000;</p>
<p>​	无效，bookingCount是基于聚集函数的，不能出现在WHERE子句中</p>
<p>(f) SELECT hotelNo FROM HotelBookingCount ORDER BY bookingCount;</p>
<p>​	有效，视图分解为</p>
<p>​		SELECT h.hotelNo,</p>
<p>​		FROM Hotel h, Room r, Booking b</p>
<p>​		WHERE h.hotelNo = r.hotelNo AND r.roomNo = 	b.roomNo</p>
<p>​		GROUP BY h.hotelNo</p>
<p>​		ORDER BY COUNT(*);</p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第九章 规范化</title>
    <url>/2021/06/02/%E6%95%B0%E6%8D%AE%E5%BA%93/Chapter9%20%E8%A7%84%E8%8C%83%E5%8C%96/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第九章-规范化"><a class="markdownIt-Anchor" href="#第九章-规范化"></a> 第九章 规范化</h2>
<h3 id="91-规范化的目的"><a class="markdownIt-Anchor" href="#91-规范化的目的"></a> 9.1 规范化的目的</h3>
<a id="more"></a>
<p><strong>|规范化|</strong>：生成一组既具有所期望的特性又能满足企业数据需求的关系的技术。</p>
<p>数据库拥有一组合适关系的好处：数据库易于用户访问，数据易于维护，在计算机上占有较小的存储空间。</p>
<p>规范化可以识别键和属性间的依赖关系。规范化是消除数据冗余的过程，可以消除数据冗余带来的异常。</p>
<h3 id="92-数据冗余与更新异常anomalies"><a class="markdownIt-Anchor" href="#92-数据冗余与更新异常anomalies"></a> 9.2 数据冗余与更新异常(anomalies)</h3>
<p>关系数据库设计的一个主要目标就是降低数据冗余与减少存储基本关系所需的文件存储空间。</p>
<p>Staff		(staffNo, sName, position, salary, branchNo)</p>
<p>Branch	(branchNo, bAddress)</p>
<p>StaffBranch	(staffNo, sName, position, salary, branchNo, bAddress)</p>
<p>在关系StaffBranch中存在冗余数据：同一个分公司的信息在每一个属于该分公司员工的信息里反复出现。相反，在关系Branch中，每个分公司的信息只出现了一次，而且在关系Staff中只有分公司的编号这一属性的值重复出现。</p>
<h4 id="921-插入异常"><a class="markdownIt-Anchor" href="#921-插入异常"></a> 9.2.1 插入异常</h4>
<p>插入异常主要有两类</p>
<ul>
<li>在StaffBranch中插入新员工信息时，必须包括分公司信息，并且必须确保B007分公司信息和关系StaffBranch已有的B007的元组的分公司信息保持一致。</li>
<li>在向StaffBranch中插入一个新的分公司信息时，若该公司没员工，有必要在录入staffNo时设置为null，但staffNo是主键，会违反实体完整性约束。</li>
</ul>
<h4 id="922-删除异常"><a class="markdownIt-Anchor" href="#922-删除异常"></a> 9.2.2 删除异常</h4>
<p>若删除某分公司最后一名员工后，公司信息也会丢失。</p>
<h4 id="923-修改异常"><a class="markdownIt-Anchor" href="#923-修改异常"></a> 9.2.3 修改异常</h4>
<p>如果要修改StaffBranch中B003的某个属性值，那么必须更新所有B003的员工的元组。若修改操作未能在所有元组上执行，数据库则会产生不一致。</p>
<hr />
<p>当把较大的关系分解成较小的关系时，有两个很重要的特性：</p>
<ul>
<li><strong>无损连接</strong>(lossless-join)特性：确保原关系的任一实例能通过较小关系的对应实例确定出来。</li>
<li><strong>依赖保持</strong>(dependency preservation)特性：确保只需简单地在较小关系上支持某些约束，就可以继续支持在原关系上存在的约束。</li>
</ul>
<h3 id="93-函数依赖"><a class="markdownIt-Anchor" href="#93-函数依赖"></a> 9.3 函数依赖</h3>
<p><strong>|函数依赖|</strong>：描述一个关系中属性之间的联系。若A的每个值都和B中的一个唯一的值相对应，则称B函数依赖于A，记为A→B（A、B可能由一个或多个属性组成）。</p>
<p><strong>|决定方|</strong>：位于函数依赖箭头左边的属性或属性组。</p>
<p><strong>|完全函数依赖|</strong>：假设A和B是某一关系的属性（组），若B函数依赖于A，但不函数依赖于A的任一真子集，则称B完全函数依赖于A。</p>
<p>如果去掉A中的某些属性，依赖仍然成立，那么函数依赖A→B就是<strong>部分函数依赖</strong>。</p>
<p><strong>|传递依赖|</strong>：若A→B，B→C，则称C通过B传递依赖于A。</p>
<ul>
<li>
<p>由一组函数依赖X所隐含的函数依赖集合称为X的闭包（X<sup>+</sup>）</p>
</li>
<li>
<p>函数依赖具有自反性、增广性、传递性</p>
</li>
</ul>
<h4 id="利用函数依赖确定主键"><a class="markdownIt-Anchor" href="#利用函数依赖确定主键"></a> 利用函数依赖确定主键</h4>
<p>所有不属于主键的属性都应该函数依赖于主键。</p>
<h3 id="95-第一范式1nf"><a class="markdownIt-Anchor" href="#95-第一范式1nf"></a> 9.5 第一范式(1NF)</h3>
<p><strong>|非范式(UNF)|</strong>：包含一个或多个<strong>重复组</strong>的表。</p>
<p><strong>|第一范式(1NF)|</strong>：属于第一范式的关系，其每一行和每一列相交的位置有且仅有一个值。</p>
<p>为了将非规范化的表转化为第一范式，我们需要确定并删除表中的重复组。</p>
<p>两种方法：</p>
<ol>
<li>
<p>在含有重复数据的那些行的空白列上输入合适的数据。</p>
</li>
<li>
<p>将重复数据单独移到一个新的关系中，同时也将原来关系中的关键属性复制到这个新的关系中。</p>
</li>
</ol>
<h3 id="96-第二范式2nf"><a class="markdownIt-Anchor" href="#96-第二范式2nf"></a> 9.6 第二范式(2NF)</h3>
<p><strong>|第二范式|</strong>：满足第一范式的要求并且每个非主键属性都完全函数依赖于主键的关系。</p>
<p>将1NF关系规范化为2NF关系需要消除部份依赖，如果存在部份依赖，就要将部份依赖的属性从原关系移出，移到一个新的关系中去，同时将这些属性的决定方复制到新的关系中。</p>
<p><img src="https://i.loli.net/2021/05/22/Iz48LfhrcXowmnb.png" alt="2.png" /></p>
<p>主键：clientNo, propertyNo</p>
<h3 id="97-第三范式3nf"><a class="markdownIt-Anchor" href="#97-第三范式3nf"></a> 9.7 第三范式(3NF)</h3>
<p><strong>|第三范式|</strong>：满足第一范式和第二范式的要求并且所有非主键属性都不传递依赖于主键的关系。</p>
<p>将2NF关系规范化为3NF关系需要消除传递依赖，如果存在传递依赖，就要将传递依赖的属性移到一个新的关系中去，同时将这些属性的决定方也复制到新的关系中。</p>
<p><img src="https://i.loli.net/2021/05/22/2JjliXuqkxz8sNB.png" alt="3.png" /></p>
<h3 id="98-2nf和3nf的一般化定义"><a class="markdownIt-Anchor" href="#98-2nf和3nf的一般化定义"></a> 9.8 2NF和3NF的一般化定义</h3>
<p><strong>|第二范式|</strong>：满足第一范式的要求并且每个非主属性都完全函数依赖于任何一个候选键的关系。</p>
<p><strong>|第三范式|</strong>：满足第一范式和第二范式的要求并且所有非主属性都不传递依赖于任何一个候选键的关系。</p>
<p><strong>|非主属性|</strong>：候选键之外的属性。</p>
<h3 id="99-byoce-codd-normal-form范式bcnf"><a class="markdownIt-Anchor" href="#99-byoce-codd-normal-form范式bcnf"></a> 9.9 Byoce-Codd Normal Form范式(BCNF)</h3>
<p><strong>|BCNF|</strong>:当且仅当每个函数依赖的决定方都是候选键时，某一关系才是BCNF。</p>
<p>3NF和BCNF的区别在于，对于一个函数依赖A→B，3NF允许B是主键而A不是候选键</p>
<p>而BCNF坚持在依赖关系中A必须是候选键</p>
<p>例：</p>
<p><img src="https://i.loli.net/2021/05/22/31xdjKoJIrpiF5M.png" alt="4.png" /></p>
<p>2NF：</p>
<p><img src="https://i.loli.net/2021/05/22/QiFuy3p5ELdR49g.png" alt="5.png" /></p>
<p>3NF：</p>
<p><img src="https://i.loli.net/2021/05/22/WD7pFE9kxs5QYGr.png" alt="6.png" /></p>
<p>BCNF：</p>
<p><img src="https://i.loli.net/2021/05/22/MsonR1yZ53ai4fp.png" alt="7.png" /></p>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<ol>
<li>
<p>Describe the types of update anomalies that may occur on a relation that has redundant data.</p>
<p>StaffBranch	(staffNo, sName, position, salary, branchNo, bAddress)</p>
<p>插入异常</p>
<ul>
<li>在StaffBranch中插入新员工信息时，必须包括分公司信息，并且必须确保B007分公司信息和关系StaffBranch已有的B007的元组的分公司信息保持一致。</li>
<li>在向StaffBranch中插入一个新的分公司信息时，若该公司没员工，有必要在录入staffNo时设置为null，但staffNo是主键，会违反实体完整性约束。</li>
</ul>
<p>删除异常</p>
<ul>
<li>若删除某分公司最后一名员工后，公司信息也会丢失。</li>
</ul>
<p>修改异常</p>
<ul>
<li>如果要修改StaffBranch中B003的某个属性值，那么必须更新所有B003的员工的元组。若修改操作未能在所有元组上执行，数据库则会产生不一致。</li>
</ul>
</li>
<li>
<p>Describe the concept of functional dependency.</p>
<p>函数依赖：描述一个关系中属性之间的联系。若A的每个值都和B中的一个唯一的值相对应，则称B函数依赖于A，记为A→B（A、B可能由一个或多个属性组成）。</p>
</li>
<li>
<p>How is the concept of functional dependency associated with the process of normalization?</p>
<p>函数依赖描述了属性之间的联系，而规范化是依靠键和属性之间的函数依赖对关系进行验证的形式化技术。</p>
</li>
<li>
<p>Describe the concept of full functional dependency and describe how this concept relates to 2NF. Provide an example to illustrate your answer.</p>
<p><strong>完全函数依赖</strong>：假设A和B是某一关系的属性（组），若B函数依赖于A，但不函数依赖于A的任一真子集，则称B完全函数依赖于A。规范化过程中的2NF要求满足1NF，并且每个非主键属性都完全函数依赖于主键的关系。</p>
<p>2NF举例</p>
<p>fd1 a, b→c, d</p>
<p>fd2 a→e</p>
<p>fd3 e→f</p>
<p>2NF: A(a, b, c, d)</p>
<p>​		B(a, e, f)</p>
</li>
<li>
<p>Describe the concept of transitive dependency and describe how this concept relates to 3NF. Provide an example to illustrate your answer.</p>
<p><strong>传递依赖</strong>：若A→B，B→C，则称C通过B传递依赖于A。3NF要求满足2NF，并且所有非主键属性都不传递依赖于主键的关系。</p>
<p>3NF举例</p>
<p>fd1 a, b→c, d</p>
<p>fd2 a→e</p>
<p>fd3 e→f</p>
<p>3NF: A(a, b, c, d)</p>
<p>​			B(a, e)</p>
<p>​			C(e, f)</p>
</li>
<li>
<p>Examine the Patient Medication Form for the Wellmeadows Hospital case study shown in Figure in next page.<br />
(a) Identify the functional dependencies represented by the data shown in the form in Figure 13.25.</p>
</li>
</ol>
<p>​	  (b) Describe and illustrate the process of normalizing the data shown in Figure 13.25 to first (1NF), second (2NF), third (3NF), and BCNF.<br />
© Identify the primary, alternate, and foreign keys in your BCNF relations.</p>
<p><img src="https://i.loli.net/2021/05/22/1cVBktrguoy9D2I.png" alt="8.png" /></p>
]]></content>
      <categories>
        <category>数据库</category>
      </categories>
  </entry>
  <entry>
    <title>第五章 数据通信网络与软件</title>
    <url>/2019/11/17/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA/%E7%AC%AC%E4%BA%94%E7%AB%A0%20%E6%95%B0%E6%8D%AE%E9%80%9A%E4%BF%A1%E7%BD%91%E7%BB%9C%E4%B8%8E%E8%BD%AF%E4%BB%B6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="51-数字化通讯与编码"><a class="markdownIt-Anchor" href="#51-数字化通讯与编码"></a> 5.1 数字化通讯与编码</h3>
<h4 id="511电报-电传与ascii码"><a class="markdownIt-Anchor" href="#511电报-电传与ascii码"></a> 5.1.1电报、电传与ASCⅡ码</h4>
<h4 id="512-汉字编码与unicode"><a class="markdownIt-Anchor" href="#512-汉字编码与unicode"></a> 5.1.2 汉字编码与Unicode</h4>
<ul>
<li>双字节汉字码</li>
</ul>
<a id="more"></a>
<h3 id="52通信交换网络"><a class="markdownIt-Anchor" href="#52通信交换网络"></a> 5.2通信交换网络</h3>
<h4 id="521-邮政业务网络"><a class="markdownIt-Anchor" href="#521-邮政业务网络"></a> 5.2.1 邮政业务网络</h4>
<ul>
<li>每个用户的信件是一个包，每个包有：收件人地址、收件人、发件人地址</li>
</ul>
<h4 id="522电话交换网络"><a class="markdownIt-Anchor" href="#522电话交换网络"></a> 5.2.2电话交换网络</h4>
<ul>
<li>人工交换——机电式自动交换——电子式自动交换（专供两者使用）</li>
</ul>
<h3 id="53-数据包交换网络"><a class="markdownIt-Anchor" href="#53-数据包交换网络"></a> 5.3 数据包交换网络</h3>
<h4 id="531-基于数据包的网络原理"><a class="markdownIt-Anchor" href="#531-基于数据包的网络原理"></a> 5.3.1 基于数据包的网络原理</h4>
<p><img src="https://i.loli.net/2019/11/17/auN5AXKwspPiUJG.png" alt="Node.JPG" /></p>
<h4 id="532-包的设计"><a class="markdownIt-Anchor" href="#532-包的设计"></a> 5.3.2 包的设计</h4>
<ul>
<li>数据传输，数据封装：对数据进行拆封和组装</li>
<li>应用层：被传输的是一系列ASCⅡ码、汉字码、二进制码的数据</li>
<li>物理层：被传输的是能够表达0和1代码的电路信号</li>
<li>在物理层和应用层之间，需要对数据进行多次封装</li>
</ul>
<p><img src="https://i.loli.net/2019/11/17/71EcJj4SmnPzWqO.png" alt="包的设计.png" /></p>
<ul>
<li>数据包：源地址、目标地址/目的地地址、传输的数据。</li>
</ul>
<h4 id="533-路由"><a class="markdownIt-Anchor" href="#533-路由"></a> 5.3.3 路由</h4>
<ul>
<li>​     设计和实现一种自动调整传输单元大小的机制来适应网络的技术限制，对IP包进行分片。</li>
</ul>
<h5 id="5331-数据分片与重组"><a class="markdownIt-Anchor" href="#5331-数据分片与重组"></a> 5.3.3.1 数据分片与重组</h5>
<ul>
<li>
<p>第一步：数据分片</p>
<p>​	例： 一个4500字节的数据包被封装进了一个头部为20字节的IP包</p>
<table>
<thead>
<tr>
<th>片</th>
<th>总字节</th>
<th>头部字节</th>
<th>数据字节</th>
<th>MF标志</th>
<th>偏移字节</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>2500</td>
<td>20</td>
<td>2480</td>
<td>1</td>
<td>0</td>
</tr>
<tr>
<td>2</td>
<td>2040</td>
<td>20</td>
<td>2020</td>
<td>0</td>
<td>310</td>
</tr>
<tr>
<td></td>
<td></td>
<td>分片后的数据规模：</td>
<td>2480 +2020</td>
<td>=4500</td>
<td></td>
</tr>
</tbody>
</table>
</li>
<li>
<p>第二步： 包的重新组装</p>
<p>​	用最终偏移和最终数据尺寸计算出最终的总尺寸为：495×8+540=3960+540=4500。</p>
</li>
<li>
<p>数据包：存储——分解——接受——组装</p>
</li>
</ul>
<h5 id="5332-基本的路由算法"><a class="markdownIt-Anchor" href="#5332-基本的路由算法"></a> 5.3.3.2 基本的路由算法</h5>
<ul>
<li>路由器：
<ul>
<li>主要功能为寻找下一个网络节点</li>
<li>存一张路由表供算法查询节点</li>
</ul>
</li>
<li>算法：
<ul>
<li>给定目标地地址D，下一个结点地址N</li>
<li>if (N直接与D地址匹配)
<ul>
<li>将数据传给D</li>
</ul>
</li>
<li>else if (路由表中包含一个带N的路由)
<ul>
<li>将数据包送给N</li>
</ul>
</li>
<li>else if （有一个默认的路由结点）
<ul>
<li>传给缺省的路由结点</li>
</ul>
</li>
<li>else
<ul>
<li>任务失败</li>
</ul>
</li>
</ul>
</li>
<li>路由的选择
<ul>
<li>静态路由： 将路由器的路由选择预先设定好。</li>
<li>动态路由： 每台路由器上运行一个路由协议，该协议根据路由器接口配置、链路状态圣城路由表中的路由器。</li>
<li>缺省路由： 一个路由表条目，用来指明一些下一跳不明确的数据单元如何转发。</li>
</ul>
</li>
<li>路由表包括：
<ul>
<li>网络ID： 目的地子网</li>
<li>成本度量元： 将包送到目的地的路径长度</li>
<li>下一跳/网关：下一站地址</li>
</ul>
</li>
</ul>
<h3 id="54-互联网设计"><a class="markdownIt-Anchor" href="#54-互联网设计"></a> 5.4 互联网设计</h3>
<h4 id="541-网络互联的需求"><a class="markdownIt-Anchor" href="#541-网络互联的需求"></a> 5.4.1 网络互联的需求</h4>
<h4 id="542-网络互联的设计模型"><a class="markdownIt-Anchor" href="#542-网络互联的设计模型"></a> 5.4.2 网络互联的设计模型</h4>
<h4 id="543-dod网络互连协议族设计"><a class="markdownIt-Anchor" href="#543-dod网络互连协议族设计"></a> 5.4.3 DoD网络互连协议族设计</h4>
<p>​	路由器：一个专用计算机，以查地址、快速转发为目的，不需要浮点运算。</p>
<h3 id="55-互联网发展与应用"><a class="markdownIt-Anchor" href="#55-互联网发展与应用"></a> 5.5 互联网发展与应用</h3>
<h4 id="551-美国互联网的全面发展"><a class="markdownIt-Anchor" href="#551-美国互联网的全面发展"></a> 5.5.1 美国互联网的全面发展</h4>
<ul>
<li>美国能独霸天下的根本原因：
<ul>
<li>计算机硬件和系统产业垄断全球</li>
<li>软件关键产品垄断全球</li>
</ul>
</li>
</ul>
<h4 id="552-中国发展互联网的历程"><a class="markdownIt-Anchor" href="#552-中国发展互联网的历程"></a> 5.5.2 中国发展互联网的历程</h4>
<ul>
<li>1994年，由北邮等六所高校建设的“中国教育和科研计算机网”试验网开通</li>
</ul>
<h4 id="553-ietf"><a class="markdownIt-Anchor" href="#553-ietf"></a> 5.5.3 IETF</h4>
<h4 id="554-物联网"><a class="markdownIt-Anchor" href="#554-物联网"></a> 5.5.4 物联网</h4>
<ul>
<li>
<p>IPV6</p>
<ul>
<li>源地址和目的地地址扩展（为128位），可以连接更多的设备</li>
</ul>
</li>
</ul>
<h3 id="56-软件定义网络"><a class="markdownIt-Anchor" href="#56-软件定义网络"></a> 5.6 软件定义网络</h3>
<h4 id="561-传统路由器的问题"><a class="markdownIt-Anchor" href="#561-传统路由器的问题"></a> 5.6.1 传统路由器的问题</h4>
<ul>
<li>协议复杂，网络运维成本高</li>
</ul>
<h4 id="552-openflow-论坛"><a class="markdownIt-Anchor" href="#552-openflow-论坛"></a> 5.5.2 OpenFlow 论坛</h4>
<ul>
<li>解决重新设计互联网的问题</li>
</ul>
<h4 id="553-sdnsoftware-defined-network的提出"><a class="markdownIt-Anchor" href="#553-sdnsoftware-defined-network的提出"></a> 5.5.3 SDN(Software Defined Network)的提出</h4>
<ul>
<li>通过编程解决网络的管理</li>
<li>SDN将数据与控制分离</li>
</ul>
<h4 id="554-学术界与产业界联合"><a class="markdownIt-Anchor" href="#554-学术界与产业界联合"></a> 5.5.4 学术界与产业界联合</h4>
<ul>
<li>梅特卡夫定律：网络的实用性是加入的结点数的平方（转义：像互联网、移动电话网等，价值的增长与用户数成平方数比例）</li>
</ul>
<hr />
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<h4 id="1-描述一下包交换的原理"><a class="markdownIt-Anchor" href="#1-描述一下包交换的原理"></a> 1. 描述一下包交换的原理</h4>
<p>​		数据封装后成为一个数据包，该数据包具有源地址、目标地址以及传输的数据。再包交换的过程中，数据包会在其中的每层都进行一次进一步的组装。将上一层传输的数据包作为本层的数据，并接上用以指明该分组发往何处地址的分组头。到达接收端后，再去掉分组头将各数据字段按顺序连接起来。</p>
<h4 id="2-路由器是一个计算机这种计算机与通用计算机例如pc机或笔记本的共同点和区别在哪里"><a class="markdownIt-Anchor" href="#2-路由器是一个计算机这种计算机与通用计算机例如pc机或笔记本的共同点和区别在哪里"></a> 2. 路由器是一个计算机，这种计算机与通用计算机（例如，PC机或笔记本）的共同点和区别在哪里？</h4>
<p>​		路由器与通用计算机的结构相同</p>
<p>​		路由器主要用来传输数据，基本不需要浮点运算</p>
<p>​		计算机主要用来做数据存储运算</p>
<h4 id="3回顾第4章如何开发路由器上的软件"><a class="markdownIt-Anchor" href="#3回顾第4章如何开发路由器上的软件"></a> 3.回顾第4章如何开发路由器上的软件？</h4>
<p>​		以瀑布式开发为例：</p>
<p>​				进行需求分析（如需要降低路由器的时延）-&gt; 设计（编写软件设计文档、数据库设计说明等）-&gt; 编程（通过优化算法实现时延的降低） -&gt; 测试（将路由器小规模投入使用，并分析收集到的数据） -&gt;运行和维护(大范围推广，并持续维护)</p>
]]></content>
      <categories>
        <category>软工导论</category>
      </categories>
  </entry>
  <entry>
    <title>第七章 数字音视频与图形</title>
    <url>/2019/12/19/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA/%E7%AC%AC%E4%B8%83%E7%AB%A0%20%E6%95%B0%E5%AD%97%E9%9F%B3%E8%A7%86%E9%A2%91%E4%B8%8E%E5%9B%BE%E5%BD%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第七章-数字音视频与图形"><a class="markdownIt-Anchor" href="#第七章-数字音视频与图形"></a> 第七章 数字音视频与图形</h2>
<h3 id="71-数字音频"><a class="markdownIt-Anchor" href="#71-数字音频"></a> 7.1 数字音频</h3>
<a id="more"></a>
<h4 id="711-机械式留声机"><a class="markdownIt-Anchor" href="#711-机械式留声机"></a> 7.1.1 机械式留声机</h4>
<h4 id="712-磁带录音机"><a class="markdownIt-Anchor" href="#712-磁带录音机"></a> 7.1.2 磁带录音机</h4>
<h4 id="713-数字音频系统"><a class="markdownIt-Anchor" href="#713-数字音频系统"></a> 7.1.3 数字音频系统</h4>
<h3 id="72-数字图像"><a class="markdownIt-Anchor" href="#72-数字图像"></a> 7.2 数字图像</h3>
<h4 id="721-图像传感"><a class="markdownIt-Anchor" href="#721-图像传感"></a> 7.2.1 图像传感</h4>
<ul>
<li>CCD、CMOS传感器</li>
</ul>
<h4 id="722-图像位图表示"><a class="markdownIt-Anchor" href="#722-图像位图表示"></a> 7.2.2 图像位图表示</h4>
<ul>
<li>
<p>一副500 X 400的24位像素图象</p>
<p>bitmap: 500 X  400 X 24(3 X 8) = 4,800,000 (bits)</p>
</li>
</ul>
<h4 id="723-图像压缩"><a class="markdownIt-Anchor" href="#723-图像压缩"></a> 7.2.3 图像压缩</h4>
<ul>
<li>无损压缩和有损压缩</li>
</ul>
<h4 id="724-数字图像的应用"><a class="markdownIt-Anchor" href="#724-数字图像的应用"></a> 7.2.4 数字图像的应用</h4>
<h3 id="73-数字视频"><a class="markdownIt-Anchor" href="#73-数字视频"></a> 7.3 数字视频</h3>
<h4 id="731-视频数据与压缩"><a class="markdownIt-Anchor" href="#731-视频数据与压缩"></a> 7.3.1 视频数据与压缩</h4>
<h5 id="视频数据"><a class="markdownIt-Anchor" href="#视频数据"></a> 视频数据</h5>
<ol>
<li>帧显示的速率以帧/秒（FPS）为单位进行测量。如果一个图像具有W宽度和H高度的像素，则表示帧大小是W×H。
<ul>
<li>例：一小时(3600s)的视频，具有24位的颜色深度，帧大小为640 X 480 (W X H), 以及25fps的帧速率
<ul>
<li>每个帧的像素 = 640 X 480 = 307,200</li>
<li>每帧的比特位 = 307,200 X 24 = 7,372,800 = 7.37 Mbits</li>
<li>比特的速率 = 7.37×25 = 184.25 Mbits/sec</li>
<li>视频文件尺寸 = 184 × 3600 = 662,400 Mbits = 82,800 Mbytes = 82.8 Gbytes</li>
</ul>
</li>
</ul>
</li>
</ol>
<h5 id="视频压缩"><a class="markdownIt-Anchor" href="#视频压缩"></a> 视频压缩</h5>
<ul>
<li>
<p>前向预测压缩：参考之前帧</p>
</li>
<li>
<p>帧间压缩(时间增量编码)：参考序列内的前后帧</p>
</li>
<li>
<p>帧内压缩</p>
</li>
</ul>
<h5 id="mpeg-2"><a class="markdownIt-Anchor" href="#mpeg-2"></a> MPEG-2</h5>
<ul>
<li>I帧：全帧内压缩</li>
<li>P帧：前向预测帧</li>
<li>B帧：双向预测帧</li>
</ul>
<h4 id="732-数字电视广播系统"><a class="markdownIt-Anchor" href="#732-数字电视广播系统"></a> 7.3.2 数字电视广播系统</h4>
<ul>
<li>数据编码流：传输流、节目流</li>
</ul>
<h4 id="733-视频识别的应用"><a class="markdownIt-Anchor" href="#733-视频识别的应用"></a> 7.3.3 视频识别的应用</h4>
<h4 id="734-立体电影与电视"><a class="markdownIt-Anchor" href="#734-立体电影与电视"></a> 7.3.4 立体电影与电视</h4>
<h3 id="74-计算机图形学"><a class="markdownIt-Anchor" href="#74-计算机图形学"></a> 7.4 计算机图形学</h3>
<h4 id="741-图像的矢量表示"><a class="markdownIt-Anchor" href="#741-图像的矢量表示"></a> 7.4.1 图像的矢量表示</h4>
<ul>
<li>位图占用太多空间，不适合图形为主体的数据表达</li>
<li>矢量图减少存储空间</li>
</ul>
<h4 id="742-图形的运算"><a class="markdownIt-Anchor" href="#742-图形的运算"></a> 7.4.2 图形的运算</h4>
<ul>
<li>平移、反射、旋转、缩放</li>
</ul>
<h4 id="743-二维图形"><a class="markdownIt-Anchor" href="#743-二维图形"></a> 7.4.3 二维图形</h4>
<h4 id="744-三维图形"><a class="markdownIt-Anchor" href="#744-三维图形"></a> 7.4.4 三维图形</h4>
<h4 id="745-图形学的应用"><a class="markdownIt-Anchor" href="#745-图形学的应用"></a> 7.4.5 图形学的应用</h4>
<h4 id="746-虚拟现实技术"><a class="markdownIt-Anchor" href="#746-虚拟现实技术"></a> 7.4.6 虚拟现实技术</h4>
<h3 id="75-专用处理器"><a class="markdownIt-Anchor" href="#75-专用处理器"></a> 7.5 专用处理器</h3>
<ul>
<li>CPU关注算术和逻辑运算</li>
</ul>
<h4 id="751-gpu"><a class="markdownIt-Anchor" href="#751-gpu"></a> 7.5.1 GPU</h4>
<p>图形处理单元：快速运算和访问存储器，快速图像运算，快速输出到显示设备缓冲器</p>
<h4 id="752-tpu"><a class="markdownIt-Anchor" href="#752-tpu"></a> 7.5.2 TPU</h4>
<p>张量处理单元：针对符号处理和人工神经学习网络</p>
<h3 id="76-图形与符号编码"><a class="markdownIt-Anchor" href="#76-图形与符号编码"></a> 7.6 图形与符号编码</h3>
<h4 id="761-一维码"><a class="markdownIt-Anchor" href="#761-一维码"></a> 7.6.1 一维码</h4>
<ul>
<li>条形码</li>
</ul>
<h4 id="762-二维码"><a class="markdownIt-Anchor" href="#762-二维码"></a> 7.6.2 二维码</h4>
<h4 id="763-三维码"><a class="markdownIt-Anchor" href="#763-三维码"></a> 7.6.3 三维码</h4>
<ul>
<li>利用图像的灰度和彩色产生出第三维度</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<h4 id="1-一副500-x-400像素深度为24位的彩色照片用位图bitmap存储文件尺寸最小是多少"><a class="markdownIt-Anchor" href="#1-一副500-x-400像素深度为24位的彩色照片用位图bitmap存储文件尺寸最小是多少"></a> 1. 一副500 X 400像素，深度为24位的彩色照片，用位图(bitmap)存储，文件尺寸最小是多少？</h4>
<p class='katex-block'><span class="katex-display"><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML" display="block"><semantics><mrow><mn>500</mn><mo>×</mo><mn>400</mn><mo>×</mo><mn>24</mn><mo>=</mo><mn>4</mn><mo separator="true">,</mo><mn>800</mn><mo separator="true">,</mo><mn>000</mn><mo stretchy="false">(</mo><mi>b</mi><mi>i</mi><mi>t</mi><mi>s</mi><mo stretchy="false">)</mo><mo>=</mo><mn>600</mn><mo separator="true">,</mo><mn>000</mn><mo stretchy="false">(</mo><mi>b</mi><mi>y</mi><mi>t</mi><mi>e</mi><mi>s</mi><mo stretchy="false">)</mo><mo>≈</mo><mn>586</mn><mi>K</mi><mi>B</mi><mo>≈</mo><mn>0.6</mn><mi>M</mi><mi>B</mi></mrow><annotation encoding="application/x-tex">500 \times 400 \times 24 = 4,800,000 (bits) = 600,000 (bytes)  \approx 586 KB \approx 0.6 MB
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">5</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.72777em;vertical-align:-0.08333em;"></span><span class="mord">4</span><span class="mord">0</span><span class="mord">0</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">2</span><span class="mord">4</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">4</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">8</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal">i</span><span class="mord mathnormal">t</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord">6</span><span class="mord">0</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mord">0</span><span class="mord">0</span><span class="mopen">(</span><span class="mord mathnormal">b</span><span class="mord mathnormal" style="margin-right:0.03588em;">y</span><span class="mord mathnormal">t</span><span class="mord mathnormal">e</span><span class="mord mathnormal">s</span><span class="mclose">)</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">5</span><span class="mord">8</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.07153em;">K</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">≈</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">0</span><span class="mord">.</span><span class="mord">6</span><span class="mord mathnormal" style="margin-right:0.10903em;">M</span><span class="mord mathnormal" style="margin-right:0.05017em;">B</span></span></span></span></span></p>
<h4 id="2-如何提高视频数据的传输速度"><a class="markdownIt-Anchor" href="#2-如何提高视频数据的传输速度"></a> 2. 如何提高视频数据的传输速度？</h4>
<p>进行视频压缩，利用帧间压缩或帧内压缩等压缩方式，用前后帧的数据来描述当前帧或者对当前帧进行有损压缩，减少视频传输的数据大小，提高传输速度。</p>
<h4 id="3-试探发明某种图形编码的方案"><a class="markdownIt-Anchor" href="#3-试探发明某种图形编码的方案"></a> 3. 试探发明某种图形编码的方案。</h4>
]]></content>
      <categories>
        <category>软工导论</category>
      </categories>
  </entry>
  <entry>
    <title>第六章 从数据管理到Web和信息通信</title>
    <url>/2019/12/19/%E8%BD%AF%E5%B7%A5%E5%AF%BC%E8%AE%BA/%E7%AC%AC%E5%85%AD%E7%AB%A0%20%E4%BB%8E%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%88%B0Web%E5%92%8C%E4%BF%A1%E6%81%AF%E9%80%9A%E4%BF%A1/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h2 id="第六章-从数据管理到web和信息通信"><a class="markdownIt-Anchor" href="#第六章-从数据管理到web和信息通信"></a> 第六章 从数据管理到Web和信息通信</h2>
<h3 id="61-数据结构化数据库"><a class="markdownIt-Anchor" href="#61-数据结构化数据库"></a> 6.1 数据结构化数据库</h3>
<h4 id="611-数据存储的结构化"><a class="markdownIt-Anchor" href="#611-数据存储的结构化"></a> 6.1.1 数据存储的结构化</h4>
<ul>
<li>节约空间</li>
<li>便于计算机查询</li>
<li>便于删除、修改、增添信息</li>
</ul>
<a id="more"></a>
<h4 id="612-消除数据冗余"><a class="markdownIt-Anchor" href="#612-消除数据冗余"></a> 6.1.2 消除数据冗余</h4>
<h4 id="613-建立实体关联"><a class="markdownIt-Anchor" href="#613-建立实体关联"></a> 6.1.3 建立实体关联</h4>
<h3 id="62-关系代数"><a class="markdownIt-Anchor" href="#62-关系代数"></a> 6.2 关系代数</h3>
<h4 id="621-关系代数定义"><a class="markdownIt-Anchor" href="#621-关系代数定义"></a> 6.2.1 关系代数定义</h4>
<p>​		给定集合D<sub>1</sub>，D<sub>2</sub>，……D<sub>n</sub>，关系r是D<sub>1</sub>×D<sub>2</sub>×…×D<sub>n</sub>，这样，关系r是n元组(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)的集合，这里的每个a<sub>i</sub> ∈ D<sub>i</sub></p>
<ul>
<li>
<p>5种基本运算：选择、投影、笛卡尔积、并、差</p>
</li>
<li>
<p>其他扩展运算：交、连接、除</p>
</li>
</ul>
<h4 id="622-选择运算"><a class="markdownIt-Anchor" href="#622-选择运算"></a> 6.2.2 '选择’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/fNpisxe1TDQMojK.png" alt="6.2.2.png" /></p>
<h4 id="623-投影运算"><a class="markdownIt-Anchor" href="#623-投影运算"></a> 6.2.3 ‘投影’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/9ZxSsmOnLVdi6aR.png" alt="6.2.3.png" /></p>
<h4 id="624-笛卡尔积运算"><a class="markdownIt-Anchor" href="#624-笛卡尔积运算"></a> 6.2.4 ‘笛卡尔积’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/SJp1Gj9Fx3IqVlZ.png" alt="6.2.4.png" /></p>
<h4 id="625-并运算"><a class="markdownIt-Anchor" href="#625-并运算"></a> 6.2.5 '并运算</h4>
<p><img src="https://i.loli.net/2019/12/05/78vEgrWAwXDJIHo.png" alt="6.2.5.png" /></p>
<h4 id="626-差运算"><a class="markdownIt-Anchor" href="#626-差运算"></a> 6.2.6 '差’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/9fPLp5WcYuGtQlx.png" alt="6.2.6.png" /></p>
<h4 id="627-交运算"><a class="markdownIt-Anchor" href="#627-交运算"></a> 6.2.7 '交’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/Dcmph3MWtTRlwNX.png" alt="6.2.7.png" /></p>
<h4 id="628-连接运算"><a class="markdownIt-Anchor" href="#628-连接运算"></a> 6.2.8 '连接’运算</h4>
<p><img src="https://i.loli.net/2019/12/05/7Kgx6vTSjpAoCVM.png" alt="6.2.8.png" /></p>
<h3 id="63-关系数据库"><a class="markdownIt-Anchor" href="#63-关系数据库"></a> 6.3 关系数据库</h3>
<h4 id="631-关系数据库管理系统"><a class="markdownIt-Anchor" href="#631-关系数据库管理系统"></a> 6.3.1 关系数据库管理系统</h4>
<ul>
<li>
<p>表的运算（表的模式、表的增删等等）</p>
</li>
<li>
<p>表的内容运算（查询、内容的增删）</p>
</li>
<li>
<p>用户和数据表的管理</p>
</li>
</ul>
<p>数据库管理系统(DBMS)：增、删、改、查</p>
<h4 id="632-sql-结构化查询语言"><a class="markdownIt-Anchor" href="#632-sql-结构化查询语言"></a> 6.3.2 SQL: 结构化查询语言</h4>
<h3 id="64-万维网"><a class="markdownIt-Anchor" href="#64-万维网"></a> 6.4 万维网</h3>
<h4 id="641-www的初衷"><a class="markdownIt-Anchor" href="#641-www的初衷"></a> 6.4.1 WWW的初衷</h4>
<h4 id="642-web基本原理"><a class="markdownIt-Anchor" href="#642-web基本原理"></a> 6.4.2 Web基本原理</h4>
<p>协议和语言：HTML + HTTP</p>
<p align='right'>
    <font size=5>
    Web网的组成结构
    </font>
</p>
<p><img src="https://i.loli.net/2019/12/05/HST8qdGWryzaip4.png" alt="6.4.2.png" /></p>
<h4 id="643-www函数库"><a class="markdownIt-Anchor" href="#643-www函数库"></a> 6.4.3 WWW函数库</h4>
<h4 id="644-早期美国网站的迅速发展"><a class="markdownIt-Anchor" href="#644-早期美国网站的迅速发展"></a> 6.4.4 早期美国网站的迅速发展</h4>
<h4 id="645-web服务器产品"><a class="markdownIt-Anchor" href="#645-web服务器产品"></a> 6.4.5 Web服务器产品</h4>
<h4 id="646-web浏览器产品"><a class="markdownIt-Anchor" href="#646-web浏览器产品"></a> 6.4.6 Web浏览器产品</h4>
<h4 id="647-早期中国www的发展"><a class="markdownIt-Anchor" href="#647-早期中国www的发展"></a> 6.4.7 早期中国WWW的发展</h4>
<h3 id="65-web搜索"><a class="markdownIt-Anchor" href="#65-web搜索"></a> 6.5 Web搜索</h3>
<h4 id="651-爬虫"><a class="markdownIt-Anchor" href="#651-爬虫"></a> 6.5.1 爬虫</h4>
<p>​		爬虫基本功能是从一个或若干初始网页的URL开始，获得初始网页上的URL，在抓取网页的过程中，不断从当前页面上抽取新的URL放入队列,直到满足系统的一定停止条件。</p>
<p>​		并行爬行的缺点：</p>
<ul>
<li>重复</li>
<li>质量低——每个爬虫只能获取部分页面</li>
<li>通信带宽代价——爬虫之间进行通信</li>
</ul>
<h4 id="652-内容分类和标引"><a class="markdownIt-Anchor" href="#652-内容分类和标引"></a> 6.5.2 内容分类和标引</h4>
<ol>
<li>提取文字</li>
</ol>
<p>(2. 对于中文要进行中文分词，)</p>
<ol start="3">
<li>去停止词；</li>
<li>消除噪音（版权声明、导航条、广告）</li>
<li>正向索引</li>
<li>倒排索引</li>
<li>链接关系计算</li>
<li>特殊文件处理</li>
</ol>
<h4 id="653-搜索策略"><a class="markdownIt-Anchor" href="#653-搜索策略"></a> 6.5.3 搜索策略</h4>
<ul>
<li>全文搜索引擎
<ul>
<li>定期搜索</li>
<li>提交网站搜索</li>
</ul>
</li>
<li>目录内容搜索（全手工）</li>
</ul>
<h3 id="66-web变迁与nosql数据库"><a class="markdownIt-Anchor" href="#66-web变迁与nosql数据库"></a> 6.6 Web变迁与NoSQL数据库</h3>
<h4 id="661-web应用方式的变迁"><a class="markdownIt-Anchor" href="#661-web应用方式的变迁"></a> 6.6.1 Web应用方式的变迁</h4>
<p>Web2.0: 增强交互性</p>
<h4 id="662-web对信息管理系统的改变"><a class="markdownIt-Anchor" href="#662-web对信息管理系统的改变"></a> 6.6.2 Web对信息管理系统的改变</h4>
<p><img src="https://i.loli.net/2019/12/05/cfymA9UhQ6ranli.png" alt="6.6.2.png" /></p>
<h4 id="663-nosql对数据处理系统的影响"><a class="markdownIt-Anchor" href="#663-nosql对数据处理系统的影响"></a> 6.6.3 NoSQL对数据处理系统的影响</h4>
<ul>
<li>键值存储数据库（使用哈希表）</li>
<li>列存储数据库（分布式存储的海量数据）</li>
<li>文档型数据库</li>
<li>图形数据库</li>
</ul>
<p><img src="https://i.loli.net/2019/12/05/4UcSNAypYEW2r83.png" alt="6.6.3.png" /></p>
<h4 id="664-大数据时代"><a class="markdownIt-Anchor" href="#664-大数据时代"></a> 6.6.4 大数据时代</h4>
<h3 id="67-信息量"><a class="markdownIt-Anchor" href="#67-信息量"></a> 6.7 信息量</h3>
<h4 id="671-单变量的熵定义"><a class="markdownIt-Anchor" href="#671-单变量的熵定义"></a> 6.7.1 单变量的熵定义</h4>
<h4 id="672-关联信息的熵定义"><a class="markdownIt-Anchor" href="#672-关联信息的熵定义"></a> 6.7.2 关联信息的熵定义</h4>
<h4 id="673-数据-信息与知识时代"><a class="markdownIt-Anchor" href="#673-数据-信息与知识时代"></a> 6.7.3 数据、信息与知识时代</h4>
<h3 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h3>
<ul>
<li>
<p>结构化数据管理：数据（增、删、改、查）</p>
</li>
<li>
<p>Web（非结构化）的信息表达、传输和交流</p>
</li>
<li>
<p>Web信息的自动搜索、分类、信息提取</p>
</li>
<li>
<p>信息量</p>
</li>
<li>
<p>大数据：</p>
<ul>
<li>结构化数据迅速增加</li>
<li>非结构数据迅速增加
<ul>
<li>流式数据(音频、视频)、文档数据</li>
</ul>
</li>
<li>Web数据的迅速增加</li>
<li>从这些大数据中，如何提取到期望的信息(和知识)</li>
</ul>
</li>
</ul>
<h3 id="作业"><a class="markdownIt-Anchor" href="#作业"></a> 作业</h3>
<h4 id="1-关系代数是如何定义的有哪些基本运算"><a class="markdownIt-Anchor" href="#1-关系代数是如何定义的有哪些基本运算"></a> 1. 关系代数是如何定义的？有哪些基本运算？</h4>
<h5 id="定义"><a class="markdownIt-Anchor" href="#定义"></a> 定义：</h5>
<p>​		给定集合D<sub>1</sub>，D<sub>2</sub>，……D<sub>n</sub>，关系r是D<sub>1</sub>×D<sub>2</sub>×…×D<sub>n</sub>，这样，关系r是n元组(a<sub>1</sub>,a<sub>2</sub>,…,a<sub>n</sub>)的集合，这里的每个a<sub>i</sub> ∈ D<sub>i</sub></p>
<h5 id="五种基本运算"><a class="markdownIt-Anchor" href="#五种基本运算"></a> 五种基本运算：</h5>
<ul>
<li>
<p>'选择’运算：从关系 R 中选择满足给定条件的元组</p>
</li>
<li>
<p>'投影’运算：从一张表中，选取某一列或多列(属性)的运算</p>
</li>
<li>
<p>'笛卡尔积’运算：</p>
</li>
<li>
<p>'并’运算：把两个相同模式的表中的数据聚在一起，同时消除重复的数据。</p>
</li>
<li>
<p>'差’运算：从被减表中消除减表中数据。</p>
</li>
</ul>
<h5 id="扩展运算"><a class="markdownIt-Anchor" href="#扩展运算"></a> 扩展运算：</h5>
<ul>
<li>
<p>'交’运算：取两个相同模式表中都具有的数据。</p>
</li>
<li>
<p>'连接’运算：笛卡尔积 + 选择  R ⋈<sub>F</sub> S = σ<sub>F</sub> (R×S)   F为连接条件</p>
</li>
</ul>
<h4 id="2-web网与实体关联图的区别在哪里"><a class="markdownIt-Anchor" href="#2-web网与实体关联图的区别在哪里"></a> 2. Web网与实体关联图的区别在哪里？</h4>
<p>​		实体与实体之间的关联比较简单,Web网则有更丰富的关联或链接关系。实体关系图需要顺序链接阅读，Web网可以通过超文本链接进行位置的跳转。</p>
]]></content>
      <categories>
        <category>软工导论</category>
      </categories>
  </entry>
</search>
