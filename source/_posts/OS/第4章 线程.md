---
title: 第4章 线程
date: 2020-10-10 20:30:15
tags: 
categories: 操作系统
---
## 线程

- 线程是CPU利用的基本单位

<!-- more -->

- 它包含一个线程ID，一个程序计数器，一个寄存器集和一个堆栈
  它与属于同一进程的其他线程，代码部分，数据部分和其他OS资源（例如打开的文件，信号等）共享

<img src="https://i.loli.net/2020/10/23/A5bLvzJX6sPEdCO.png" alt="image-20201011095455371.png" style="zoom:50%;" />

#### 进程与线程的比较

- 进程是资源分配单位，线程是CPU分配单位
- 进程拥有一个完整的资源平台，而进程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞和执行三种状态，同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销
- 线程 = 轻量级进程

#### 优点

- 响应度高

- 资源共享

- 经济

- MP结构的利用

  ​	并发和并行

### 多线程模型

#### 多对一模型

<img src="https://i.loli.net/2020/10/23/Q5hWvgyc41rLVZU.png" alt="image-20201011095958114.png" style="zoom:50%;" />

#### 一对一模型

<img src="https://i.loli.net/2020/10/23/sjuRIC3W8iVLYgO.png" alt="image-20201011100009095.png" style="zoom:50%;" />

#### 多对多模型

<img src="https://i.loli.net/2020/10/23/QqAYf8TFyhl6c1K.png" alt="image-20201011100019172.png" style="zoom:50%;" />

#### 双层模型

<img src="https://i.loli.net/2020/10/23/T3qniP86VYKZGCe.png" alt="image-20201011100025612.png" style="zoom:50%;" />

### 线程问题

- fork（）和exec（）系统调用的语义
- fork（）是否仅复制调用线程或所有线程？

##### 两种通用解决方法

- Asynchronous （异步）取消立即终止目标线程
- Deferred（延迟）取消允许目标线程定期检查是否应取消它

#### 线程池

- 在它们所在的池中创建许多线程并等待工作

- 使用现有线程处理请求要比创建新线程快一些
- 允许将应用程序中的线程数绑定到池的大小

### 作业

4.1 Provide two programming examples in which multithreading provides
better performance than a single-threaded solution.

网页浏览和字处理，都需要并发处理多个事件

4.2 What are two differences between user-level threads and kernel-level
threads? Under what circumstances is one type better than the other?

​	kernel-level threads由kernel mode直接支持，而user-level threads不被kernel mode支持。但是kernel-level threads因为会需求更多资源，所以会比user-level threads更慢。一些不需要kernel mode来管理的低级任务，使用user-level threads能加快速度；kernel-level threads更适合需要系统资源的高级任务。

4.3 Describe the actions taken by a kernel to context-switch between kernel-level threads.

​	记录当前线程的CPU寄存器值并加载调度线程的CPU寄存器值

4.4 What resources are used when a thread is created? How do they differ
from those used when a process is created?

1）一组用来在上下文切换时记录状态的寄存器

2)一个堆栈

3)各种运行时库和动态链接库使用的线程专用存储

当进程被创建时，内存分配用于程序指令和数据以及线程存储

4.5 Assume that an operating system maps user-level threads to the kernel
using the many-to-many model and that the mapping is done through
LWPs. Furthermore, the system allows developers to create real-time
threads for use in real-time systems. Is it necessary to bind a real-time
thread to an LWP? Explain.

​		是的，把实时线程绑定到LWP很有必要，这样可以确保线程在调度好之后就能以最小的延迟时间运行

4.6 Provide two programming examples in which multithreading does not
provide better performance than a single-threaded solution.

- 任何顺序执行的程序
- 监控自己工作空间的程序如open files和C-shell

4.7 Under what circumstances does a multithreaded solution using multiple
kernel threads provide better performance than a single-threaded
solution on a single-processor system?

​		在程序经常发生页面错误、或需要经常等待其他系统事件时，用多kernel threads的多线程解决方案比用单处理器的单线程解决方案好



4.8 Which of the following components of program state are shared across
threads in a multithreaded process?
a. Register values
b. Heap memory
c. Global variables
d. Stack memory

b, c



4.9 Can a multithreaded solution using multiple user-level threads achieve
better performance on a multiprocessor system than on a single processor
system? Explain.

​		因为user-level threads没有kernel mode的支持，在多处理器系统上使用多 user-level threads没有收益，所以不能

4.11 Is it possible to have concurrency but not parallelism? Explain.

​	可以，进程的执行就可以只是并发，没有并行。



4.15 Consider the following code segment:
pid t pid;
pid = fork();
if (pid == 0) { /* child process */
fork();
thread create( . . .);
}
fork();
a. How many unique processes are created?

​	5

b. How many unique threads are created?

​	2



4.16 As described in Section 4.7.2, Linux does not distinguish between
processes and threads. Instead, Linux treats both in the same way,
allowing a task to be more akin to a process or a thread depending on the
set of flags passed to the clone() system call. However, other operating
systems, such as Windows, treat processes and threads differently.
Typically, such systems use a notation in which the data structure for
a process contains pointers to the separate threads belonging to the
process. Contrast these two approaches for modeling processes and
threads within the kernel.



Pros:

- Linux认为这很相似，因此可以很容易地减少属于操作系统的代码。
- Linux操作系统中存在的调度程序不需要特殊的代码即可测试与每个进程耦合的线程。
- 在调度期间，它将不同的线程和进程视为单个任务。

Cons:

- 这种能力使Linux操作系统更难直接施加进程范围的资源限制。
- 需要额外的步骤来识别每个进程属于适当的线程以及执行相关任务的复杂性。

