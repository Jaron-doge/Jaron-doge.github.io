---
title: 第7章 死锁
date: 2020-10-28 20:30:15
tags: 
categories: 操作系统
---
## 死锁

### 7.1 死锁特性

<!-- more -->

- 互斥(mutual exclusion)

- 占有并等待(hold and wait)

  拥有至少一个资源的进程正在等待获取其他进程所拥有的其他资源

- 非抢占(no preemption)

  资源只能由拥有该资源的进程在该进程完成其任务后自动释放

- 循环等待(circular wait)

#### 资源分配图

圆：进程、块：资源、点：资源个数

- 无环无死锁
- 有环
  - 每个资源资源单实例，死锁
  - 资源多实例，不一定死锁

<img src="https://i.loli.net/2020/10/23/PcMDzK3UERHY4v6.png" alt="image-20201023185203185.png" style="zoom: 50%;" />

<img src="https://i.loli.net/2020/10/23/MQLqlfzcsx756Fr.png" alt="image-20201023185400598.png" style="zoom:50%;" />

### 7.2 死锁处理方法

- 采用某个协议来预防或避免死锁，确保系统将永远不会进入死锁状态
  - 死锁预防
  - 死锁避免
- 允许系统进入死锁状态，检测它，然后恢复
  - 死锁检测和死锁恢复
- 完全忽略这个问题，并假设系统永远都不会出现死锁

<img src="https://i.loli.net/2020/10/23/dyCJ9xOQK6ke3Bc.png" alt="image-20201023185736801.png" style="zoom:80%;" />

### 7.3 死锁预防

​	破坏死锁特性

#### 互斥

​	基本不可行

#### 占有并等待

​	保证当进程申请一个资源时，不能占有其他资源

- 在进程开始执行前申请获得所有资源
- 进程在结束时申请资源

##### 缺点：

- 资源利用率低
- 可能发生饥饿

#### 非抢占

​	当一个进程处于等待时，如果其他进程申请其拥有资源，那么该进程的部分资源可以被抢占

#### 循环等待

对所有的资源进行完全排序，而且要求每个进程按递增顺序来申请资源

### 7.4 死锁避免

#### 安全状态

如果系统能按一定顺序为每个进程分配资源，仍然避免死锁，那么系统就是安全的。只有存在一个安全序列，系统才处于安全状态

#### 资源分配图算法

如果每种资源类型只有一个实例，那么可以用资源分配图算法来避免死锁

- 需求边

  进程Pi可能在将来某个时候申请资源Pj，用虚线表示

- 申请边

- 分配边

<img src="https://i.loli.net/2020/10/23/1fvWgDVsTjUr9aC.png" alt="image-20201023194122927.png" style="zoom:50%;" />

#### 银行家算法

对于每种资源有多个实例

- 每个进程必须提前声明每种类型资源实例的最大数量

- 当用户申请资源时，系统应确定这些资源的分配是否会使系统处于安全状态，如果会，就分配资源；否则，进程应等待其他进程释放资源
- 当进程获取所有资源时，必须在有限时间内返回它们

##### 数据结构

- Available: 长度为m的向量，表示每种资源的可用实例数量
- Max: n × m矩阵，定义每个进程的最大需求
- Allocation: n × m矩阵，定义每个进程现在分配的每种资源类型的实例数量
- Need: n × m矩阵，表示每个进程还需要的剩余资源， Need = Max - Allocation

##### 安全算法

1. 令Work和Finish分别为长度m和n的向量，初始化Work = Available、Finish[i] = false

2. Finish[i] == false

   Need_i ≤ Work

   如果没有这样的i，跳转到第4步

3. Work = Work + Allocation_i

   Finish[i] = true

   返回第2步

4. 如果对所有i, Finish[i] == true，系统处于安全状态

##### 资源请求算法

1. Request_i ≤ Need_i

2. Request_i ≤ Available

3. Available -= Request_i

   Allocation += Request_i

   Need_i -= Request_i

   如果新的资源分配状态是安全的，那么交易完成且进程Pi可分配到需要的资源；如果新状态不安全，则Pi应等待并恢复到原来的资源分配状态

<img src="https://i.loli.net/2020/10/23/tNGFWoT8PyiO4kC.png" alt="image-20201023195806388.png" style="zoom:80%;" />



![image-20201023195541997.png](https://i.loli.net/2020/10/23/pmA7rF9loONXk2H.png)

### 7.5 死锁检测

#### 单个实例

将资源分配图中的资源类型节点去除，合并适当边，得到等待(wait-for)图

#### 多个实例

银行家算法

### 7.6 死锁恢复

#### 进程终止

- 终止所有死锁进程
- 一次终止一个进程，直到消除死循环为止
- 最小代价(minimum cost): 按最小代价终止进程
  - 优先级
  - 计算时间
  - 使用资源数量

#### 资源抢占

- 选择牺牲进程

  最小代价

- 回滚

  被抢占资源的进程回滚到安全状态，通常为重新执行该进程

- 饥饿

  确保一个进程只能有限次数被选为牺牲进程，在代价因素中加上回滚次数

### 作业

7.3 Consider the following snapshot of a system:
Allocation Max Available
<img src="https://i.loli.net/2020/10/23/qEJPmWyaANTzn54.png" alt="image-20201023200753433.png" style="zoom:80%;" />
Answer the following questions using the banker’s algorithm:
a. What is the content of the matrix Need?

P0: (0, 0, 0, 0), P1:(0, 7, 5, 0), P2:(1, 0, 0, 2), P3:(0, 0, 2, 0), P4:(0, 6, 4, 2)

b. Is the system in a safe state?

处于安全状态，P1或P3申请资源后会满足需求，然后释放资源，P3释放后的可用资源能满足剩下任意进程的资源需求

c. If a request from process P1 arrives for (0,4,2,0), can the request be
granted immediately?

可以，P1申请资源后可用资源为(1, 1, 0, 0)，序列<P0, P2, P3, P1, P4>满足安全要求



7.6 Consider a computer system that runs 5,000 jobs per month and has no
deadlock-prevention or deadlock-avoidance scheme. Deadlocks occur about twice per month, and the operator must terminate and rerun about ten jobs per deadlock. Each job is worth about two dollars (in CPU time), and the jobs terminated tend to be about half done when they are aborted.
		A systems programmer has estimated that a deadlock-avoidance
algorithm (like the banker’s algorithm) could be installed in the system
with an increase of about 10 percent in the average execution time per
job. Since the machine currently has 30 percent idle time, all 5,000 jobs
per month could still be run, although turnaround time would increase
by about 20 percent on average.
a. What are the arguments for installing the deadlock-avoidance
algorithm?
b. What are the arguments against installing the deadlock-avoidance
algorithm?

同意：可以避免死锁的发生，并且由于有空闲时间，5000个作业仍能每月完成，没有太大影响

不同意：每月死锁发生次数不多，仅为2次，增加死锁避免方法产生的开销不如每月处理死锁产生的开销少



7.7 Can a system detect that some of its processes are starving? If you answer
“yes,” explain how it can. If you answer “no,” explain how the system
can deal with the starvation problem.

可以检测饥饿，先设置一个时间T用来判断进程是否为饥饿状态，当进程申请资源时，设置一个计时器开始计时，当时间超过T时，进程就被认为处于饥饿状态。



7.8 Consider the following resource-allocation policy. Requests for and
releases of resources are allowed at any time. If a request for resources
cannot be satisfied because the resources are not available, thenwe check
any processes that are blocked waiting for resources. If a blocked process
has the desired resources, then these resources are taken away from it
and are given to the requesting process. The vector of resources for which
the blocked process is waiting is increased to include the resources that
were taken away.
		For example, a system has three resource types, and the vector
Available is initialized to (4,2,2). If process P0 asks for (2,2,1), it gets
them. If P1 asks for (1,0,1), it gets them. Then, if P0 asks for (0,0,1), it
is blocked (resource not available). If P2 now asks for (2,0,0), it gets the
available one (1,0,0), as well as one that was allocated to P0 (since P0 is
blocked). P0’s Allocation vector goes down to (1,2,1), and its Need vector
goes up to (1,0,1).
a. Can deadlock occur? If you answer “yes,” give an example. If you
answer “no,” specify which necessary condition cannot occur.
b. Can indefinite blocking occur? Explain your answer.

a. 死锁不会发生，因为非抢占的特性被打破了，进程间可以抢占资源

b. 是的，如果一个进程需要多个常用资源，会经常被抢占资源，可能必须永久等待，即发生饥饿



7.10 Is it possible to have a deadlock involving only one single-threaded
process? Explain your answer.

不可能，单线程进程中的线程顺序执行，不会发生死锁

7.17 Consider a system consisting of four resources of the same type that are
shared by three processes, each of which needs at most two resources.
Show that the system is deadlock free.

因为一个进程最多需要2个资源，让每个进程都处于占有并等待的状态，也就是每个进程都占有1个资源，请求1个资源。此时剩余1个资源，无论分配给哪个进程，都能满足需求，然后释放资源，满足另外的进程的请求。所以死锁不会发生。



7.19 Consider the version of the dining-philosophers problem in which the
chopsticks are placed at the center of the table and any two of them
can be used by a philosopher. Assume that requests for chopsticks are
made one at a time. Describe a simple rule for determining whether a
particular request can be satisfied without causing deadlock given the
current allocation of chopsticks to philosophers.

当左边或右边的哲学家有筷子时，不能拿起筷子



7.21 We can obtain the banker’s algorithm for a single resource type from
the general banker’s algorithm simply by reducing the dimensionality
of the various arrays by 1. Show through an example that we cannot
implement the multiple-resource-type banker’s scheme by applying the
single-resource-type scheme to each resource type individually.

​	3 3

​		Allocation	Max	Availiable

​		A, B			 A, B	 A, B

p1    0, 0    		2, 2	 3, 3	

p2    0, 0			1, 2

p3    0, 0     		2, 1

单资源分配时对于A、B来说<p1, p2, p3>都是安全序列，单双资源分配时<P1, P2, P3>不是安全序列，所以多资源分配时不能分别使单资源分配策略

7.22 Consider the following snapshot of a system:

<img src="https://i.loli.net/2020/10/23/sKboN2awOEIUeXl.png" alt="image-20201023201000292.png" style="zoom:80%;" />

Using the banker’s algorithm, determine whether or not each of the
following states is unsafe. If the state is safe, illustrate the order in which
the processes may complete. Otherwise, illustrate why the state is unsafe.
a. Available = (0, 3, 0, 1) 
b. Available = (1, 0, 0, 2)

P0、P1、P2、P3、P4的需求矩阵为:

​		A B C D  

P0	2 1 0 3

P1	1 0 0 1

P2	0 2 0 0 

P3	4 1 0 2

P5	2 1 1 3

a. 不安全，进程P2, P1, P3可以完成，但剩余资源满足不了其他进程的请求

b. 安全，<P1, P2, P0, P3, P4>是一个安全序列，因此状态是安全的 



7.23 Consider the following snapshot of a system:

<img src="https://i.loli.net/2020/10/23/hXAgjS4rQqbF32E.png" alt="image-20201023201019048.png" style="zoom:80%;" />

Answer the following questions using the banker’s algorithm:
a. Illustrate that the system is in a safe state by demonstrating an
order in which the processes may complete.
b. If a request from process P1 arrives for (1, 1, 0, 0), can the request
be granted immediately?
c. If a request from process P4 arrives for (0, 0, 2, 0), can the request
be granted immediately?

Need	A B C D 	Available      

P0		2 2 1 1		3 3 2 1		    	

P1		2 1 3 1		

P2		0 2 1 3		

P3		0 1 1 2		5 3 2 2 

P4		2 2 3 2

a. <P0, P3, P1, P2, P4> 安全序列前两个为P0、P3,后面的P1、P2、P4可以随机排序

b. 可以，P1请求i(1, 1, 0, 0)后仍存在安全序列<P0, P3, P1, P2, P4>

C. 不行，P4请求(0, 0, 2, 0)后不存在安全序列



7.25 A single-lane bridge connects the two Vermont villages of North
Tunbridge and South Tunbridge. Farmers in the two villages use this
bridge to deliver their produce to the neighboring town. The bridge
can become deadlocked if a northbound and a southbound farmer get
on the bridge at the same time. (Vermont farmers are stubborn and are
unable to back up.) Using semaphores and/or mutex locks, design an
algorithm in pseudocode that prevents deadlock. Initially, do not be
concerned about starvation (the situation in which northbound farmers
prevent southbound farmers from using the bridge, or vice versa).

使用互斥信号量mutex，当有农夫上桥时将信号量mutex设为0, 下桥时设为1，当农夫想要上桥时需要等待信号量mutex = 1。 