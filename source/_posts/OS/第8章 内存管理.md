---
title: 第8章 内存管理
date: 2020-11-15 13:30:15
tags: 
categories: 操作系统
---
## 内存管理

### 8.1 背景

- CPU可以直接访问的通用存储只有内存和处理器内置的寄存器

<!-- more -->

#### 8.1.1 内存保护

- **Base register** + **Limit register**

<img src="https://i.loli.net/2020/11/15/cQfmXAuEvWOD6Ir.png" alt="image-20201112195903075.png" style="zoom:80%;" />

<img src="https://i.loli.net/2020/11/15/CMwhnZslgrbp2S3.png" alt="image-20201114163901044.png" style="zoom:80%;" />

#### 8.1.2 地址绑定

- 将符号地址(**Symbolic address**)绑定到可重定位的地址(**relocatable address**)
- 将可重定位的地址(**Relocatable address**)绑定到绝对地址(**absolute address**)

##### 编译时

- 如果在编译时可知，那么就生成绝对代码
- 地址发生变化需要重编译

##### 加载时

- 生成可重定位代码

##### 执行时

- 绑定延迟到执行时，需要硬件支持

#### 8.1.3 逻辑地址空间与物理地址空间

- CPU生成的地址通常称为逻辑地址，而内存单元看到的地址通常称为物理地址

- 编译时和加载时的地址绑定方法生成相同的逻辑地址和物理地址。执行时的地址绑定方案生成不同的逻辑地址和物理地址

##### 内存管理单元(MMU)

- 从虚拟地址到物理地址的运行时映射的硬件设备
- 用户进程所生成的地址在送交内存之前，需要加上重定位寄存器(**relocation register**)的值

<img src="https://i.loli.net/2020/11/15/tSg9znxZ4shLUEf.png" alt="image-20201112201932270.png" style="zoom:80%;" />

#### 8.1.4 动态加载

- 依据局部性原理(principle of locality of reference)

- 加载之前：可重定位代码
- 检查程序是否加载，如果没有，可重定位链接程序(**dynamic linking loader**)会加载所需的程序到内存，并更新程序的地址表以反映这一变化，然后控制传递给新加载的程序

#### 8.1.5 动态链接

##### 装入时动态链接(Load-time dynamic linking)

根据外部调用和引用，加载程序找到所需的对象模块和库，并将它们加载到内存中

##### 运行时动态链接(Dynamic Linking)

- 每个库程序的引用都有一个存根
- 存根是一小段代码，用来指出如何定位适当的内存驻留库程序
- 存根先检查所需程序是否在内存中，并将其加入
- 存根用程序地址替换自身，并执行程序

Advantage: 加载时间短、存储空间少

### 8.2 交换

- 备份存储大部分是快速磁盘，提供对这些存储器映像的直接访问

### 8.3 连续内存分配(Contiguous Memory Allocation)

#### 8.3.1 单一连续

- 内存分为两个区域：一个用于驻留OS，一个用于用户进程

<img src="https://i.loli.net/2020/11/15/CMwhnZslgrbp2S3.png" alt="image-20201114163901044.png" style="zoom:80%;" />

#### 8.3.2 多分区分配

多个用户进程同时驻留在内存中

- 用户分区分为n个
- 每个分区可能只包含一个进程
  1. 当分区空闲时，选择输入队列中的进程并将其加载到空闲分区
  2. 进程终止时，释放内存
- 分区数量决定**多道程序度**

##### 固定分区

- 将内存分为多个固定大小的分区

缺点：内存利用率低，内部碎片大

##### 动态分区

- 起初，所有的内存为一个大洞
- 根据需求分配内存给进程
- 释放内存时合并孔

OS管理：

1. 分区分配
2. 可用分区
   - 分区表
   - 分区list

##### 动态分配问题

First-fit:第一个足够大的孔

Next-fit:第二个足够大的孔

Best-fit:最小的足够大的孔

Worst-fit:最大的足够大的孔

优点：随着进程的换入换出，分区的数量，大小和位置都会动态变化；它十分灵活，可以提高内存利用率，避免由固定分区的不适当分区大小引起的内部碎片

缺点：随着分配的进行，可用分区分散在内存中；尽管进行了回收，内存仍被分成越来越多的碎片，形成大量的外部碎片(存储被分成了大量的小孔)

#### 8.3.3 碎片(Fragmentation)

**内部碎片**

进程所分配的内存比所需的大，这两个数字之差为内部碎片，这部分内存在分区内部，但不能用

**外部碎片**

总的可用内存之和可以满足请求但并不连续(存储被分成了大量的小孔)

##### 紧缩

- 移动内存内容，将所有空闲空间合并成一整块
- 只有重定位是动态的，并在运行时进行，才可采用紧缩

### 8.4 分段(Segmentation)

#### 8.4.1 分段策略

- 支持用户视图的内存管理方案

- 逻辑地址空间由一组段构成

- 每个段有名称和长度

  ​	<段号，偏移>

#### 8.4.2 分段硬件

##### 段表

- 映射用户定义的二维地址到一维物理地址
- **段基地址**：段在内存中的开始物理地址
- **段界限**：该段的长度

<img src="https://i.loli.net/2020/11/15/UFlkGqPcpMDLsAz.png" alt="image-20201115124939794.png" style="zoom:80%;" />

##### 基本段表硬件

- **段表基址寄存器(STBR)**

- **段表长度寄存器(STLR)**

  **s** is legal if **s < STLR**

<img src="https://i.loli.net/2020/11/15/cHzwNihYZmtkI1s.png" alt="image-20201115125245923.png" style="zoom:80%;" />

### 8.5 分页

- **帧/物理页框**：将物理内存分为固定大小的块
- **页**：将逻辑内存分为同样大小的块

#### 8.5.1 分页策略

- **页码(p)**：页表的索引
- **页偏移(d)**：与基地址相加得到物理地址

##### 页表

页码作为页表的索引，页表包含每页所在物理内存的基地址

##### 页

<img src="https://i.loli.net/2020/11/15/AHrROUKzdGZXlax.png" alt="image-20201114202647441.png" style="zoom:80%;" />

##### 帧表

由于操作系统管理物理内存，它需要知道物理内存的分配细节：哪些帧已分配、哪些帧可用、总共有多少帧……

#### 8.5.2 硬件支持

##### 基本页表硬件

- 页表存放在主存中
- **页表基址寄存器(PTBR)**

- **页表长度寄存器(PTLR)**

<img src="https://i.loli.net/2020/11/15/D6ZKAXI73eMCkrw.png" alt="image-20201115103614025.png" style="zoom:80%;" />

**Effective memory-Access (EAT, 有效访问时间)**

- 访问一个字节需要两次内存访问(一次用于页表，一次用于字节)

##### 转换表缓冲区(Translation Look-aside Buffer, TLB)

关联的高速内存

- 每个条目由键和值组成
- 同时与所有的键进行比较(高速)

- 代价昂贵，通常存储8~2048条目

**TLB miss**

如果页码在TLB中，则取得帧码；如果页码不在TLB中，则需访问页表，并将页码和帧码添加到TLB

<img src="https://i.loli.net/2020/11/15/mhqbwU7ivBYASes.png" alt="image-20201115101834743.png" style="zoom:80%;" />

**命中率**

TLB中找到页码的次数的百分比

<img src="https://i.loli.net/2020/11/15/urOWgJ79HkL1Bab.png" alt="image-20201115102615443.png" style="zoom:80%;" />

#### 8.5.3 保护

- 通过检查保护位来验证有没有进行正确操作

**有效-无效位**

有效表示相关页在进程的逻辑地址空间内，无效表示相关页不在进程的逻辑地址空间内

#### 8.5.4 共享页

- **可重入代码**是不能自我修改的代码，它在执行期间不会改变，所有进程中的共享代码逻辑地址必须相同

- 每个进程都有自己的寄存器副本和数据

<img src="https://i.loli.net/2020/11/15/nXDgjBMcYWLew67.png" alt="image-20201115121128880.png" style="zoom:80%;" />

### 8.6 页表结构

#### 8.6.1 分层页表

<img src="https://i.loli.net/2020/11/15/GWvS6yKgdrMkO5Z.png" alt="image-20201115121813907.png" style="zoom:80%;" />

#### 8.6.2 哈希页表

处理大于32位地址空间的常用方法是使用哈希页表

- 哈希页表的每一个条目都包含一个链表
- 每个元素由三个字段组成：
  - 虚拟页码
  - 映射的帧码
  - 指向链表内下一元素的指针

**Algorithm**

虚拟地址的虚拟页码哈希到哈希表，用虚拟页码与链表内的元素的字段逐一比较。如果匹配，则相应帧码形成物理地址

<img src="https://i.loli.net/2020/11/15/YbXlUROckj9Bv4q.png" alt="image-20201115122659927.png" style="zoom:80%;" />

#### 8.6.3 倒置页表(Inverted Page Tables)

- 对于每个真正的内存页或帧，倒置页表才有一个条目
- 每个条目包含保存在真正内存位置上的页的虚拟地址，以及拥有该页进程的信息

**Advantage**

- 整个系统只有一个页表
- 减少存储页表所需的内存

**Disadvantage**

- 发生页面引用时增加了搜索表所需的时间
- 可以使用哈希表将搜索限制为一个或最多几个页表条目

<img src="https://i.loli.net/2020/11/15/B3962dygNMVTEhJ.png" alt="image-20201115123142089.png" style="zoom:80%;" />

### 8.7 分页与分段的区别

#### 动机和目的

- 分页：**面向系统、物理上离散、减少外部和内部碎片、提高内存利用率**；页是信息的物理单元
- 分段：**面向用户，逻辑上离散，满足用户需求**；段是具有相对完整含义的信息的逻辑单元

#### 大小

- 分页：大小固定，由硬件决定
- 分段：大小不固定，由程序和编译时决定

#### 维度

- 分页：一维
- 分段：二维

### 作业

8.1 Name two differences between logical and physical addresses.

逻辑地址由CPU生成，物理地址由MMU生成。逻辑地址对用户是可视的，物理地址对用户是不可视的。逻辑地址通过MMU转化成物理地址。

8.2 Consider a system in which a program can be separated into two
parts: code and data. The CPU knows whether it wants an instruction
(instruction fetch) or data (data fetch or store). Therefore, two base–
limit register pairs are provided: one for instructions and one for data.
The instruction base–limit register pair is automatically read-only, so
programs can be shared among different users. Discuss the advantages
and disadvantages of this scheme.

可以共享公共代码。因为指令的寄存器对只读，所以代码为可重入代码，可以保存一个编辑器的副本，每个用户的页表映射到编辑器的同一物理副本，减少内存使用。同时由于只读，可以保证代码不会被修改。缺点是代码和数据需要分开，每个进程需要有自己的私有数据，并存储到不同的物理地址。

8.3 Why are page sizes always powers of 2?

对于m位的CPU来说，分页将地址分为页码m-n位和页偏移n位，每一位都代表着2个幂，其中页大小为2^n ，页的逻辑地址空间为2^(m-n)，所以页大小总为2的幂

8.4 Consider a logical address space of 64 pages of 1,024 words each, mapped
onto a physical memory of 32 frames.
a. How many bits are there in the logical address?

2^6 * 2^10 = 2^16

b. How many bits are there in the physical address?

2^5 * 2^10 = 2^15

8.5 What is the effect of allowing two entries in a page table to point to the
same page frame in memory? Explain how this effect could be used to
decrease the amount of time needed to copy a large amount of memory
from one place to another. What effect would updating some byte on the
one page have on the other page?

可以共享代码和数据。当需要重复多次执行代码时，每个进程使用相同的公共代码，页表映射到同一物理地址，不需要每次都复制内存，减少内存的使用。但如果对一个页中的代码进行修改，其余使用这份共享代码的页也会受到影响。

8.6 Describe a mechanism by which one segment could belong to the address
space of two different processes.

两个进程的段表中的条目指向同一物理地址。两个进程中的共享段的段号要相同。

8.7 Sharing segments among processes without requiring that they have the
same segment number is possible in a dynamically linked segmentation
system.
a. Define a system that allows static linking and sharing of segments
without requiring that the segment numbers be the same.
b. Describe a paging scheme that allows pages to be shared without
requiring that the page numbers be the same.

这两个问题都简化为一个程序可以引用自己的代码和数据，却不知道该段或页面
与地址关联的数字。 MULTICS通过以下方式解决了这个问题：每个进程将四个寄存器关联起来。一个寄存器具有当前程序段的地址，另一个寄存器具有堆栈的基地址，另一个寄存器具有全局数据的基地址，依此类推。这个想法是所有引用都必须通过映射到当前段或页码的寄存器进行间接访问。通过更改这些寄存器，可以在没有相同页码或段号的情况下针对不同的进程执行相同的代码。

8.9 Explain the difference between internal and external fragmentation.

进程所分配的内存比所需的大，这两个数字之差为内部碎片，这部分内存在分区内部，但不能用。外部碎片是存储被分成了大量的小孔，总的总的可用内存之和可以满足请求但并不连续。

8.12 Most systems allow a program to allocate more memory to its address
space during execution. Allocation of data in the heap segments of
programs is an example of such allocated memory. What is required
to support dynamic memory allocation in the following schemes?
a. Contiguous memory allocation
b. Pure segmentation
c. Pure paging

a. 可能需要整个程序重定位

b. 可能需要段重定位

c. 可以增加分配新页面，而无需重新定位程序的地址空间

paging物理上是不连续的

8.13 Compare the memory organization schemes of contiguous memory
allocation, pure segmentation, and pure paging with respect to the
following issues:
a. External fragmentation
b. Internal fragmentation
c. Ability to share code across processes

a. contiguous memory 、pure segmentation有外部碎片的问题，当旧进程结束，新进程加入时，由于进程长度不一，会产生小孔，重复多次会产生大量的小孔，形成外部碎片。而pure paging没有这种情况。

b. contiguous memory、pure segmentation没有内部碎片的问题，pure paging由于分配的内存可能大于所需内存，会产生内部碎片

c. contiguous memory不允许共享代码，pure segmentation和pure paging可以有共享代码，只需保证代码是可重入代码，进程中的共享代码逻辑地址相同。

8.14 On a system with paging, a process cannot access memory that it does
not own. Why? How could the operating system allow access to other
memory? Why should it or should it not?

PTLR和PTBR会限制进程只访问页表中的条目。如果操作系统允许非进程内存条目进入进程页表，它将提供对其他内存的访问。

8.17 Compare paging with segmentation with respect to how much memory
the address translation structures require to convert virtual addresses to
physical addresses.

分页需要的内存量更多

分页每页需要一个条目，每个条目存储一个页面映射的物理地址

分段只需要两个寄存器，一个寄存器管理段基址，一个寄存器管理段长

8.19 Program binaries in many systems are typically structured as follows.
Code is stored starting with a small, fixed virtual address, such as 0. The
code segment is followed by the data segment that is used for storing
the program variables. When the program starts executing, the stack is
allocated at the other end of the virtual address space and is allowed
to grow toward lower virtual addresses. What is the significance of this
structure for the following schemes?
a. Contiguous memory allocation
b. Pure segmentation
c. Pure paging

a. b. 可以重定位程序位置来分配新内存，c. 可以新增页

8.20 Assuming a 1-KB page size, what are the page numbers and offsets for
the following address references (provided as decimal numbers):
a. 3085

p: 3	d: 13

b. 42095

p: 41	d: 111

c. 215201

p: 210	d: 161

d. 650000

p: 634	d: 784

e. 2000001

p: 1953	d: 129

8.22 What is the maximum amount of physical memory?

取决于系统硬件

8.23 Consider a logical address space of 256 pages with a 4-KB page size,
mapped onto a physical memory of 64 frames.
a. How many bits are required in the logical address?

20

b. How many bits are required in the physical address?
18

8.24 Consider a computer system with a 32-bit logical address and 4-KB page
size. The system supports up to 512 MB of physical memory. How many
entries are there in each of the following?

2^29 / 2^12 = 2^17

8.25 Consider a paging system with the page table stored in memory.
a. If a memory reference takes 50 nanoseconds, how long does a
paged memory reference take?

100 ns

b. If we add TLBs, and 75 percent of all page-table references are found
in the TLBs, what is the effective memory reference time? (Assume
that finding a page-table entry in the TLBs takes 2 nanoseconds, if
the entry is present.)

EAT = 0.75 * (52) + 0.25 * (102) = 64.5ns

8.26 Why are segmentation and paging sometimes combined into one
scheme?

当页表变得非常大时，分段式分页很有用。可以将未使用的页表的大连续部分折叠为一个页表地址为零的单个段表条目。 通过分页段，我们减少了因外部碎片而造成的内存浪费，并简化了分配。

8.27 Explain why sharing a reentrant module is easier when segmentation is
used than when pure paging is used.

由于分段是基于内存的逻辑划分而不是物理划分，因此任何大小的分段都只能与每个用户的分段表中的一项共享。 使用分页时，页面表中必须为每个共享页面共享一个公共条目。

8.28 Consider the following segment table:
<img src="https://i.loli.net/2020/11/15/qOJ7iy2cUBjpkV1.png" alt="image-20201115131458354.png" style="zoom:80%;" />
What are the physical addresses for the following logical addresses?
a. 0,430
b. 1,10
c. 2,500
d. 3,400
e. 4,112

a. 649

b. 2310

c. illegal

d. 1727

e. illegal

8.29 What is the purpose of paging the page tables?

当页表太大，较难管理时，需要对页表进行分页

8.31 Compare the segmented paging scheme with the hashed page table
scheme for handling large address spaces. Under what circumstances is
one scheme preferable to the other?

当程序仅占据其大型虚拟地址空间的一小部分时，由于其较小的大小，因此可能首选哈希页表。 但是，哈希页面表的缺点是由于将多个页面映射到同一哈希页面表项中的冲突而引起的问题。 如果许多页面映射到同一个条目，则遍历与该哈希表条目相对应的列表可能会产生大量开销； 这样的开销在分段式分页方案中是最小的，在分页式分页方案中，每个页表项仅维护有关一个页面的信息。

