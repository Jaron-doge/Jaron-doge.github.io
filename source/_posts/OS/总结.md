---
title: 总结
date: 2020-12-20 13:30:15
tags: 
categories: 操作系统
---

### 第1章 导论

**操作系统是一组控制和管理计算机软硬件资源、合理地对各类作业进行调度以及方便用户的程序的集合**

#### Multiprogramming

- 提高CPU利用率
- 提高内存和I/O设备利用率
- 增加系统吞吐量

多道性 + 无序性

#### 特权指令

- 访问某些禁止用户访问的硬件的指令
- 直接访问I/O设备的指令
- 用于操作内存管理状态的指令
- 设置特殊状态位的指令
- HLT(停机指令)

#### kernel / user mode

kernel → user —— PSW(程序状态字)

user → kernel —— system call

---

**1.1**What are the three main purposes of an operating system?

- 提供一个用户可以运行程序的环境
- 提高软硬件资源的利用率
- 作为控制系统
  - 监督用户程序的执行，以防止错误和不当使用
  - 操作和控制管理I/O设备

### 第2章 操作系统结构

#### 简单结构

用户——系统调用——硬件

优点：内核通信和系统调用的开销小

缺点：用户程序可能导致系统崩溃

#### 分层结构

接受上一层的数据，并使用下一层的操作

优点：构造和调试简单

缺点：适当定义各层、效率较低

#### 微内核

将内核中不必要的功能封装到用户程序中

优点：内核小，可扩展性强

缺点：系统需要的功能越多，微内核的性能越差

### 第3章 进程

**进程是活动的程序实体，包括寄存器、堆栈、数据、代码、堆**

#### 进程状态转换图

![39.png](https://i.loli.net/2021/06/17/A2cZ6EyTno8kSgQ.png)

#### 进程调度

- Long-term scheduler选择应将哪些进程带入ready queue
- Short-term scheduler选择CPU执行哪个进程
  - 从ready queue
  - 频度高
- Medium-term scheduler
  - 从内存或CPU中移出进程
  - 可以降低多道程序运行的度（与Long-term scheduler相反）

#### 进程间通讯

**消息传递**

- 可用于交换少量数据，因为无需避免冲突
- 更容易实施
- 通过系统调用（例如send（），receive（））交换信息

**共享内存**

- 通过内存访问有更快的内存速度
- 系统调用仅用于建立共享内存区域

### 第4章 线程

<img src="https://i.loli.net/2020/10/23/A5bLvzJX6sPEdCO.png" alt="image-20201011095455371.png" style="zoom: 80%;" />

#### 进程与线程的比较

- 进程是资源分配单位，线程是CPU分配单位
- 进程拥有一个完整的资源平台，而线程只独享必不可少的资源，如寄存器和栈
- 线程同样具有就绪、阻塞和执行三种状态，同样具有状态之间的转换关系
- 线程能减少并发执行的时间和空间开销
- 线程 = 轻量级进程

#### 线程优点

- 响应性
- 资源共享
- 经济
- 可伸缩性

### 第5章 CPU调度

#### CPU调度发生的情况

- 从new到ready
- 从running到waiting
- 从running到ready
- 从waiting到ready
- terminate

2、5非抢占 

#### 调度准则

- CPU利用率
- 吞吐率：在时间单元内进程完成的数量
- 周转时间：从进程提交到进程完成的时间段，包括等待进入内存、在就绪队列中等待、在CPU上执行和I/O执行
- 等待时间：在就绪队列中等待所花时间之和
- 响应时间：从提交请求到产生第一响应的时间

#### 调度算法

FCFS、SJF、SRTF、优先级调度、RR、多级队列/多级反馈队列调度、实时调度算法（单调速率和最早截止优先调度）

饥饿：SJF、SRTF、优先级、多级队列

#### 线程调度

PCS发生在同一进程的线程之间，会将线程调度到可用LWP上；SCS用来决定哪个内核级线程调度到处理器上，发生在系统内的所有线程之间

### 第6章 进程同步

**竞争条件：多个进程并发访问且要求修改同一个数据**

#### 临界区问题解决

- mutual exclusion
- progress
- bounded waiting

#### 互斥锁

![40.png](https://i.loli.net/2021/06/17/eAcW4CXnOPSzKjZ.png)

优点：进程等待时无需上下文切换，简单容易实现

缺点：浪费CPU资源，会忙碌等待，饥饿

#### 信号量

![41.png](https://i.loli.net/2021/06/17/XfB9nwozpQMIGdi.png)

优点：避免了busy waiting，可以适用于非互斥的情况

缺点：用户的错误使用会导致死锁和饥饿

#### 生产者-消费者问题

![42.png](https://i.loli.net/2021/06/17/y9SgXLVRr68zUua.png)

### 第7章 死锁

**死锁：在系统的某一部分中，所有进程都在等待其他进程释放资源而陷入的无尽循环的等待过程**

- 互斥
- 占有并等待
- 非抢占
- 循环等待

#### 系统资源分配图：申请边、分配边

#### 死锁预防

**持有并等待**

每个进程必须一次申请完自己所需的所有资源

缺点：资源利用率低

**防止循环等待**

规划资源申请顺序，防止死锁

**安全状态**

进程的资源申请顺序<p1, pn>改顺序使得每个p都可申请到所需资源

#### 银行家算法

**安全算法**

![43.png](https://i.loli.net/2021/06/17/xvoqhD3LCN41HwY.png)

![44.png](https://i.loli.net/2021/06/17/pTlnzIDc8qBiv6K.png)

**资源请求算法**

![45.png](https://i.loli.net/2021/06/17/pTlnzIDc8qBiv6K.png)

### 第8章 内存管理

#### 连续内存分配

**固定分区**

**可变分区**

- 首次适应
- 最优适应
- 最差适应

问题：内部碎片、外部碎片

#### 分页



#### 分段

<段号、偏移>

STBR、STLR

#### 分页与分段的区别

**动机和目的**

- 分页：**面向系统、物理上离散、减少外部和内部碎片、提高内存利用率**；页是信息的物理单元
- 分段：**面向用户，逻辑上离散，满足用户需求**；段是具有相对完整含义的信息的逻辑单元

**大小**

- 分页：大小固定，由硬件决定
- 分段：大小不固定，由程序和编译时决定

**维度**

- 分页：一维
- 分段：二维

### 虚拟内存管理

**请求调页：在程序需要一部分内存页面时，从硬盘中加载对应页面到内存的技术**

**系统抖动：进程的调页时间多于执行时间，监视cpu利用率，降低说明发生抖动**