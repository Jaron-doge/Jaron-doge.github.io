---
title: 第9章 虚拟内存管理
date: 2020-11-22 13:30:15
tags: 
categories: 操作系统
---
## 虚拟内存管理

### 9.1 背景

#### Virtual Memory

<!-- more -->

是指具有请求调页功能和置换功能，能从逻辑上对内存容量加以扩充的一种存储器系统

**虚拟内存** = **物理内存** + **磁盘**

- 多次性

  一个作业被分成多次装入内存运行

- 对换性

  允许在进程运行的过程中，(部分)换入换出

- 虚拟性

  逻辑上的扩充

**优点**：

- 进程共享内存和文件

- 加速进程创建
- 程序员不用关系内存限制
- 可以同时运行更多程序
- 更少的I/O需求，程序运行更快

### 9.2 请求调页(Demand Paging)

#### 9.2.1 基本概念

##### Swapper VS. Pager

- 交换器操纵整个进程
- 处理单个页面的swapper是pager

**惰性交换器(Lazy swapper)**

除非需要某个页面，否则从不将它交换到内存中

##### 修改页表机制(有效无效位)

v	⇒	in-memory & logical

i 	⇒	not-in-memory 或者有效但只在磁盘上

##### Page Fault

请求调页的关键要求是在缺页错误后重新启动任何指令的能力。当发生**page fault**时，**保存被中断的进程状态**，在完全相同的位置和状态下，重新启动进程。如果在获取指令时出现了缺页错误，那么再次获取指令

##### Page Fault Handling

1. 检查进程的内部表(通常与PCB一起保存)，确定该引用是有效的还是无效的
2. 如果引用无效，那么终止进程，如果引用有效但尚未调入页面，则调入
3. 找到一个空闲帧
4. 调度一个磁盘操作，以将所需页面读到刚分配的帧
5. 修改进程的内部表和页表，设置v
6. 重新启动被缺页错误中断的指令

<img src="https://i.loli.net/2020/11/22/WYz1rBUaP2gjTwm.png" alt="image-20201122150607589.png" style="zoom:80%;" />

##### Address translation

Address translation hardware + page fault handling

<img src="https://i.loli.net/2020/11/22/9UVHJMWhopwvRSk.png" alt="image-20201122152004936.png" style="zoom:80%;" />

#### 9.2.2 请求调页的性能

##### EAT

p = **Page Fault Rate**(0 ≤ p ≤ 1.0)

**EAT** = (1 - p) × memory access + p × page fault time

缺页错误时间 = 缺页错误开销 + 换出页面(optional) + 读入页面 + 重启进程

- 程序执行局部化可以降低**page fault rate**

##### 交换空间

前提：交换空间的文件系统更快

1. 系统可以在进程启动时将**整个文件映像复制到交换空间中**，然后从交换空间执行请求调页，从而获得更好的分页吞吐量

2. 开始时从文件系统进行请求调页，但在**置换页面时将页面写入交换空间**。这种方法确保**只从文件系统读取所需的页面**，后续调页都是从交换空间完成的

### 9.3 写时复制(Copy-on-Write)

​		允许父进程和子进程最初共享内存中的相同页面。如果任一进程修改了共享页面，则将创建共享页面的副本，因为仅复制修改过的页面，所以COW更有效地创建进程。

​		假设子进程试图修改包含部分堆栈的页面，并且设置为写时复制。操作系统会创建这个页面的副本，将其映射到子进程的地址空间。然后，子进程会修改复制的页面，而不是属于父进程的页面

​		操作系统为这类请求提供了一个空闲的页面池**(page pool)**，空闲页面从页面池中分配。分配这些页面的技术称为**按需填零(zero-fill-on-demand)**技术，页面在分配前先填零，清除以前的内容

### 9.4 页面置换

**over-allocation**:为了增加多道程序，可能会导致过度分配，没有空闲帧，所有的内存都在使用

- 页面置换是请求调页的基础，它完成了逻辑内存和物理内存之间的分离

算法评估：针对特定内存引用串，运行某个置换算法，并计算缺页错误的数量

- 页面错误数量取决于进程分配的帧的数量

#### 9.4.1 基本页面置换

1. 找到所需页面的磁盘位置

2. 找到空闲帧

   a. 如果有空闲帧，使用它

   b. 如果没有空闲帧，使用页面置换算法来选择一个牺牲帧**(victim frame)**

   c. 将牺牲帧的内容写到磁盘上，修改对应的页表和帧表

3. 将所需页面读入(新的)空闲帧，修改页表和帧表

4. 从发生缺页错误位置，继续用户进程

<img src="https://i.loli.net/2020/11/22/zQCIvYSElZ9ULh7.png" alt="image-20201122161446738.png" style="zoom:80%;" />

​		稍后，**对该页面的引用将导致缺页错误**。那时，页面将被调回到内存

##### 修改位(modify bit) / 脏位(dirty bit)

​		当要选择一个页面进行置换时，就检查它的修改位。如果该位已被设置，那么该页面从磁盘读入以后已被修改。在这种情况下，应将页面写入磁盘。然而，如果修改位未被设置，那么该页面从磁盘读入以后还未被修改。在这种情况下，我们不需要将内存页面写到磁盘因为它已经存在。

#### 9.4.2 FIFO页面置换

选择最旧的页面进行置换

<img src="https://i.loli.net/2020/11/22/DF7e8rzQcBnqytN.png" alt="image-20201122164853072.png" style="zoom:80%;" />

##### Belady's anomaly(贝莱迪异常现象)

<img src="https://i.loli.net/2020/11/22/lXT8cdpJ9myknaM.png" alt="image-20201122165117164.png" style="zoom:80%;" />

#### 9.4.3 最优页面置换

- 置换最长时间不会使用的页面

然而，因为需要引用串的未来知识，难以实现，最优算法主要用于比较研究

#### 9.4.4 LRU页面置换

**最近最少使用算法(Least-Recent-Used algorithm)**

- LRU置换将每个页面与它的上次使用的时间关联起来。当需要置换页面时，LRU选择最长时间没有使用的页面。

##### 计数器实现

- 每个页表条目关联一个使用时间域，并为CPU添加一个逻辑时钟

- 每当进行页面引用时，复制时钟寄存器的内容到页表条目的使用时间域中

  ​	(每次内存访问都要写到内存)

- 当需要页面置换时，搜索页表，选择具有最小时间的页面

##### 堆栈实现

使用具有首指针和尾指针的双向链表实现

- 每当页面被引用时，就从堆栈中移除并放在顶部

  ​	(可能每次需要改变6个指针)

- 更新有点费时，但置换不用搜索

栈底页面就是LRU页面

<img src="https://i.loli.net/2020/11/22/cBsnDGN6TljQf1M.png" alt="image-20201122172558599.png" style="zoom:80%;" />

#### 9.4.5 近似LRU页面置换

**引用位**

**每当引用一个页面时，它的页面引用位就被硬件置位**

- 最初所有**reference bit**由OS清0

- 当页面被引用时，**reference bit**置1
- 置换**reference bit**是0的页面

##### 9.4.5.1 额外引用位算法(Additional-Reference-Bits)

- 为内存中的页表的每个页面保留一个8位的字节
- 定时器中断定期地将控制传到OS
- OS将每个页面引用位移到其8位字节的高位，将其他位右移1位
- **具有最小编号的页面是LRU页面**，可以被替换

##### 9.4.5.2 第二次机会算法(Second-Chance Algorithm)

- 按FIFO算法选择一个页面
- 如果**reference bit**为0， 置换
- 如果**reference bit**为1
  - 设置**reference bit**为0
  - 保留页面
  - 按相同规则替换下一页面（按时钟顺序）

<img src="https://i.loli.net/2020/11/22/gRG7Qbvmx3IAjHB.png" alt="image-20201122180447872.png" style="zoom:80%;" />

##### 9.4.5.3 增强型第二次机会算法

**reference bit** + **modify bit**

- 四种类型
  - (0, 0)—最近没有使用且没有修改的页面，**最佳的页面置换**
  - (0, 1)—最近没有使用但修改过的页面，需要置换前将页面写出到磁盘
  - (1, 0)—最近使用过但没有修改的页面，可能很快再次使用
  - (1, 1)—最近使用过且修改过，需要置换前将页面写出到

- **如果扫描到(0, 1)，则换为(0, 0)**

<img src="https://i.loli.net/2020/11/22/RZliLOWQUuxJCh3.png" alt="image-20201122185018106.png" style="zoom:80%;" />

<img src="https://i.loli.net/2020/11/22/pk6hQ48Fm27wyzd.png" alt="image-20201122181130772.png" style="zoom:80%;" />

### 9.4.6 基于计数的页面置换(Counting Algorithms)

为每个页面的引用次数保存一个计数器

##### 9.4.6.1 最不经常使用(Least-Frequently Used, LFU)

- 置换具有最小计数的页面

问题：一个页面最初大量使用但随后不用时，会出现问题

解决方案：定期地将计数右移1位，以衰减平均使用计数

<img src="https://i.loli.net/2020/11/22/2Q4TtpqJk6U1fjM.png" alt="image-20201122185744389.png" style="zoom:80%;" />

##### 9.4.6.2 最经常使用(Most-Frequently Used, MFU)

具有最小计数的页面可能刚刚被引入并且尚未使用

- 置换具有最大计数的页面

### 9.5 帧分配

#### 9.5.1 帧的最小数

每个进程需要最小数量的帧

#### 9.5.2 分配算法

##### Fixed Allocation

**平均分配(Equal Allocation)**

n个进程m个帧

每个进程获得 m / n 帧

**比例分配(Proportional Allocation)**

根据进程大小进行分配可用内存

a<sub>i</sub> =	s<sub>i</sub> / S	×	m

##### Priority Allocation

根据进程的优先级分配内存

#### 9.5.3 全局分配与局部分配

##### 全局置换(Global Replacement)

进程从所有帧的集合中选择一个置换帧，**而不管该帧是否已分配给其他进程**

问题：进程无法控制其自身的页面错误率

##### 局部置换(Local Replacement)

每个进程只从它自己分配的帧中进行选择

问题：不能使用其他进程的较少使用的内存页面

### 9.6 系统抖动(Thrashing)

#### 9.6.1 系统抖动的原因

​		如果一个进程没有需要支持活动使用页面的帧数，那么它会很快产生缺页错误。此时，必须置换某个页面。然后循环产生缺页错误。

​		这种高度的页面调度活动称为抖动。如果**一个进程的调页时间多于它的执行时间**，那么这个进程就在抖动。

- 缺页错误进程使用调页设备将页面换进换出，为调页设备排队，就绪队列清空，CPU利用率低
- OS增加多道程序度
- 新进程试图获取帧来启动，导致更多的缺页错误和更长的调页设备队列

​		

​	不合理的多道程序度造成系统抖动

<img src="https://i.loli.net/2020/11/22/261DXNW5fUZM7ow.png" alt="image-20201122193339588.png" style="zoom:80%;" />

##### 局部性模型(Locality model)

随着进程执行，它从一个局部移向另一个局部。局部性是最近使用页面的一个集合。局部可能会重叠

#### 9.6.2 工作集模型(Working-Set Model)

工作集模型基于局部性假设 

**Δ ≡ 工作集窗口(Working-set Window)**，检查最近Δ个页面引用，这**最近Δ个页面引用的页面集合称为工作集(Working-set)**，如果页面不再使用，它在最后一次引用的Δ时间单位后，会从工作集中删除。

<img src="https://i.loli.net/2020/11/22/bwOcqWldX9GKZe7.png" alt="image-20201122201545219.png" style="zoom:80%;" />

##### Working set size(WSS)

**WSS<sub>i</sub>**(working set of Process P<sub>i</sub>) = **最近Δ个页面引用的数量**

**D** 	=	**Σ WSS<sub>i</sub>**	≡ 	**总需求**

如果总需求大于可用帧的总数**(D > m) ⇒ 发生抖动**

##### 策略

如果工作集大小的总和超过可用帧的总数，OS会**选择一个进程挂起**，该进程的页面被写出，并且其帧可分配给其他进程

##### 跟踪工作集

**定期时钟中断(fixed interval timer)** + **引用位(reference bit)** 

例：Δ = 10,000

- 每5000个引用引起定时器中断
- 每页有两个内存的位
- 当发生定时器中断时，复制并清除所有页面的引用位

- 如果内存中两位有一位是1，那么页面在工作集中

通过增加历史位的数量和中断的频率可以降低不确定性，10位和每1000个引用引起定时器中断

#### 9.6.3 缺页错误频率(Page-Fault Frequency, PFF)

设置可接受的缺页错误率

<img src="https://i.loli.net/2020/11/22/EcLrQIpHWiv2tJm.png" alt="image-20201122205056446.png" style="zoom:80%;" />

### 9.8 分配内核内存

通常从空闲内存池中分配内核内存

- 内核需要为不同大小的数据结构请求内存
- 有些内核内存需要常驻在连续物理内存中

#### 9.8.1 伙伴系统(Buddy System)

从物理连续的大小固定的段商进行分配

内存分配采用2的幂分配器

<img src="https://i.loli.net/2020/11/22/LR4h859ojrg1ZxF.png" alt="image-20201122231351936.png" style="zoom:80%;" />

#### 9.8.2 slab分配器(Slab Allocator)

- 每个slab由一个或多个物理连续的页面组成

- 每个cache由一个或多个slab组成

- 每个内核数据结构都有一个cache

- 每个cache含有内核数据结构的对象实例

1. 在创建cache时，将若干标记为free的对象分配到cache

2. 从cache上分配的对象标记为used

3. slab分配器首先在部分为空的slab中用空闲对象来满足请求，如果不存在，则从空的slab中分配空闲对象

   slab三状态：

   - full: slab的所有对象标记为可用
   - empty: slab上的所有对象标记为空闲
   - partial: slab上的对象有的标记为使用，有的标记为空闲

4. 如果没有空的slab，则从连续物理页面分配新的slab

<img src="https://i.loli.net/2020/11/22/mqZVHBSFfJL7i6Q.png" alt="image-20201122232820522.png" style="zoom:80%;" />

优点：没有碎片，可以快速满足内存请求