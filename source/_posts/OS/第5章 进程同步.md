---
title: 第5章 进程同步
date: 2020-10-17 20:30:15
tags: 
categories: 操作系统
---
## 进程同步

### 临界区问题

#### 竞争状态(race condition)

<!-- more -->

​	多个进程同时访问和操作相同的数据，执行的结果取决于访问发生的特定顺序。所以确保一次只能处理一个进程。

#### 临界区条件

- 互斥
- 空闲让进
- 有限等待

### 互斥访问

- 加锁标志位法

- 强制轮流法
- 标记法

#### 基于繁忙等待的互斥

​		当一个进程要进入其关键部分时，首先要检查是否允许其进入。 如果允许，它将直接进入； 如果不允许，它将循环等待直到允许其进入

​	缺点：

- 浪费CPU时间

- 可能会导致意外结果（如一个低优先级进程位于临界区中，这时有一个高优先级进展也试图进入临界区）

### 硬件中断实现的互斥

缺点：

- 禁用中断后，无法停止该过程
- 可能导致其他进程处于饥饿
- 关键部分可能很长，无法确定响应时间
- 它适用于单个处理器，在多处理器计算机上不起作用，其他CPU仍可以进入关键区域

### 高度抽象方法

#### 锁

<img src="https://i.loli.net/2020/10/23/5jMQEYrJeCsbAmS.png" alt="image-20201014155240628.png" style="zoom: 67%;" />

#### 没有busy waiting的lock

- 增添等待队列

优点：

- 适用于单个处理器或共享主内存的多个处理器上的任意数量的进程同步
- 简单容易证明
- 支持多临界区

缺点：

- 繁忙的等待消耗处理器时间
- 可能导致饥饿
- 死锁：低优先级进程占据临界区； 高优先级进程请求访问临界区并等待

### 信号量

- 计数信号量、二进制信号量

![image-20201014171835419.png](https://i.loli.net/2020/10/23/Z2K7Qk1eizsB5wG.png)

### 经典同步问题

#### 生产者-消费者问题

![image-20201014172023506.png](https://i.loli.net/2020/10/23/bDAv6X1jiEcrZJ5.png)

#### 读者-写者问题

![image-20201014172033292.png](https://i.loli.net/2020/10/23/tGgLweIFjc4hNdP.png)

#### 哲学家就餐问题

奇数先左后右，偶数先右后左
![image-20201014172137641.png](https://i.loli.net/2020/10/23/sFUrkxnV82SwEzy.png)

### 管程

![image-20201014172415297.png](https://i.loli.net/2020/10/23/w8cKbxayOFGP6v5.png)

#### 条件变量

条件变量是管程上的等待机制

#### 两种条件变量操作

Wait():

- 将自己阻塞再等待队列中
- 唤醒一个等待线程

Signal():

- 唤醒等待队列中的线程
- 如果等待队列为空，则相当于一个空操作

![image-20201014174245226.png](https://i.loli.net/2020/10/23/ruMh6GvxJZ2bsXN.png)

### 作业

5.3 What is the meaning of the term busy waiting? What other kinds of
waiting are there in an operating system? Can busy waiting be avoided
altogether? Explain your answer.

繁忙等待表示进程在占用CPU的情况下不停地循环来等待执行，进程还可以放弃CPU转入进程等待队列，等待被唤醒。可以避免繁忙等待，可以将其转入进程等待队列等待被唤醒。

5.5 Show that, if the wait() and signal() semaphore operations are not
executed atomically, then mutual exclusion may be violated.

当一个信号量为1时，如果wait()不是原子地执行，成功执行了两次wait()操作，导致信号量总共减少2，就会导致违反互斥。

5.6 Illustrate how a binary semaphore can be used to implement mutual
exclusion among n processes.

在每个进程的entry section调用wait(mutex)，exit section调用signal(mutex)

5.10 Explain why implementing synchronization primitives by disabling
interrupts is not appropriate in a single-processor system if the synchronization
primitives are to be used in user-level programs.

因为如果当执行一个进程时，有更高优先级的进程也需要执行时，由于同步机制，kernel无法进行调度，更高优先级的进程只能等待。同时，低优先级进程占据临界区， 高优先级进程请求访问临界区并等待会造成死锁发生。当进程离开临界区时会有许多等待进程，这种情况下可能造成饥饿。

5.11 Explain why interrupts are not appropriate for implementing synchronization
primitives in multiprocessor systems.

中断只会阻止其他在中断发生的处理器上的进程执行，因为其他处理器执行的操作不受限，仍可进入该进程的临界区，不能保证互斥访问

5.12 The Linux kernel has a policy that a process cannot hold a spinlock while
attempting to acquire a semaphore. Explain why this policy is in place.

为了防止饥饿和死锁。当低优先级进程拥有自旋锁，而高优先级进程请求访问临界区并等待时，可能会发生死锁。进程拥有自旋锁，一直占用CPU资源，可能导致其他进程得不到资源，造成饥饿。

5.13 Describe two kernel data structures in which race conditions are possible.
Be sure to include a description of how a race condition can occur.

stack和queue，当一个进程对stack执行pop()操作时，另一个进程对stack执行了push()操作，那么此进程pop()出的并不是想要得到的结果。queue类似，当一个进程对queue执行pop()操作，而另一个进程对queue抢先执行了一次pop()，那么此进程pop()出的并不是想要得到的结果。

5.23 Show how to implement the wait() and signal() semaphore operations
in multiprocessor environments using the test and set() instruction. The solution should exhibit minimal busy waiting.

给信号量新增一个计数器和队列，利用等待队列来降低繁忙等待。代码如下：

typedef struct {

​	int value;

​	WaitQueue q;	// 一个等待队列

} Semaphore;

int lock = 0;

wait(Semaphore* S) {

​	while(test_and_set(&lock)) {

​		S->value--;

​		if(S->value < 0)

​			block();

​	}

}

signal(semaphore* S) {

​	lock = 0;	

​	S->value++;

​	if(S->value <= 0)

​		wakeup(P);					// 把进程改为就绪状态，插入就绪队列

}

5.25 Demonstrate that monitors and semaphores are equivalent insofar
as they can be used to implement solutions to the same types of
synchronization problems.

在使用信号量处理同步问题时，进程在进入临界区前获取系统资源，无资源则挂起进入等待队列。退出临界区后释放资源，如果释放后有可用资源，则唤醒等待队列中的一个进程。这样的管理方式与管程类似，只需将管程的条件变量设为判断是否有可用资源，则会与信号量拥有类似的实现结构和方式，它们在处理同步问题上是等效的。

5.26 Design an algorithm for a bounded-buffer monitor in which the buffers
(portions) are embedded within the monitor itself.

设计一个结构体buffer,里面有数据存储区，读写标识符，计数器以及两个条件变量。

利用条件变量来实现进程对共享内存的互斥访问，

伪代码如下：

struct bound-buffer {

​	int size = 32;	

​	char buffer[32];

​	int writepos, readpos;

​	int cnt;

​	condition notfull, notempty;

} buffer;

int mutex;

void producer(int data) {

​	wait(mutex);

​	if(cnt == size)

​		cond_wait(notfull);

​	buffer[writepos] = data;

​	writepos = (writepos + 1) % size;

​	cond_signal(notempty);

​	signal(mutex);

}

void comsumer() {

​	wait(mutex);

​	if(cnt == 0)

​		cond_wait(not empty);

​	int data = buffer[readpos];

​	readpos = (readpos + 1) % size;

​	cond_signal(notfull);

​	signal(mutex);

}

5.32 A file is to be shared among different processes, each of which has
a unique number. The file can be accessed simultaneously by several
processes, subject to the following constraint: the sum of all unique
numbers associated with all the processes currently accessing the file
must be less than n. Write a monitor to coordinate access to the file.

在管程中设计一个计数器，并设计操作，在进入进程的临界区前，增加检查计数器加当前id是否小于总和n，如果小于n，则将其累加进计数器中，如果大于n，则进行繁忙等待。在退出临界区后中让计数器减去当前id，并唤醒其他进程。



5.37 Assume that a finite number of resources of a single resource type must be managed. Processes may ask for a number of these resources and will return them once finished. As an example, many commercial software packages provide a given number of licenses, indicating the number of applications that may run concurrently. When the application is started, the license count is decremented. When the application is terminated, the license count is incremented. If all licenses are in use, requests to start the application are denied. Such requests will only be granted when an existing license holder terminates the application and a license is returned. The following program segment is used to manage a finite number of instances of an available resource. The maximum number of resources and the number of available resources are declared as follows:![image-20201014144721685.png](https://i.loli.net/2020/10/23/opk8WXmlThMJdPC.png)

The preceding program segment produces a race condition. Do the
following:
a. Identify the data involved in the race condition.

available_resources

b. Identify the location (or locations) in the code where the race
condition occurs.

在语句 available_resources -= count和语句available_resources += count处，假设available_resources初值为1，第一个进程调用decrease_count()，在执行到else时发生中断，此时available_resources为1。第二个进程调用decrease_count()并执行完毕，假设count值为1，available_resources执行完为0。切换上下文回第一个进程继续执行，假设count为1，available_resources会得到负数的结果，也就意味着越界了。

c. Using a semaphore or mutex lock, fix the race condition. It is
permissible to modify the decrease count() function so that the
calling process is blocked until sufficient resources are available.

利用互斥锁实现，伪代码如下：

int mutex = 1;

int decrease_count(int count) {

​	if(available_resources < count)

​		return -1;

​	else {

​		wait(mutex);

​		available_resources -= count;

​		signal(mutex);

​		return 0;

​	}

}

int increase_count(int count) {

​	wait(mutex);

​	available_resources += count;

​	signal(mutex);

​	return 0;

}