---
title: 第六章 图
date: 2020-09-17 20:30:15
tags: 图
categories: 数据结构
---
## 第六章 图

### 顶点和边

<!-- more -->

```c++
typedef enum {UNDISCOVERED, DISCOVERED, VISITED} VStatus;
template <typename Tv> struct Vertex {
    Tv data; int inDegree, outDegree;	// 数据、出入度数
    VStatus status;						// 状态
    int dTime, fTime;					// 发现时刻、访问完时刻
    int parent;							// 遍历树中父节点
    int priority;						// 遍历树中优先级
}
```

```c++
typedef enum {UNDETERMINED, TREE, CROSS, FORWARD, BACKWARD} 
EStatus;
template <typename Te> struct Edge {
    Te data;			// 数据
    int weight;			// 权重
    EStatus status;		// 类型
}
```

![几种图边.png](https://i.loli.net/2020/09/16/ioFlDQ6NMV8XAug.png)

### 广度优先搜索(BFS)

```c++
template <typename Tv, typename Te>
void Graph<Tv, Te>::BFS(int v, int& clock)
{
    queue<int> Q; status(v) = DISCOVERED; Q.euqueue(v);
    while(!Q.empty()) {
        int v = Q.dequeue();
        dTime = ++clock;
        for(int u = firstNbr(v); -1 < u; u = nextNbr(v, u))
            if(status(u) == UNDISCOVERED) {	// 若u未被发现
                status(u) = DISCOVERED;		// 发现该顶点
                Q.euqueue(u);
                status(v, u) = Tree;		// 引入树边
                parent(u) = v;				
            } 
        	else
                status(v, u) = CROSS;
                
        status(v) = VISITED;
    }
}
```

```c++
template <typename Tv, typename Te>
void Graph<Tv, Te>::bfs(int s) {		// s为起始节点
    reset();
    int clock = 0;
    int v = s;
    do {
    	if(status(v) == UNDISCOVERED)
            BFS(v, clock);
    }while(s != (v = ++v % n));
}
```

- BFS可以得到最短路径

### 深度优先搜索(DFS)

```c++
template <typename Tv, typename Te>
void Graph<Tv, Te>::DFS(int v, int& clock) {
    dTime(v) = ++clock;
    status(v) = DISCOVERED;
    for(int u = firstNbr(v); -1 < u; u = nextNbr(v, u)) {
        switch(status(u)) {
            case UNDISCOVERED:		// u尚未发现，意味支撑树可扩展
                status(v, u) = TREE;
                parent(u) = v;
                DFS(u, clock);
                break;
            // u已被发现但尚未访问完毕，应属被后代指向的祖先
            case DISCOVERED:		
                status(v, u) = BACKWARD;
                break;
            default:		// u已访问完毕，视承袭关系分为前向边或跨边
                status(v, u) = dTime(v) < dTime(u) ? FORWARD : 						CROSS;
                break;
        }
    }
    status(v) = VISITED;
    fTime(v) = ++clock;
}
```

```c++
template <typename Tv, typename Te>
void Graph<Tv, Te>::dfs(int s) {
    reset();
    int clock = 0;
    int v = s;
    do {
        if(status(v) == UNDISCOVERED)
        	DFS(v, clock);
    }while(s != (v = v++ % n));
}
```

#### 括号引理(Parenthesis lemma)

给定有向图G = (V, E)及其任一DFS森林，则

- u是v的后代	iff	active[u]	⊆	active[v]
- u是v的祖先	iff	active[u]	⊇	active[v]
- u与v“无关”	iff	active[u]	∩	active[v]	=	Ø

### 基于DFS搜索框架的拓补排序算法

```c++
template <typename Tv, typename Te>
stack<Tv>* Graph<Tv, Te>::tSort(int s) {
    reset(); int clock = 0; int v = s;
    do {
        if(status(v) == UNDISCOVERED)
            if(!TSort(v, clock, s)) {
                while(!S.empty())
                    S->pop();
                break;
            }
    } while(s != (v = ++v % n));
    return S;
}
```

```c++
template <typename Tv, typename Te>
bool Graph<Tv, Te>::TSort(int v, int& clock, stack<Tv>* S)
{
    dTime(v) = ++clock; status(v) = DISCOVERED;
    for(int u = firstNbr(v); -1 < u; u = nextNbr(v, u)) {
        switch(status(u)) {
            case UNDISCOVERED:		// u尚未发现，意味支撑树可扩展
                status(v, u) = TREE;
                parent(u) = v;
                if(!TSort(u, clock, S));
                	return false;
                break;
            // u已被发现但尚未访问完毕，应属被后代指向的祖先
            case DISCOVERED:		
                status(v, u) = BACKWARD;
                return false;
            default:		// u已访问完毕，视承袭关系分为前向边或跨边
                status(v, u) = dTime(v) < dTime(u) ? FORWARD : 						CROSS;
                break;
        }
    }
    status(v) = VISITED;
	S->push(vertex(v));
}
```

### 优先级搜索(priority-first search)

​		优先级数越大顶点的优先级越低

```c++
template <typename Tv, typename Te> template <typename PU>
void Graph<Tv, Te>::PFS(int s, PU prioUpdater) {
    priority(s) = 0; status(s) = VISITED; parent(s) = -1;
    while(true) {
        for(int w = firstNbr(s); -1 < w; w = nextNbr(s, w))
            prioUpdater(this, s, w);   // 更新顶点w的优先级及其父节点
        for(int shortest = INT_MAX, w = 0; w < n; w++)
            if(status(w) == UNDISCOVERED)	// 从尚未遍历的顶点中
                if(shortest > priority(w)) {// 选出下一个
                    shortest = priority(w);	// 优先级最高的顶点
                    s = w;
                }
        if(status(s) == VISITED)
            break;
        status(s) = VISITED; 			// 将s及其父顶点的联边加入树
        status(parent(s), s) = TREE;
    }
}
```

```c++
template <typename Tv, typename Te> template <typename PU>
void Graph<Tv, Te>::pfs(int s, PU prioUpdater) {
    reset();
    int v = s;
    do 
        if(status(v) = UNDISCOVERED)
            PFS(v, prioUpdater);
    while(s != (v = ++v % n));
}
```

#### 基于PFS的BFS算法

```c++
template <typename Tv, typename Te> struct BfsPU {
    virtual void operator()(Graph<Tv, Te>* g, int uk, int v) {
        if(g->status(v) == UNDISCOVERED) {
            if(g->priority(v) > g->priority(uk) + 1)
                g->priority(v) = g->priority(uk) + 1；
                g->parent(v) = uk;
        }
    }
};
```

#### 基于PFS的DFS算法

```c++
template <typename Tv, typename Te> struct DfsPU {
    virtual void operator()(Graph<Tv, Te>* g, int uk, int v) {
        if(g->status(v) == UNDISCOVERED) {
           	if(g->priority(v) > g->priority(uk) - 1) {
                g->priority(v) = g->priority(uk) - 1;
                g->parent(v) = uk;
                return;
            }
        }
    }
};
```



### 基于PFS的Prim算法

​		在找到V~k~的最短跨越边e~k~=(v~k~, u~k~)后，可以将T~k~扩展为更大子树T~k+1~

```c++
template <typename Tv, typename Te> struct PrimPU {
    virtual void operator()(Graph<Tv, Te>* g, int uk, int v) {
        if(g->status(v) == UNDISCOVERED) {//对uk每一尚未被发现邻接点
            if(g->priority(v) > g->weight(uk, v)) {
                g->priority(v) = g->weight(uk, v);	// 更新优先数
                g->parent(v) = uk;					// 更新父节点
            }
        }
    }
}
```

### 基于PFS的Dijkstra算法

```c++
// 考虑u~k+1~到起点s的距离
template <typename Tv, typename Te> struct DijkstraPU {
    virtual void operator()(Graph<Tv, Te>* g, int uk, int v) {
        if(g->status(v) == UNDISCOVERED) {
            if(priority(v) > priority(uk) + weight(uk, v)) {
                priority(v) = priority(uk) + weight(uk, v);
                g->parent(v) = uk;
            }
        }
    }
}
```

### 概念

1. 欧拉环路(Eulerian tour)

   ​	经过每一条边一次且恰好一次的环路

2. 哈密尔顿环路(Hamiltonian tour)

   ​	经过每一个顶点一次且恰好一次的环路

3. 活动期

   ```c++
   active[u] = (dTime[u], fTime[u])
   ```

4. 拓扑排序

   ​	对一个DAG进行拓扑排序，将G中所有顶点排成一个线性序列，使得图中任意一对顶点u和v，若边<u, v> ∈ E(G)，则u在线性序列中出现在v之前

5. 关节点(articulation point)

   ​	节点的删除将导致连通域的增加

6. 双连通图

   ​	不含任何关节点的图

7. 最小支撑树

   ​	最小支撑树总是会采用联接每一割的最短跨越边