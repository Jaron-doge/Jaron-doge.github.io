---
title: 第七章 二叉搜索树
date: 2020-09-19 20:30:15
tags: 树
categories: 数据结构
---
## 第七章 二叉搜索树

### 二叉搜索树

<!-- more -->

```c++
template <typename T> class BST : public BinTree<T> {
public:
	virtual BinNodePosi(T)& search(const T&);
    virtual BinNodePosi(T)& insert(const T&);
    virtual bool remove(const T&);
protected:
    BinNodePosi(T) _hot;
    BinNodePosi(T) connect34(
    	BinNodePosi(T), BinNodePosi(T), BinNodePosi(T),
    BinNodePosi(T), BinNodePosi(T), BinNodePosi(T), BinNodePosi(T));
    BinNodePosi(T) rotateAt(BinNodePosi(T) x);
};
```

#### 搜索

```c++
template <typname T> BinNodePosi(T)& BST<T>::search(const T& e)
{ return searchIn(_root, e, _hot = NULL); }

static BinNodePosi(T)& searchIn(
	BinNodePosi(T)& v,		// 当前树根
	const T& e,				// 目标关键码
	BinNodePosi(T)& hot)	// 记忆热点
{
    if(!v || (v->data == e)) return v;	// 返回成功/失败节点
    hot = v;
    return searchIn((e < v->data) ? v->lChild : v->rChild, e, hot);
}
```

#### 插入

```c++
template <typname T> BinNodePosi(T)& BST<T>::insert(const T& e)
{
    BinNodePosi(T)& x = search(e);
    if(!x) {
        x = new BinNode<T>(e, _hot);	// 以e为关键码，以_hot为父
        _size++;
        updateHeightAbove(x);
    }
    return x;
}
```

#### 删除

```c++
template <typname T> bool BST<T>::remove(const T& e) {
    BinNodePosi(T) x = search(e);
    if(!x) return false;
    removeAt(x, _hot);
    _size--;
    updateHeightAbove(_hot);
    return true;
}

template <typename T> static BinNodePosi(T)
removeAt(BinNodePosi(T)& x, BinNodePosi(T)& hot)
{
    BinNodePosi(T) w = x;				// 实际被摘除的节点
    BinNodePosi(T) succ = NULL;			// 实际被删除节点的接替者
    if(!hasLChild(*x)) succ = x = x->rChild;		// 如果单子节点
    else if(!hasRChild(*x)) succ = x = x->lChild;
    else {											// 双子节点
        w = w->succ(); swap(x->data, w->data);		// 寻找直接后继
        BinNodePosi(T) u = w->parent;
        (u == x ? u->rChild : u->lChild) = succ = w->rChild;
    }
    hot = w->parent;
    if(succ) succ->parent = hot;
    release(w->data); release(w);
    return succ;
}
```

### AVL树

​		|平衡因子| < 1

```c++
#define Balanced(x) (stature((x).lChild) == stature((x).rChild))
#define BalFac(x) (stature((x).lChild) - stature((x).rChild))
#define AvlBalanced(x) 
((-2 < BalFac(x)) && (BalFac(x) < 2))
template <typename T> class AVL : public BST<T> {
    public:	//BST::search()
    BinNodePosi(T) insert(const T&);
    bool remove(const T&);
};
```

- 高度为h的AVL树：节点 n = fib(h + 3) - 1
- remove操作最多导致父节点失衡
- insert操作最多导致logn个祖先节点失衡
- insert: O(1), remove: O(n)

#### 重平衡

 		**既然g(x)是因为x的引入而失衡，则p和v的高度均不会低于其各自的兄弟，可由g(x)找到p和v**

```c++
// 在左、右孩子中取更高者，若登高，则与父亲p同侧者优先
#define tallerChild(x) (
	stature((x).lChild) > stature((x).rChild) ? (x)->lChild : (
	stature((x).lChild) < stature((x).rChild) ? (x)->rChild : (
	IsLChild((*x)) ? (x)->lChild : (x)->rChild
    )
    )
)
```

#### 插入

- 调整插入节点x，x的父亲，离x最近的失衡祖先三个节点

- 三代节点同一方向，单旋后子树复衡，全树也复衡
- 三代节点之字形，双旋

```c++
template <typename T> BinNodePosi(T) AVL<T>::insert(const T& e) {
    BinNodePosi(T)& x = search(e); if(x) return x;
    x = new BinNode<T>(e, hot); _size++; BinNodePosi(T) xx = x;
    for(BinNodePosi(T) g = x->parent; g; g = g->parent) {
        if(!AvlBalanced(*g)) {
            FromParentTo(*g) = rotateAt(tallerChild(tallerChild(g)));
            break;
        }
        else
            updateHeight(g);
    }
    return xx;
}
```

#### 删除

- 三代节点同一方向，单旋后复衡，子树高度未必复原，更高祖先仍可能失衡
- 双旋后子树高度收缩1，更高祖先可能失衡
- 失衡传播：自底而上，高层的某一节点由平衡转为失衡，之可能发生在下层失衡节点恢复平衡之后

```c++
template <typename T> bool AVL<T>::remove(const T& e) {
    BinNodePosi(T)& x = search(e); if(!x) return false;
    removeAt(x, _hot); _size--;
    for(BinNodePosi(T) g = _hot; g; g = g->parent) {
        if(!AvlBalanced(*g))
            g = FromParentTo(*g) =
            rotateAt((tallerChild(tallerChild(g)));
        updateHeight(g);
    }
    return true;
}
```

#### 3+4重构

- 按中序遍历，将祖孙三代命名为：a < b < c
- 按中序遍历，将四棵子树命名为：T~0~ < T~1~ < T~2~ < T~3~

![image-20200919105312948.png](https://i.loli.net/2020/09/19/xlLTeQqdIp7tuXj.png)

```c++
template <typename T> BinNodePosi(T) BST<T>::connect34(
	BinNodePosi(T) a, BinNodePosi(T) b, BinNodePosi(T) c,
	BinNodePosi(T) T0, BinNodePosi(T) T1, BinNodePosi(T) T2, 		BinNodePosi(T) T3)
{
    a->lChild = T0; if(T0) T0->parent = a;
    a->rChild = T1; if(T1) T1->parent = a; updateHeight(a);
    c->lChild = T2; if(T2) T2->parent = c;
    c->rChild = T3; if(T3) T3->parent = c; updateHeight(c);
    b->lChild = a; a->parent = b;
    b->rChild = c; c->parent = b; updateHeight(b);
    return b;
}
```

<img src="https://i.loli.net/2020/09/19/XBTRSPwOZzVlWLN.png" alt="image-20200919110058626.png" style="zoom:80%;" />				<img src="https://i.loli.net/2020/09/19/IPsxfOk3hiSZ75R.png" alt="image-20200919110111220.png" style="zoom:80%;" />

```c++
template <typename T> 					// 两种情况
BinNodePosi(T) BST<T>::rotateAt(BinNodePosi(T) v) {
    BinNodePosi(T) p = v->parent, g = p->parent;
    if(IsLChild(*p))
        if(IsRChild(*v)) {
            p->parent = g->parent;		// 向上联接
            return connect34(v, p, g, 
            		v->lChild, v->rChild, p->rChild, g->rChild);
        } else {
            v->parent = g->parent;		// 向上联接 	
            return connect34(p, v, g,
            		p->lChild, v->lChild, v->rChild, g->rChild);
        }
    else if(IsRChild(*p))
            if(IsRChild(*v)) {
                p->parent = g->parent;
                return connect34(g, p, v,
                	g->lChild, p->lChild, v->lChild, v->rChild);
            } else {
                v->parent = g->parent;
                return connect34(g, v, p,
               		g->lChild, v->lChild, v->rChild, p->rChild);
            }
} 
```

### 概念

1. 顺序性：任一节点均不小于/大于其左/右后代

2. 单调性：BST的中序遍历，必然单调非降

3. 高度渐进地不超过O(logn)，即可称作适度平衡

4. 适度平衡地二叉树，称作平衡二叉搜索树(BBST)

5. 等价BST

   承袭关系可能颠倒，中序遍历完全一致