---
title: 第四章 栈与队列
date: 2020-09-10 08:56:15
tags: 栈
categories: 数据结构
---

## 第四章 栈与队列

### 栈应用

1. 逆序输出（进制转换）

<!--more-->

```c++
void convert(Stack<char>& S, int n, int base) 
{
    static char digit[] = 
    {'0', '1', '2', '3', '4','5', '6', '7', '8', '9',
     'A', 'B', 'C', 'D', 'E', 'F'};
    while(n > 0) {
        S.push([n % base]);
    	n /= base;
    }
}
```

2. 递归嵌套（括号匹配）（栈混洗）

   - 括号匹配：

   ```c++
   bool paren(const char exp[], int lo, int hi)
   {
       Stack<char> S;
       for(int i = lo; i < hi; i++) {
           if('(' == exp[i]) 
               S.push(exp[i]);
           else if(!S.empty())
               S.pop();
           else
               return false;		// 遇右括号时栈已空
       }
       return S.empty();			// 左括号缺少右括号匹配
   }
   ```

   - 栈混洗

   ![image-20200909111850275.png](https://i.loli.net/2020/09/09/AUgMQrjKin15xIY.png)

$$
Catalan = \frac{(2n)!}{(n)!(n+1)!}
$$

​		甄别：O(n^3^)：对于i , j, k，出现k, i, j的情况必不为栈混洗

​				    O(n^2^)：对于i, j, j+1, 出现 j+1, i, j的情况必不为栈混洗

​					O(n)：再来一次栈混洗，看能不能实现序列B中的效果
   ```c++
template<class T>
bool stackWashing(stack<T> a, stack<T> b) {	
	stack<T> rb, s;
	while (b.size()) {
		rb.push(b.top());
		b.pop();
	}
	while (a.size()) {
		s.push(a.top());
		a.pop();
		while (s.size() && s.top() == rb.top()) {
                //将s中累计的元素清算
			s.pop();
			rb.pop();
		}
	}
	return s.empty();//若s为空则代表栈清洗成功
}
   ```


3. 延迟缓冲（中缀表达式求值）

   ![image-20200909140612606.png](https://i.loli.net/2020/09/09/4CGt3Tb9wMSYEus.png)

   ```c++
   float evaluate(char* S, char*& RPN)
   {
   	Stack<char> opnd, optr;
   	optr.push('\0');
   	while (!optr.empty()) {
   		if (isdigit(*S)) {
   			readNumber(S, opnd);
   			append(RPN, opnd.top());
   		}
   		else
   			switch (orderBetween(optr.top(), *S)) {
   			case '<':
   				optr.push(S);
   				S++;
   				break;
   			case '=':
   				optr.pop();
                   S++;
   				break;
   			case '>':
   				char op = optr.pop(); append(RPN, op);
   				if ('!' == op) {
   					float pOpnd = opnd.pop();
   					opnd.push(calcu(op, pOpnd));
   				}
   				else {
   					float pOpnd2 = opnd.pop(); pOpnd1 = opnd.pop();
   					opnd.push(calcu(pOpnd1, op, pOpnd2));
   				}
   				break;
   			default:
   				exit(-1);
   			}
   	}
   	return opnd.pop();
   }
   ```

   

4. 栈式计算（逆波兰表达式(Reverse Polish Notation)）

   ​		在由运算符和操作数组成的表达式中不使用括号，即可表示带优先级的运算关系

   ![image-20200909142359936.png](https://i.loli.net/2020/09/19/Uatq62Pf3kOrmZo.png)

### 试探回溯法

#### N皇后问题

```c++
struct Queen {
    int x, y;
    Queen(int xx = 0, int yy = 0) : x(xx), y(yy) { }
    bool operator==(Queen const& q) const 
    {
        return (x == q.x)
            || (y == q.y)
            || (x + y == q.x + q.y)
            || (x - y == q.x - q.y)
    }
    bool operator !=(Queen const& q)
    {
        return !(*this == q);
    }
};
```

```c++
void placeQueen(int N) {	// N皇后算法（迭代版）：反复试探回溯
    stack<Queen> solu; //存放（部分）解的栈
    Queen q(0, 0); //从原点位置出发
    do { //反复试探、回溯
        if(N <= solu.size() || q.y >= N) { //若已出界，则
            q = solu.pop();	q.y++;	// 回溯一行并继续试探下一列
        }
        else {
             //通过与已有皇后的比对
            while((q.y < N) && (0 <= solu.find(q))) {
                q.y++; nCheck++; //尝试找到可摆放下一皇后的列
            }
            if(q.y < N) {
                solu.push(q); //摆上当前皇后，并
                if(N <= solu.size()) nSolu++;// 全局变量nSolu
                q.x++; q.y = 0;
            }
        }
    } while((0 < q.x) || (q.y < N));
}
```

#### 迷宫寻径

```c++
// 迷宫单元状态
typedef enum {AVALIABLE, ROUTE, BACKTRACKED, WALL} Status;
// 单元的相对邻接方向
typedef enum {UNKNOWN, EAST, SOUTH, WEST, NORTH, NO_WAY} ESWN;
// 依次转至下一邻接方向
inline ESWN nextESWN(ESWN eswn) { return ESWN(eswn + 1); }

struct Cell {					// 迷宫格点
    int x, y; 					// x, y坐标 
    Status status;				// 格点类型
    ESWN incoming, outgoing;	// 进入、走出方向
};

#define LABY_MAX 24 			// 最大迷宫尺寸
Cell laby[LABY_MAX][LABY_MAX];
```

```c++
// 邻格查询
inline Cell* neighbor(Cell* cell) {
    switch(cell->outgoing) {
        case EAST : return cell + LABY_MAX;	// 向东
        case SOUTH: return cell + 1;		// 向南
        case WEST : return cell - LABY_MAX; // 向西
        case NORTH: return cell - 1;		// 向北
    	default   : exit(-1);
    }
}
```

```c++
inline Cell* advance(Cell* cell) {
    Cell* next;
    switch(cell->outgoing) {
        case EAST : next = cell + LABY_MAX;	// 向东
            next->incoming = WEST; break;
        case SOUTH: next = cell + 1;		// 向南
            next->incoming = NORTH; break;
        case WEST : next = cell - LABY_MAX; // 向西
            next->incoming = EAST; break;
        case NORTH: next = cell - 1;		// 向北
            next->incoming = SOUTH; break;
    }
    return next;
}
```

```c++
bool labyrinth(Cell Laby[LABY_MAX][LABY_MAX],Cell* s,Cell* t) {
    if((AVALIABLE != s->status) || (AVALIABLE != t->status))
        return false;
    stack<Cell*> path;	// 用栈记录通路
    s->incoming = UNKNOWN; s->status = ROUTE; path.push(s);
    do {	// 从起点出发不断试探、回溯，直到抵达终点
        Cell* c = path.top();
        if( c == t) return true;		// 抵达终点
        while(NO_WAY > (c->outgoing = nextESWN(c->outgoing)))
            if(AVAILABLE == nerghbor(c)->status)
                break;				// 试图找到尚未试探的方向
        if(NO_WAY <= c->outgoing) {	// 若所有方向都已尝试过
            c->status = BACKTRACKED;// 向后回溯一步
            c = path.pop();
        }
        else {						// 否则，向前试探一步
            path.push(c = advance(c));
            c->outgoing = UNKNOWN;
            c->status = ROUTE;
        } 
    } while(!path.empty());
    return false;
}
```



