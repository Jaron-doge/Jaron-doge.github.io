---
title: 第八章 高级搜索树
date: 2020-09-22 20:30:15
tags: 树
categories: 数据结构
---

## 高级搜索树

### 伸展树(splay tree)

<!-- more -->

```c++
template <typename T>
class Splay : public BST<T> {
protected:
  	BinNodePosi(T) splay(BinNodePosi(T) v);
public:		// 伸展树的search也会引起整树的结构调整
    BinNodePosi(T)& search(const T& e);
    BinNodePosi(T) insert(const T& e);
    bool remove(const T& e);
};
```

#### 伸展

```c++
template <typename T> BinNodePosi(T)
Splay<T>::splay(BinNodePosi(T) v) {
    if(!v) return NULL; 
    BinNodePosi(T) p; BinNodePosi(T) g;
    while((p = v->parent) && g = p->parent) {
        BinNodePosi(T) gg = g->parent;
        if(IsLChild(*v))
            if(IsLChild(*p)) { 		// zig-zig
            	attachAsLChild(g, p->rc);
                attachAsLChild(p, v->rc);
                attachAsRChild(p, g);
                attachAsRChild(v, p);
            }	
        	else { }				// zag-zig
        else if(IsRChild(*p)) { }	// zag-zag
        else { }					// zig-zag
        if(!gg)					// 若无曾祖父gg,则v现即为树根，
            v->parent = NULL;	// 否则，gg应以v为左或右孩子
        else(g == gg->lc) ? attachAsLChild(gg, v) : attachAsRChild(gg, v);
        updateHeight(g); updateHeight(p); updateHeight(v);
    }	// 双层伸展结束时，必有g == NULL,但p可能非空
    if(p = v->parent) {	// 若p为根，只需单旋一次
		if(IsLChild(*v)) {
            attachAsLChild(p, v->rChild);
            attachAsRChild(v, p);        
        }
        else {
            attachAsRChild(p, v->lChild);
            attachAsLChild(v, p);
        }
        updateHeight(p); updateHeight(v);
    }
    v->parent = NULL; return v;    
}
```

#### 查找

```c++
template <typename T> BinNodePosi(T)&
Splay<T>::search(const T& e) {
    BinNodePosi(T) p = searchIn(_root, e, _hot = NULL);
    _root = splay(p ? p : _hot);		// 成功、失败
    return _root;
}	
```

#### 插入

```c++
template <typename T> BinNodePosi(T)&
Splay<T>::search(const T& e) {
    if(!_root) {
        _size++;
        return _root = new BinNode<T> (e);
    }
    if(e == search(e)->data) return _root;	// 若存在
    _size++; BinNodePosi(T) t = _root;
    if(_root->data < e) {// 插入新根，以t和t->rChild为左、右孩子
        t->parent = _root = new BinNode<T>(e, NULL, t, 
                                           t->rChild);
        if(HasRChild(*t)) {
            t->rChild->parent = _root;
            t->rChild = NULL;
        }   
    } else {			// 插入新根，以t->lChild和t为左、右孩子
            t->parent = _root = new BinNode<T>(e, NULL, 
                                              t->lChild, t);
        	if(HasLChild(*t)) {
                t->lChild->parent = _root;
               	t->lChild = NULL;
            }
        }
	updateHeightAbove(t);	// 更新_root的高度
    return _root;
}	
```

#### 删除

```c++
template <typename T> bool Splay<T>::remove(const T& e)
{
    if(!_root || (e != search(e)->data)) return false;
    BinNodePosi(T) w = _root;	// 经search后节点已伸展至树根
    if(!HasLChild(*_root)) {	// 若无左子树，直接删除
        _root = _root->rChild; if(_root) _root->parent=NULL;
    } else if(!HasRChild(*_root)) {	// 若无右子树，直接删除
        _root = _root->lChild; if(_root) _root->parent=NULL;
    } else {					// 左右子树同时存在
        BinNodePosi(T) lTree = _root->lChild;//暂时切除左子树
        lTree->parent = NULL; _root->lChild = NULL;
        _root = _root->rChild; _root->parent = NULL;
        search(w->data);	  // 再做一次查找，返回大于e的最小值
        _root->lChild = lTree; lTree->parent = _root;//接回
    }
    release(w->data); release(w); _size--;		// 释放节点
    if(_root) updateHeight(_root);
    return true;
}
```

### B-树

- 每d代合并：m = 2^d路， m - 1个关键码

- 充分利用外存对批量访问的高效支持，将此特点转化为优点，每下降一层，都以超级节点为单位，读入一组关键码
- m的大小视磁盘的数据块大小而定KB/4 = 200 ~ 300

- **树高h = 外部节点深度**
- 内部节点的分支数n+1也不能太少
  - 树根：2 <= n+1 <= m
  - 其余： 「m / 2 ⌉ <= n + 1 <= m
- 也称为(「m / 2 ⌉,  m)-树

```c++
tempalte <typename T> struct BTNode {
	BTNodePosi(T) parent;
    vector<T> key;
    vector<BTNodePosi(T)> child;
    BTNode() { parent = NULL; child.insert(0, NULL); }
    BTNode(T e, BTNodePosi(T) lc = NULL, BTNodePosi(T) rc = 													NULL) 
    {
        parent = NULL;
        key.insert(0, e);
        child.insert(0, lc);
        child.insert(1, rc);
        if(lc) lc->parent = this;
        if(rc) rc->parent = this;
    }
}
```

```c++
#define BTNodePosi(T) BTNode<T>*
template <typename T> class BTree {
protected:
    int _size; int _order; BTNodePosi(T) _root;// 总数、阶次
    BTNodePosi(T) _hot;
    void solveOverflow(BTNodePosi(T));//因插入而上溢后的分裂处理
    void solveUnderflow(BTNodePosi(T));//因删除而下溢后的合并
public:
	BTNodePosi(T) search(const T& e);
    bool insert(const T& e);
    bool remove(const T& e);
};
```

#### 查找

```c++
template <typename T> 
BTNodePosi(T) BTree<T>::search(const T& e) {
    BTNodePosi(T) v = _root; _hot = NULL;
    while(v) {
        int r = v->key.search(e);
        if(0 <= r && e == v->key[r]) return v;
        _hot = v; v = v->child[r + 1];
    }
    return NULL;
}
```

#### 插入

```c++
template <typename T>
bool BTree<T>::insert(const T& e) {
    BTNodePosi(T) v = search(e);
    if(v) return false;
    int r = _hot->key.search(e);
    _hot->key.insert(r + 1, e);
    _hot->child.insert(r + 2, NULL);
    _size++; solveOverflow(_hot);	// 如发生上溢，需做分裂
    return true;
}
```

#### 分裂

​		取关键码中位数k~s~，k~s~上升一层，并分裂，以所得的两个节点作为左、右孩子

```c++
tempalte <typename T>
void BTree<T>::solveOverflow(BTNodePosi(T) v) {
	if(_order >= v->child.size()) return;	// 递归基
    int s = _order / 2;
    BTNodePosi(T) u = new BTNode<T>();		// 新节点有个空孩子
    for(int j = 0; j < _order - s - 1; j++) {	// 右侧孩子
        u->child.insert(j, v->child.remove(s + 1));// u的也没
        u->key.insert(j, v->key.remove(s + 1));
    }
    u->child[_order - s - 1] = v->child.remove(s + 1);
    if(u->child[0])							// 若u孩子非空
        for(int j = 0; j < _order - s; j++)	// 将父节点统一
            u->child[j]->parent = u;
    BTNodePosi(T) p = v->parent;
    if(!P) {								// p为空则创建
        _root = p = newBTNode<T>();
        p->child[0] = v;
        v->parent = p;
    }
    int r = 1 + p->key.search(v->key[0]); // p中指向u的指针的秩
    p->key.insert(r, v->key.remove(s));	  // 轴点关键码上升
    p->child.insert(r + 1, u); u->parent = p;	// 互联
    solveOverflow(p);	
}
```



#### 删除

````c++
template <typename T>
bool BTree<T>::insert(const T& e) {
    BTNodePosi(T) v = search(e);
    if(v) return false;
    int r = v->key.search(e);
    if(v->child[0]) {					// 若v非叶子
        BTNodePosi(T) u = v->child[r + 1];	// 在右子树中向左
        while(u->child[0]) u = u->child[0];	// 找到e的后继
        v->key[r] = u->key[0]; v = u; r = 0;// 互换位置
    }	// 至此,v必然位于最底层，且其中第r个关键码就是待删除者			v->key.remove(r); v->child.remove(r + 1); _size--;
    solveUnderflow(v);				// 如有必要，需做旋转或合并
    true;
}
````

#### 旋转

- 左或右兄弟关键码 ≥ ⌈m / 2⌉

#### 合并

- 左或右兄弟关键码 = ⌈m / 2 - 1⌉

![image-20200919194411160.png](https://i.loli.net/2020/09/19/Be4tUCRzwpmSEfM.png)

```c++
template <typename T>
void BTree<T>::solveUnderflow(BTNodePosi(T) v) {
    if((_order + 1) / 2 <= v->child.size()) return;// 递归基
    BTNodePosi(T) p = v->parent;
    if(!p) {							// 递归基：已到根节点
        if(!v->key.size() && v->child[0]) {
            // 倘若v不含关键码，却有非空孩子
            _root = v->child[0];
            _root->panret = NULL;
            v->child[0] = NULL; release(v);			// 删除
        }	// 整树高度降低一层
        return;        
    }
	int r = 0; while(p->child[r] != v) r++;
    // 确定v是p的第r个孩子
    
    // 情况1：向左兄弟借关键码
    if(0 < r) {	// 若v不是p的第一个孩子，则
        BTNodePosi(T) ls = p->child[r - 1];	   // 左兄弟必存在
        if((_order + 1) / 2 < ls->child.size()) {	// 足够胖
            v->key.insert(0, p->key[r - 1]);	// p借给v
            // ls的最大关键码转入p
            p->key[r - 1]=ls->key.remove(ls->key.size()-1);
        	v->child.insert(0, ls->child.remove(
                ls->child.size() - 1));		// ls最右侧孩子给v
        	if(v->child[0])
                v->child[0]->parent = v;
            return;
        }
    }// 至此，左兄弟要么为空，要么太“瘦”
    
    // 情况2：向右兄弟借关键码
	if(p->child.size() - 1 > r) {	// 若v不是p最后一个孩子
        BTNodePosi(T) rs = p->child.size();	// 右兄弟必存在
    	if((_order + 1) / 2 < rs->child.size()) {
            v->key.insert(v->key.size(), p->key[r]);
            p->key[r] = rs->key.remove(0);
            v->child.insert(v->child.size(), 
                            rs->child.remove(0));
            if(v->child[v->child.size() - 1])
                v->child[v->child.size() - 1]->parent = v;
            return;            
        }
    }
    
    // 情况3：左、右兄弟都太“瘦”，需要合并
    if(0 < r) {	// 与左兄弟合并
        BTNodePosi(T) ls = p->child[r - 1];	// 左兄弟必存在
    	ls->key.insert(ls->key.size(), p->key.remove(r-1));
        p->child.remove(r);		// p的第r-1个关键码转入ls
        // v的最左侧孩子过继给ls做最右侧孩子
        ls->child.insert(ls->child.size(), 
                         v->child.remove(0));
        if(ls->child[ls->child.size() - 1])
            ls->child[ls->child.size() - 1]->parent = ls;
        while(!v->key.empty()) {	// v剩余的关键码和孩子入ls
            ls.key.insert(ls->key.size(), v->key.remove(0));
            ls->child.insert(ls->child.size(), 
                             v->child.remove(0));
            if(ls->child[ls->child.size() - 1])
                ls->child[ls->child.size() - 1]->parent=ls;
        }
        release(v);					//释放v
    } else {	// 与右兄弟合并
    	BTNodePosi(T) rs = p->child[r + 1];	//右兄弟必存在
        rs->key.insert(0, p->key.remove(r)); 
        					p->childremove(r);
        rs->child.insert(0, v->child.remove(
            				v->child.size()-1));
        if(rs->child[0]) 
            rs->child[0]->parent = rs;
        while(!v->key.empty()) {
            rs->key.insert(0, v->key.remove(
                				v->key.size() - 1));
            rs->child.insert(0, v->child.remove(
                                v->child.size() - 1));
            if(rs->child[0])
                rs->child[0]->parent = rs;
        }
        release(v);    
    }
    solveUnderflow(p);		// 上升一层
    return;
}
```

### 红黑树

- 支持对历史版本的访问
- 任何一次动态操作引发的结构变化量不超过O(1)
- 红黑树与4阶B数相同

#### 定义规则

- 树根：黑色
- 外部节点：均为黑色
- 其余节点：若为红，则只能有黑孩子
- 外部节点到根：黑节点数目相等

```c++
template <typename T> class RedBlack : public BST<T> {
public:
    // search()继承
    BinNodePosi(T) insert(const T& e);
    bool remove(const T& e);
protected: 
    void solveDoubleRed(BinNodePosi(T) x);
    void solveDoubleBlack(BinNodePosi(T) x);	
    int updateHeight(BinNodePosi(T) x);		// 黑高度
};
template <typename T> 
int RedBlack<T>::updateHeight(BinNodePosi(T) x) {
    x->height = max(stature(x->lc), stature(x->rc));
    if(IsBlack(x)) x->height++; return x->height;
}
```

#### 插入

```c++
template <typename T> BinNodePosi(T) 
RedBlack<T>::insert(const T& e) {
    BinNodePosi(T) & x = search(e);		
    if(x) return x;					// 假设不存在
    x = new BinNode<T>(e, _hot, NULL, NULL, -1); _size++;
    solveDoubleRed(x);
    return x ? x : _hot->parent;
} 
```

#### 双红缺陷

![image-20200920191030377](D:\study\编程\数据结构\notes\images\image-20200920191030377.png)

![image-20200920190926947](https://i.loli.net/2020/09/20/e3DAoCjkhNWHz6L.png)

![image-20200920191511955.png](https://i.loli.net/2020/09/20/i9jeYJQbHSd8GLN.png)

```c++
template <typename T> 
void RedBlack::solveDoubleRed(BinNodePosi(T) x) {
    if(IsRoot(*x))	// 若递归至树根，则将其转黑，整树黑高度增加
    { _root->color = RB_BLACK; +root->height++; return; }
    BinNodePosi(T) p = x->parent; if(IsBlack(p)) return;
    BinNodePosi(T) g = p->parent;	// p为红，g为黑
    BinNodePosi(T) u = uncle(x);	// 以下，视u颜色分别处理
    if(IsBlack(u)) {	// u为黑色
        if(IsLChild(*x) == IsLChild(*p)) 
            p->color = RB_BLACK;
        else 
            x->color = RB_BLACK;
        g->color = RB_RED;
        BinNodePosi(T) gg = g->parent;
        BinNodePosi(T) r= FromParentTo(*g) = rotateAt(x);
        r->parent = g;
    } else {			// u为红色
        p->color = RB_BLACK; p->height++;	// p、u转黑
        u->color = RB_BLACK; u->height++;	// g非根转红
        if(!(IsRoot(*g)) g->color = RB_RED;
           solveDoubleRed(g);
    }
}
```



#### 删除

```c++
template <typename T> BinNodePosi(T) 
RedBlack<T>::remove(const T& e) {
    BinNodePosi(T)& x = search(e);
    if(!x) return false;
    BinNodePosi(T) r = removeAt(x, _hot);
    if(0 >= --_size) return true;
    if(!_hot)	// 如果被删除的是根节点，置黑并更新黑高度
    { _root->color = RB_BLACK; updateHeight(_root); 
     return true; }
    if(BlackHeightUpdated(*(_hot))) // 若祖先黑深度平衡
        return true;
    if(IsRed(r))		// 若r为红，转黑
    { r->color = RB_BLACK; r->height++; return true; }
    soloveDoubleBlack(r); return true;
} 
```

#### 双黑缺陷

![image-20200920193316876](https://i.loli.net/2020/09/20/AewRLstB45P3ji8.png)

![image-20200920193246521](https://i.loli.net/2020/09/20/VPTHR3Ga5ihZrdA.png)

![image-20200920193333324](https://i.loli.net/2020/09/20/f2rgo8t4s1i7hvN.png)

![image-20200920193631842.png](https://i.loli.net/2020/09/20/GUz4cfeS8FiAvNK.png)

![image-20200920193958612.png](https://i.loli.net/2020/09/20/lbriztVP6EqvHRp.png)

```c++
template <typename T> 
void RedBlack<T>::solveDoubleBlack(BinNodePosi(T) r) {
    BinNodePosi(T) p = r ? r->parent : _hot; 
    if(!p) return;			// r的父亲
    BinNodePosi(T) s = (r == p->lChild) ? p->rChild 
        							: p->lChild; // r的兄弟
    if(IsBlack(s)) {		// s为黑
        BinNodePosi(T) t = NULL;
        if(HasLChild(*s) && IsRed(s->lChild)) t=s->lChild;
   else if(HasRChild(*s) && IsRed(s->rChild)) t=s->rChild;
    if(t) {
        RBColor oldColor = p->color;
        // 重平衡，并将新子树的左、右孩子染黑
        BinNodePosi(T) b = FromParentTo(*p) = rotateAt(t);
    	if(HasLChild(*b)) b->lChild->color = RB_BLACK;
        updateHeight(b->lChild);
        if(HasRChild(*b)) b->rChild->color = RB_BLACK;
        updateHeight(b->rChild);
        b->color = oldColor; updateHeight(b);
    } else {	// 黑s无红孩子
        s->color = RB_RED; s->height--;	// s转红
        if(IsRed(p)) {		// BB-2R
            p->color = RB_BLACK;// p转黑，但黑高度不变
        } else {			// BB-2B
            p->height--;		// p保持黑，但黑高度下降
            solveDoubleBlack(p);
        }
    }
    } else {	// 兄弟s为红：BB-3
        s->color = RB_BLACK; p->color = RB_RED;	// s红p黑
        BinNodePosi(T) t = IsLChild(*s) ? s->lChild
            		: s->rChild;		   // 取t与其父s同侧
        _hot = p; FromParentTo(*p) = rotateAt(t); //平衡调整
        solveDoubleBlack(r);			   // 继续修正r处双黑
    }
}
```

### kd-树

```c++
KdTree* buildKdTree(P, d) {
    if(p == {p}) return CreateLeaf(p);	// 递归基
    root = CreateKdNode();				// 创建子树根
    // 确定划分方向及中位点
    root->splitDirection = Even(d) ? VERTICAL: HORIZONTAL;
    root->splitLine = FindMedian(root->splitDirection, P);
    (P1, P2) = Divide(P, root->splitDirection, 
                      root->splitLine);	  // 子集划分
    root->lChild = buildKdTree(P1, d + 1);// 在d+1构造左子树
    root->rChild = buildKdTree(P2, d + 1);// 在d+1构造右子树
    return root;					      // 返回树根
}
```

```c++
kdSearch(v, R) {
    if(lsLeaf(v))				// 直接判断，终止递归
    { if(inside(v, R)) report(v); return; }
    
    if(region(v->lChild) ⊆ R)	// 若左子树完全包含于R内，遍历
        reportSubtree(v->lChild);
    else if(region(v->lChild) ∩ R ≠ Ø)// 与R相交，递归查询
        kdSearch(v->lChild, R);
    
    if(region(v->rChild) ⊆ R)	// 若右子树完全包含于R内，遍历
        reportSubtree(v->rChild);
    else if(region(v->rChild) ∩ R ≠ Ø)// 与R相交，递归查询
        kdSearch(v->rChild, R);
}
```

