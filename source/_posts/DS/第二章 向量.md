---
title: 第二章 向量
date: 2020-09-09 08:56:00
tags: 排序
categories: 数据结构
---

## 第二章 向量

### 比较树

<!--more-->

#### 性质：

- 每一内部节点各对应于一次比对操作
- 内部节点的左、右分支，分别对应于在两种比对结果下的执行方向
- 叶节点对应于算法某次执行的完整过程及输出
- 算法的每一运行过程都对应于从根到某一叶节点的路径

可以这么描述的算法被称作**基于比较式算法 CBA(comparision-based algorithm)**

#### 最小树高

​		叶节点到根节点的距离称作叶结点的深度，最大深度为树的高度，最小树高即为最佳CBA算法

#### 计算

​		二叉树：高度为h，叶节点数目≥2^h^；输出为n，树高大于log~2~N

​		三叉树：输出为n，树高大于log~3~N

### 二路归并算法

```c++
template <typename T>
void Vector<T>::merge(T lo, T mi, T hi) {
    T* A = _elem + lo;
    int lb = mi - lo;	T* B = new T[lb];
    for(int i = 0; i < lb; B[i] = A[i++]);
    int lc = hi - mi; T* C = _elem + mi;
    for(int i = 0, j = 0, k = 0;(j < lb) || (k < lc); ) {
        if(j<lb) && (!(k<lc) || (B[j]<=C[k])) A[i++]=B[j++];
    	if(k<lc) && (!(j<lb) || (C[k]< B[j])) A[i++]=C[k++];
    }
    delete [] B;
}
```

### 归并排序算法

```c++
template <typename T>
void Vector<T>::mergeSort(int lo, int hi) {
    if(hi - lo < 2) return;
    int mi = (lo + hi) >> 1;
    mergeSort(lo, mi); mergeSort(mi, hi);
    merge(lo, mi, hi);
}
```

### 概念

1. 稳定算法(stable algorithm)：重复元素之间的相对次序在排序前后保持一致，起泡排序属于稳定算法

2. 线性（时间）归约(linear-time reduction)

   - 问题A的任一输入都可在线性时间内转换为B的输入
   - 问题B的任一输出都可在线性时间内转换为A的输出

   |B| ≥ |A| = Ω( f(n) ) 

   例：

   ​	问题A：对于任意n个实数，判定其中是否有重复者

   ​	问题B：无序向量唯一化

   解：在线性时间内

   ​	A输入：n个实数—>B输入：无序向量—>B输出：去重向量—>A输出：规模仍为n

3. 马鞍查找

   整数矩阵的任何一行(列)都严格递增，找出并报告所有值为x的元素

   减而治之：

```c++
saddleback search(int A[n][n], int x) {
    int i = 0;
    int j = binSearch(A[0][], x);		// O(logn)
    while((i < n) && (-1 < j)) {		// O(s + r)
        if(A[i][j] < x) i++;
        else if(x < A[i][j]) j--;
        else { report(A[i][j]); i++; j--;}
    }
}
```









