---
title: 第十章 优先级队列
date: 2020-09-27 20:30:15
tags: 排序
categories: 数据结构
---

## 第十章 优先级队列

### 优先级队列

<!-- more -->

```c++
template <typename T> struct PQ {
    virtual void insert(T) = 0;	// 按照优先级插入词条
    virtual T getMax() = 0;		// 取出优先级最高的词条
    virtual T delMax() = 0;		// 删除优先级最高的词条
};
```

### 完全二叉堆

```c++
#define Parent(i) ((i - 1) >> 1)
#define LChild(i) (1 + ((i) << 1))	// 奇数
#define RChild(i) ((1 + (i)) << 1)	// 偶数
```

```c++
template <typename T> class PQ_ComplHeap:public PQ<T>{
protected: 
    int percolateDown(int n, int i);	// 下滤
    int percolate00Up(int i);				// 上滤
    void heapify(int n);				//Floyd建堆算法
public:				
    PQ ComplHeap(T* A, int n)			// 批量构造
    { copyFrom(A, 0, n); }				
    void insert(T);						// 插入
    T getMax() { return _elem[0]; }		// 读取
    T delMax();  						// 删除
};
```

#### 插入和上滤

```c++
template <typename T> void PQ_ComplHeap<T>::insert(T e)
{ vector<T>::insert(e); percolateUp(_size - 1); }
```

```c++
template <typename T>
int PQ_ComplHeap<T>::percolateUp(int i)
{
	while(ParentValid(i)) {						// 未到根
        int j = Parent(i);
        if(less<int>(_elem[i], _elem[j])) break;// 不再逆序
        swap(_elem[i], _elem[j]); i = j;		// 交换父子位置
    }
    return i;									// 返回最终位置
}
```

#### 删除和下滤

```c++
template <typename T>
T PQ_ComplHeap<T>::delMax()
{
    T maxElem = _elem[0]; _elem[0] = _elem[--size];
    percolateDown(_size, 0);
    return maxElem;
}
```

```c++
template <typename T>
int PQ_ComplHeap<T>::percloateDown(int n, int i)// 下滤
{
	int j;
    while(i != (j = ProperParent(_elem, n, i)))	// 只要i非j
    { swap(_elem[i], _elem[j]); i = j;}			// 换位
    return i;
}
```

### 批量建堆

#### 自下而上的下滤

渐进意义下的O(n)

```c++
PQ_CompHealp(T* A, int n) 
{ copyFrom(A, 0, n); heapify(n); }
```

```c++
template <typename T>
void PQ_ComplHeap<T>::heapify(int n) {
    for(int i = n / 2 - 1; i >= 0; i--)	// 自下而上，依次
        percolateDown(n, i);			// 下滤各内部节点
}
```

### 堆排序

![image-20200927151243390.png](https://i.loli.net/2020/09/27/Xh1W3cOMVzD2u8L.png)

```c++
template <typename T>
void vector<T>::heapSort(int io, int hi) {
    PQ_ComplHeap<T> H(_elem + lo, hi - lo);	//待排序区间
	while(!H.empty())
        _elem[--hi] = H.delMax();
}
```

### 左式堆

- 高效合并
- 每个节点的npl值均等于其右侧通路的长度
- npl(r) = d，该堆包含一棵高度为d的满二叉树

```c++
template <typename T>	// 基于二叉树，以左式堆形式实现
class PQ_LeftHeap : public PQ<T>, public BinTree<T> {
public:
	void insert(T);
    T getMax() { return _root->data; }
    T delMax();
};
```

#### 合并

围绕右侧链进行，时间复杂度O(logn)

![image-20200927155959786.png](https://i.loli.net/2020/09/27/E4pz1wa2x5RMrqh.png)

```c++
template <typename T>static BinNodePosi(T) merge(BinNodePosi(T) a, BinNodePosi(T) b) 
{
    if(!a) return b;	// 递归基
    if(!b) return a;	// 递归基
    if(lt(a->data, b->data)) swap(a, b);	// 确保a>=b
    a->rc = merge(a->rc, b);	// 将a的右子堆，与b合并
    a->rc->parent = a;			// 更新父子关系
    if(!a->lc || a->lc->npl < a->rc->npl)
        swap(a->lc, a->rc);		// 交换a的左、右子堆
    a->npl = a->rc ? a->rc->npl + 1 : 1; // 更新a的npl
    return a;					// 返回合并后的堆顶
}
```

#### 插入与删除

```c++
template <typename T>
void PQ_LeftHeap<T>::insert(T e) {
    BinNodePosi(T) v = new BinNode<T>(e);
    _root = merge(_root, v);
    _root->parent = NULL;
    _size++;
}
```

```c++
template <typename T> T PQ_LeftHeap<T>::delMax()
{
    BinNodePosi(T) lHeap = _root->lc;
    BinNodePosi(T) rHeap = _root->rc;
    T e = _root->data;
    delete _root; _size--;
    _root = merge(lHeap, rHeap);
    if(_root) _root->parent = NULL;
    return e;
}
```

### 概念

1.  单侧倾斜

   - 节点分布偏向于左侧
   - 合并操作偏向于右侧

2.  空节点路径长度(npl)

   - npl(x) = x到外部节点的最近距离

   - npl(x) = 以x为根的最大满子树的高度

3. 左倾

   ​	npl( lc(x) ) >= npl( rc(x) )

