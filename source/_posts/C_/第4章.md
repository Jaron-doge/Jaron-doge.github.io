---
title: 第4章 C#语言高级特性
date: 2021-4-4 24:00:00
tags: 
categories: C#&nbsp;
---
## C#语言高级特性

 ### 4.1 委托(delegate)

#### 声明

<!-- more -->

```c#
public delegate double MyDelegate(double x);
```

#### 实例化

```c#
MyDeletated d2 = new MyDelegate(obj.myMethod);
```

#### 调用

委托变量名（参数列表）

#### 委托的合并/多播(Multicasting)

- 一个委托实例中可以“包含”多个函数
- 调用委托，就是调用其中多个函数

**运算符 +、 -、 +=、 -=**

```c#
delegate int NumberChanger(int n);
namespace DelegateAppl
{
   class TestDelegate
   {
      static int num = 10;
      public static int AddNum(int p)
      {
         num += p;
         return num;
      }

      public static int MultNum(int q)
      {
         num *= q;
         return num;
      }
      public static int getNum()
      {
         return num;
      }

      static void Main(string[] args)
      {
         // 创建委托实例
         NumberChanger nc;
         NumberChanger nc1 = new NumberChanger(AddNum);
         NumberChanger nc2 = new NumberChanger(MultNum);
         nc = nc1;
         nc += nc2;
         // 调用多播
         nc(5);
         Console.WriteLine("Value of Num: {0}", getNum());
         Console.ReadKey();
      }
   }
}
```

#### 委托的转换与相等

- 委托的转换
  - 按声明的名称判断
- 委托的相等
  - 按内容（即“包含的函数”）来判断
  - 有点像两个字符串的“equals”判断

### 4.2 事件

#### 按钮点击事件基本的写法

```c#
this.button1.Click += new System.EventHandler(this.button1_Click);

private void button1_Click(object sender, EventArgs e)
{
    this.label1.Text = DateTime.Now.ToString();
}
```

#### 声明

```c#
public event 委托名 事件名;
```

#### 事件的注册与移除

- 事件名+= 或 -=
- 在事件所在类外面，只能用以上两个运算符

#### 事件的发生（激发）

- 事件名（参数列表）
- 相当于回调所注册的函数

#### 定义及使用事件的6步曲

![1.png](https://i.loli.net/2021/04/20/nuyQB62FlgackiO.png)

#### 事件与委托的关系

- 事件一定有相关的委托类型
- 与委托实例一样，事件也“包含”多个函数
- 事件的运算受更多限制（在类外只能用+=或-=）

#### 特性

- 事件是一种消息机制
- 事件源调用事件，别的类注册时间
- 事件的类型是一个委托

### 4.3 Lambda表达式

#### 4.3.1 泛型

```c#
T add<T> (T a, T b){}
```

#### 4.3.2 匿名方法

不写名字，直接写方法体的函数

```c#
delegate(参数){方法体}

new Thread(delegate(){});
```

可以省略参数

```c#
new Thread(delegate{Console.Write("my function";)});
```

#### 4.3.3 Lambda表达式

- **相当于匿名方法的简写**
  - 省略delegate，甚至**省略参数类型**，会**自动推算参数类型**
  - 直接用（参数）=>{语句或表达式}

```c#
new Thread(()=>{Console.Write("my function");})
```

#### 4.3.4 Linq

Language Integrated Query 集成查询语言

### 4.4 运算符重载

#### 4.4.1 一元运算符

```c#
public static 类型 operator 一元运算符(类型 参数名){}
```

#### 4.4.2 类型转换运算符

```c#
public static implicit operator 类型(类型 参数名){}(隐式)
public static explicit operator 类型(类型 参数名){}(强制)
```

### 4.5 异常处理

子类异常写前面、更一般的异常写后面

- catch{}表示捕获所有类型的异常

```c#
try{...}
catch(Exception e){...}
finally{...}
```

**抛出异常**

```c#
if(xxx) throw new SomeException;
```

#### 4.5.1 内部异常

```c#
using System;
using System.IO;
public class Program
{
    public static void Main( )
    {
        try
        {
            try
            {
                var num = int.Parse("abc");                
            }
            catch ( Exception inner )
            {
                try
                {
                    var openLog = File.Open("DoesNotExist", FileMode.Open);
                }
                catch
                {
                    throw new FileNotFoundException("OutterException", inner);
                }                              
            }
        }
        catch ( Exception e)
        {
            string inMes, outMes;
            if (e.InnerException != null)
                inMes = e.InnerException.Message;
            outMes = e.Message;
        }        
    }
}
```

在上面的例子中，将abc转换为int会抛出FormatException异常；打开了一个不存在的文件，会抛出FileNotFoundException异常，**由于我将捕获到的异常作为了FileNotFoundException的内部异常， 我在外部就可以通过内部异常（InnerException）来知道第一个FormatException异常**。
此外，如果一个异常的内部异常为空，通常意味着它是造成当前异常状态的根源。

### 4.6 Atrribute

Attribute是与类、结构、方法等元素相关的额外信息，是对元信息的扩展

#### 4.6.1 自定义Attribute

- 从System.Attribute继承而来
- 名字要用xxxAttribute

```C#
[AttributeUsage(AttributeTargets.Class | 
               AttributeTargets.Method, 
               AllowMultiple = true)]
public class HelpAttribute : System.Attribute
{
    public readonly string Url;		// 位置参数
    private string topic;			// 命名参数
    public string Topic{get; set;}
   	public HelpAttribute(string url)
    {
        this.Url = Url;
    }
}
```

### 4.7 C#语言中的其他成分

#### 4.7.1 编译预处理

**标识符声明**

- #define定义一个标识符

- #undef“取消定义”一个标识符

**条件处理**

- #if、#elif、#else、#endif

**信息报告**

- #error、#warning

**行号标记**

- #line行号

#### 4.7.2 unsafe及指针

1. 用指针需要加上unsafe

2. fixed及指针

   fixed(类型* 指针名 = 表达式) 语句

3. sizeof运算符

   sizeof(简单或结构类型名)

4. stackalloc

   在栈上分配的内存，而不是在堆上，因此不会担心内存被垃圾回收器自动回收。

### 4.8 程序的组织

#### 4.8.1 名字空间

#### 4.8.2 嵌套类型

```c#
class A{public class B}
```

#### 4.8.3 程序集

### 4.9 语法总结

#### 4.9.1 类的成员

**常数**

**域**

- 它是类中的变量

**方法**

- 它实现了可以被类实现的计算和行为

**属性**

- 它定义了命名的属性和与对这个属性进行读写的相关行为

**事件**

- 它定义了由类产生的通知

**索引**

- 它允许类的实例通过与数组相同的方法来索引