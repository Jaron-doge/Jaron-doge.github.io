---
title: 第11章 多线程与异步编程
date: 2021-4-11 24:00:00
tags: 
categories: C#&nbsp;
---
## 多线程与异步编程

### 11.1 线程及其控制

#### 11.1.1 多线程

<!-- more -->

- 线程中的指令：一个方法(委托)
- 线程中的数据：相关的对象

#### 11.1.2 线程属性

![5.png](https://i.loli.net/2021/04/20/h57PtgQducvUMH4.png)

#### 11.1.3 线程方法

![6.png](https://i.loli.net/2021/04/20/cGdofq5iAUtCTPw.png)

#### 11.1.4 线程的创建

```c#
public Thread(ThreadStart fun);
```

#### 11.1.5 线程的状态

![7.png](https://i.loli.net/2021/04/20/wi3p9CRITNtmaOr.png)

#### 11.1.6 线程的同步

```c#
thread.join();
```

#### 11.1.7 线程池

#### 11.1.8 System.Threading.Timer类

#### 11.1.9 集合的线程安全性

```c#
ArrayList mySyncdAL = ArrayList.Synchronized(myAL);
```

#### 11.1.10 Windows界面与线程

- 界面的主线程
- 对界面的更新只能使用主线程

- 其他线程则可以这样

  ```c#
  if(this.InvokeRequired){
  	this.BeginInvoke( new AddMsg(this.AddMsgFun),new object[]{ msg} ); 		//显示到界面上
  }else{
  	this.AddMsgFun(msg);
  }
  ```

### 11.2 并行编程

多CPU协作执行任务

#### 11.2.1 并行任务库

**Task类**

- Task\<double> task = Task.Run( ()=>SomeFun() );
  doubleresult = task.Result; 			//等待直到获得结果
- 可以使用Task.WaitAll( task数组)
- 可以使用task.ContinueWith( 另一个task)

**Parallel类**

- Parallel.Invoke( Action[] actions); 并行执行多个任务，直到完成
- Parallel.For( 0, 100, i=>{…} )
- Parallel.ForEach( list, item =>{…} )

```c#
Parallel.For(0, 10, i =>
{
	Console.WriteLine("i={0}, fac={1}, 线程id={2}",
		i, Calc(i),
		Thread.CurrentThread.ManagedThreadId);
    Thread.Sleep(10);
});
Console.ReadLine();
```

**并行Linq**

- 只要在集合上加个.AsParallel()

```c#
var a = (from n in persons.AsParallel()
			where n.Age> 20 && n.Age< 25
			select n)
		.ToList();
```

### 11.3 异步编程

等待一些耗时的任务(特别是文件、网络操作)而**不阻塞**当前任务

#### 11.3.1 传统的方法

**BeginInvoke及EndInvoke**

当使用BeginInvoke异步调用方法时，如果方法未执行完，EndInvoke方法就会一直阻塞，直到被调用的方法执行完毕

```c#
PrintDelegate printDelegate = Print;

IAsyncResult result = printDelegate.BeginInvoke("Hello World.", null, null);

Console.WriteLine("主线程继续执行...");

int n = printDelegate.EndInvoke(result);
```

**使用回调**

```c#
Console.WriteLine("主线程.");

PrintDelegate printDelegate= Print;

printDelegate.BeginInvoke("Hello world.", PrintComeplete, printDelegate);

Console.WriteLine(“主线程继续执行...”);
```

```c#
// 回调方法要求：1.返回类型为void 2.只有一个参数IAsyncResult
public static void PrintComeplete(IAsyncResultresult)
{
	(result.AsyncState as PrintDelegate).EndInvoke(result);
	Console.WriteLine("当前线程结束." + result.AsyncState.ToString());
}
```

#### 11.3.2 await及async

- await表示等待任务的执行

- async修饰一个方法，表示其中有await语句

**异步任务与主程序任务一起写**

```c#
async void Test() {
	double result = await FacAsync(10);	// 调用异步方法
	Console.WriteLine( result); 	//异步方法执行完后才执行此句
}

Task<double> FacAsync(int n) { 		//用Task表示要执行任务
	return Task<double>.Run( ()=>{
		double s = 1; for(int i = 1; i<n; i++) s = s*i;
        return s;
	});
}
```

##### 在WinForm中

```c#
async Task<string> AccessTheWebAsync(string url)
{
	HttpClient client = new HttpClient();
	Task<string> task = client.GetStringAsync(url); //异步
	DoIndependentWork(); //做其他事
	string urlContents = awaittask; //等待异步执行完毕
	return urlContents;
}
```

await后面的语句，就不用写成Invoke(委托)了

```c#
async private void button1_Click(object sender, EventArgse)
{
	string content = await AccessTheWebAsync(url);
	this.textBox2.Text = content; //编译器让这句在界面线程上执行
}
```

#### 11.3.3 异步的流

await myStream.WriteAsync(...)

```c#
Task task= myStream.WriteAsync(); 	//异步
DoIndependentWork(); 				//做其他事
await task; 						//等待异步执行完毕
```

