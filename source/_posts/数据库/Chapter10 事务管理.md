---
title: 第十章 事务管理
date: 2021-6-9 00:00:00
tags: 
categories: 数据库
---

## 第十章 事务管理

数据库四大特性：一致、可靠、完整、安全

<!-- more -->

### 10.1 事务支持

**|事务|**：由单个用户或者应用程序执行时，完成读取或者更新数据库内容的一个或者一串操作。

- 事务是数据库的逻辑操作单位。
- 从数据库的角度看，应用程序的一次执行就是一个事务或者多个事务，在事务与事物之间只会出现非数据库操作(salary = salary * 1.1)。
- 事务应该总能将数据库从一种一致的状态转换到另一种一致的状态。

已提交的事务不能被撤销，只能执行另一个补偿事务来消除影响。

![1.png](https://i.loli.net/2021/06/05/jTWxQh3yamHDbUt.png)

部分提交：最后一条语句执行后，处于部分提交状态。

#### 10.1.1 事务的性质

事务应该具有四个基本性质(**ACID**)

- 原子性：事务是一个不可分割的单元，要么全部执行，要么都不执行。
- 一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。
- 隔离性：事物的执行是相互独立的。未完成事务的中间结果对其他事务来说应该是不可见的。
- 持久性：成功提交的事务结果要永远地记录在数据库中，不能因为以后的故障而丢失。

#### 10.1.2 数据库体系结构

![2.png](https://i.loli.net/2021/06/05/qlWPD1w8TgeGxzb.png)

### 10.2 并发控制

**|并发控制|**：管理数据库上的并发操作以使之互不冲突的过程。

#### 10.2.1 并发控制的必要性

- 阻止两个或更多用户同时访问数据库，并且至少有一个执行更新操作时的相互干扰。
- 虽然两个事务各自执行时是完全正确的，但操作的重叠可能产生不正确的结果。
- 三种可能导致的问题：
  - 丢失更新问题
  - 未提交依赖（脏读）问题
  - 不一致分析（不可重复读）问题

**丢失更新问题**

一个用户的更新操作已经完成，但是结果却被另一个用户的操作结果取代了。

**未提交依赖问题**

如果允许一个事务看到另外一个未提交事务的中间结果，则会出现未提交依赖问题。

**不一致分析问题**

当某事物正从数据库中读取多个数据的值，但另一个事务却在其读取过程中修改了其中某些数据的值，就会出现不一致分析问题。

---

**脏读**

脏读是指一个事务读取到其他事务没有提交的数据。

**不可重复读**

不可重复读是指一个事务内多次根据同一查询条件查询出来的同一行记录的值不一致。

**幻读**

幻读是指一个事务内多次根据同一条件查询出来的记录行数不一致。

#### 10.2.2 可串行性与可恢复性

**|调度|**：一组并发事务操作的序列，对于其中每个事务来说，该序列保留了该事务的所有操作的先后次序。

**|串行调度|**：每一个事务的操作都按顺序执行且各事务之间的操作没有任何交叉的调度。

**|非串行调度|**：一组并发事务的操作相互交叉执行的调度。

**|可串行化|**：如果一组事务并发执行，当且仅当（非串行）调度能够产生和某些串行执行相同的结果时，调度才是正确的。

- 两个事务读同一个数据项
- 两个事务读写不同数据项
- 两个事务读写同一个数据项（需要调度）

冲突可串行化的检测：wait-for graph

**|可恢复调度|**：如果T<sub>j</sub>读取了由T<sub>i</sub>修改过的数据项，那么事务T<sub>i</sub>的提交操作应该在事务T<sub>j</sub>的提交操作之前。若调度中的每一对事务T<sub>i</sub>和T<sub>j</sub>都能满足上述要求，则改调度称为可恢复调度。

#### 10.2.3 加锁方法

**|加锁|**：用来控制并发访问数据的过程。当一个事务正在访问数据库时，可以用锁拒绝其他事务的访问请求，从而避免产生不正确的结果。

**|共享锁|**：读锁。

**|互斥锁|**：写锁。

**|2PL(Two-phase locking)|**：如果事务中所有的加锁操作都出现在第一个解锁操作之前，则该事务是遵循两段锁协议的。

- 事务在对数据项进行操作之前，必须先获得该数据项的锁。根据访问的类型需要，可以是读锁或者写锁。
- 一旦事务开始释放锁，它就不能再获得任何新锁。

**级联回滚**

若T<sub>14</sub>回滚，则T<sub>15</sub>、T<sub>16</sub>均需回滚

![3.png](https://i.loli.net/2021/06/05/P5ZI9vcCRfTGqbU.png)

严格2PL(rigorous 2PL)：直到事物的最后才释放所有的锁。

弱严格2PL(strict 2PL): 只要求互斥锁到事务的最后再释放。

#### 10.2.4 死锁

**|死锁|**：当两个（或多个）事务互相等待对方释放自己已经占有的锁时产生的僵局。

**死锁处理技术**

- 超时

- 死锁预防

- 死锁检测和恢复

  - wait-for graph

    如果事务T<sub>i</sub>等待T<sub>j</sub>的锁，则创建一条有向边T<sub>i</sub>→T<sub>j</sub>

  - 周期性检测

#### 10.2.5 时间戳方法

**|时间戳|**：由DBMS创建的、标识事务的相对启动时间的、具有唯一性的标识符。

**|时间戳技术|**：一种并发控制协议，它用以下方式确定事务的顺序——越早的事务，时间戳越小，在发生冲突时优先级更高。

- 采用时间戳技术时，如果某事务要读或写一个数据项，则只有当该数据项最近的修改是由一个较早的事务执行时，才允许该事务进行读或写。

- 否则，请求读写的事务将被赋予一个新的时间戳后重启。
- 除了事务可以有时间戳，数据项也可以有读写时间戳。

例：

1. 事务T发出写请求write(x)
2. 事务T要求读或写数据项(x)，而该数据项已被一个较新的事务取代，即ts(T)<read_ts(x)。将T回滚并用一个新的时间戳重启。
3. 否则，写操作可以被执行，write_ts(x) = ts(T)

![4.png](https://i.loli.net/2021/06/05/5McwHBs9OVRjGWE.png)

**托马斯写规则**

放宽对冲突可串行化的要求，拒绝过时的写操作以获得更高的并行性。

1. 事务T发出写请求write(x)
2. 该数据项被一个较新的事务读过，即ts(T)<read_ts(x)，则重启T。
3. 该数据项被一个较新的事务写过，即ts(T)<write_ts(x)，则忽略T。

#### 10.2.6 数据项的粒度

**|粒度|**：受到保护的数据项的大小，是并发控制协议中受到保护的基本单位。

粗粒度：整个数据库、一个文件、一页、一条记录、记录的一个字段的值

**粒度的层次**

当一个节点被加锁时，其所有的子孙节点都被锁住。

**意向锁**

当一个节点被加锁时，该节点的所有祖先节点就都被加了意向锁。

意向锁可以是共享的(IS)或互斥的(IX)或共享意向互斥(SIX)。

![5.png](https://i.loli.net/2021/06/05/ITajJk179Fc68bR.png)

### 10.3 数据库恢复

**|数据库恢复|**：在发生故障时，将数据库还原到正确状态的过程。

#### 10.3.1 恢复的必要性

- 主存：易失性存储器，若系统崩溃则数据全失。
- 磁盘：联机非易失存储器。
- 磁带：非联机非易失存储。
- 光盘：非易失性存储器。

**|稳定存储|**：已被复制到许多非易失性的、具有独立故障模式的存储介质（通常指磁盘）上的信息。

#### 10.3.2 事务和恢复

事务是数据库系统进行恢复的基本单位。故障发生时，由恢复管理器负责保证事务ACID特性中的原子性和持久性。

数据库缓冲区位于内存，用于在内存和二级存储器之间传递数据。只有缓冲区中的数据被刷新到二级存储器中，更新操作才能被看作是永久的。缓冲区到二级存储器的显示写被称为强制写(force-writing)。

- 如果写了没提交——**redo**
- 如果提交了没写——**undo**
  - 部分撤销：只有一个事务需要被撤销
  - 全局撤销

**偷窃策略**

允许缓冲区管理器在事务提交前将缓冲区写回磁盘。对应非偷窃策略。

——不用undo
**强制策略**

保证在事务提交时，事务更新的所有页立即被写回磁盘。对应非强制策略。

——不用redo

#### 10.3.3 恢复机制

- 备份机制
- 日志机制
- 检查点机制
- 恢复管理器

**备份机制**

定期备份数据库和日志文件。

**日志文件**

记录对数据库更新的所有操作。

- 事务记录

  标识符、类型(增删改查)、数据项前像、后像、日志管理信息

- 检查点记录

![6.png](https://i.loli.net/2021/06/13/S6ou15RiCZFJlqx.png)

日志需要被两倍或三倍地复制(RAID)。

某些情况下，不可能总是将所有日志信息联机保存。一种处理日志文件脱机存储的方法是，将联机的日志文件分成两个独立的随机访问文件。日志记录被写入第一个文件，直到到达某个阈值，如70%。然后打开第二个文件，关闭第一个文件并写道脱机存储介质上。

**检查点**

**|检查点|**：数据库与事务日志文件之间的同步点，在该点上所有的缓冲区都被强制写到二级存储器。

- 将内存中所有日志记录写到二级存储器。
- 将数据库缓冲区所有被修改过的块写到二级存储器。
- 将一个检查点记录写到日志文件。该记录包含所有在检查点时刻活跃事务的标识符。

#### 10.3.4 恢复技术

- 如果数据库遭到严重损毁——备份

- 如果数据库只是处于不一致状态——日志

  使用日志文件中的前像和后像

三种主要恢复技术：延迟(**deferred**)修改、立即修改、影页

**延迟修改**

直到事务提交以后，修改结果才会被写到数据库。

- 事务启动，向日志写入事务启动记录
- 执行写操作，写入日志，不写入数据库缓冲区
- 提交前，写入事务提交记录，先将该事务所有日志写到磁盘，然后提交
- 根据日志完成对数据库的更新
- 如果事务被从撤销则忽略该事务的日志，不执行写操作

如果发生了故障，根据日志对事务进行撤销或重做：

- redo所有出现了事务开始和事务提交日志记录的事务。
- 对所有出现你了事务开始和事务撤销日志记录的事务，不执行操作。因为这些事务并没有对数据库执行真正的写操作。

**立即修改**

更新一旦发生就被施加到数据库，而无需等到提交时刻。

- 事务启动，向日志写入事务启动记录
- 写入日志
- 写入数据库缓冲区
- 在下一次将缓冲区内容刷新到二级存储器时更新数据库
- 提交，向日志写入事务提交记录

在事务的操作结果被写入数据库之前就先将日志记录写入数据库被称为**先写日志协议**。

如果发生了故障，根据日志对事务进行撤销或重做：

- redo所有事务开始和事务提交记录日志的事务
- undo仅包含事务开始记录日志的事务

**影像页(shadow paging)技术**

在事务的生存期中维持了两张页表：当前页表和影像页表。

事务启动时，两张页表相同，事务执行时，当前页表用于记录数据库的所有更新，影像页表用于恢复。事务完成时，当前页表转变为影像页表。

**Advantage**

- 没有维持日志文件的开销
- 无需redo和undo，恢复速度更快

**Disadvantage**

- 数据分裂

- 周期性地进行无用单元回收（垃圾回收机制），开销大

### 作业

1. Explain what is meant by a transaction.

   由单个用户或者应用程序执行时，完成读取或者更新数据库内容的一个或者一串操作。事务是数据库的逻辑操作单位。事务应该总能将数据库从一种一致的状态转换到另一种一致的状态。事务要么就全执行，要么就应该被撤销。

2. The consistency and reliability aspects of transactions are due to the ‘ACIDity’ properties of transactions. Discuss each of these properties and how they relate to the concurrency control and recovery mechanisms. Give examples to illustrate your answer.

   - 原子性：事务是一个不可分割的单元，要么全部执行，要么都不执行。
   - 一致性：事务必须将数据库从一种一致的状态转换到另一种一致的状态。
   - 隔离性：事物的执行是相互独立的。未完成事务的中间结果对其他事务来说应该是不可见的。
   - 持久性：成功提交的事务结果要永远地记录在数据库中，不能因为以后的故障而丢失。

   一致性和隔离性确保数据库一致，并且不会有事务产生的错误。原子性和持久性确保数据库中的数据在任何时候都是可靠的。原子性和持久性是由恢复子系统负责保证的，隔离性和一致性是由并发控制子系统负责保证的。

   自己举例吧，懒得打表格~~

3. Describe, with examples, the types of problem that can occur in a multi-user environment when concurrent access to the database is allowed.

   三种类型的问题：丢失更新、未提交依赖、不一致分析，自己举例吧~~

4. Explain the concepts of serial, nonserial, and schedules.

   **|调度|**：一组并发事务操作的序列，对于其中每个事务来说，该序列保留了该事务的所有操作的先后次序。

   **|串行调度|**：每一个事务的操作都按顺序执行且各事务之间的操作没有任何交叉的调度。

   **|非串行调度|**：一组并发事务的操作相互交叉执行的调度。

5. Discuss the types of problem that can occur with locking-based mechanisms for concurrency control and the actions that can be taken by a DBMS to prevent them.

   不能保证事务的可串行性，可能会导致数据不一致。有可能产生级联回滚。有可能会发生死锁和无限等待。

6. What is a timestamp?

   **|时间戳|**：由DBMS创建的、标识事务的相对启动时间的、具有唯一性的标识符。

   **|时间戳技术|**：一种并发控制协议，它用以下方式确定事务的顺序——越早的事务，时间戳越小，在发生冲突时优先级更高。

   - 采用时间戳技术时，如果某事务要读或写一个数据项，则只有当该数据项最近的修改是由一个较早的事务执行时，才允许该事务进行读或写。

   - 否则，请求读写的事务将被赋予一个新的时间戳后重启。

