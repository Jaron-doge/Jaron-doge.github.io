---
title: 第七章 异常处理
date: 2020-01-11 18:31:21
tags: Essential C++
categories: C++
---

## 第七章 异常处理

### 7.1 抛出异常

<!-- more -->

1. 两个成分
   - 异常的鉴定与发出
   - 异常的处理方式

```c++
class iterator_overflow {
public:
	iterator_overflow(int index, int max)
    : _index(index), _max(max) {}
    
    int index() {return _index;}
    int max() {return _max;}
    
    void what_happened(ostream &os = cerr) {
        os << "Internal error : current index "
            << _index << " exceds maximun bound: "
            << _max;
    }

private:
	int _index;
    int _max;
};

// 调用
if(_index > Triangular::max_elems) {
    iterator_overflow ex(_index, Triangular::_max_elems);
    throw ex;
}
```



### 7.2 捕获异常

#### 7.2.1 catch

​	1. catch由3个部分组成，关键字catch、小括号内的一个类型或对象、大括号内的一组语句。

```c++
extern void log_message(const char*);
extern string err_messages[];
extern ostream log_file;

bool some_function()
{
    bool status = true;
    
    catch(int errno) {
        log_message(err_messages[errno]);
        status = false;
    }
    catch(const char* str) {
        log_message(str);
        status = false;
    }
    catch(iterator_overflow &iof) {
		iof.what_happened(log_file);	
        status = false;
    }
    
    return status;
}
```

2. 异常对象的类型会被拿来逐一地和每个catch子句比对。如果类型符合，那么该catch子句的内容便会被执行。

```c++
throw 42;
throw "panic: no buffer!";
throw iterator_overflow(_index, Triangularr::_max_elems);
```

3. 无法完成异常的完整处理时，或许需要重新抛出异常

```c++
catch(iterator_overflow &iof) {
	log_message(iof.what_happened());
    // 重新抛出异常
    throw;
}
```

​		**重新抛出时，只需写下关键字throw即可。**它只能出现于catch子句中。

4. catch-all

   异常声明部分指定省略号

```c++
// 捕获任何类型的异常
catch(…) {
    log_message("exception of unknown type");
}
```



### 7.3 提炼异常

#### 7.3.1 try

​		catch子句放在try块的末尾，表示如果try块内由任何异常发生，便由接下来的catch子句加以处理。

```c++
bool has_elem(Triangular_iterator first, 
             Triangular_iterator last, int elem)
{
    bool status = true;
    
    try
    {
        while (first != last) {
            if(*first == elem)
                return status;
            ++first;
        }
    }
    
    // 只捕获其中类型为iterator_overflow的异常。
    catch(iterator_overflow &iof) 
    {
        log_message(iof.what_happened());
        log_message("check if iterators address same container");
    }
    
    status = false;
    return status;
}
```

1. first的提领操作和递增操作属于has_elem()的实现细节，而iterator_overflow是该实现内容的一个方面。把异常限定在has_elem()内部，因为has_elem()对于这一异常在程序执行过程中的重要性是最清楚的。

2. 其中的表达式 *first 会调用被重载的dereference运算符

```c++
inline int Triangular_iterator::operator*() 
{
	check_integrity();
    return Triangular::_elems[_index];
}

// 继续内调check_integrity();
inline void Triangular_iterator::check_integrity()
{
    if(_index >= Triangular::_max_elems)
        throw iterator_overflow(_index, Triangular::_max_elems);
    // ...
}
```

1. throw表达式并非位于try块内，check_integrity()的剩余内容不会被执行，异常处理机制终结了check_integrity()的执行权。

2. 异常处理会沿着“函数调用链”找合适的catch子句，如果在main()内还是找不到合适的处理程序，就调用标准库提供的terminate()，中断整个程序的执行。

### 7.4 局部资源管理

```c++
extern Mutex m;
void f()
{
    int *p = new int;
    m.acquire();
    
    process(p);
    
    // 释放资源
	m.release();
    delete p;
}
```

​		如果process()内抛出异常，那么process()调用操作之后的两条用以释放资源的语句便不会被执行。

```c++
// 一种效率较低的解决方法
void f()
{
    try {
        // 和先前一样
    }
    catch(...) {
        m.release();
        delete p;
        throw;
    }
}
```

#### 7.4.1 资源管理

  1. resource acquisition in initialization

     在初始化阶段即进行资源请求

     对对象而言，初始化操作、资源的请求发生于constructor内，资源的释放在destructor内完成。

```c++
// 记得加头文件memory
#include <memory>
void f()
{
    auto_ptr<int> p(new int);
    MutexLock m1(m);
    process(p);
    // p和m1的destructor会在此处被悄悄调用……
}
```

1. 在异常处理机制终结某个函数之前，函数中的所有局部对象的destructor都会被调用。

2. auto_ptr是标准库提供的class template，它会自动删除通过new表达式分配的对象。

3. auto_ptr将dereference运算符和arrow运算符予以重载，可以像使用一般指针一样使用auto_ptr对象。

```c++
#include <memory>
auto_ptr<string> aps(new string("vermeer"));
string *ps = new string("vermeer");

if((aps->size() == ps->size()) && (*aps == *ps))
    // ...
```



### 7.5 标准异常

#### 7.5.1 bad_alloc

​		如果new表达式无法从程序的空闲空间分配到足够的内存，它会抛出 bad_alloc 异常对象

```c++
vector<string>*
init_text_vector(ifstream &infile)
{
    vector<string> *ptext = 0;
    try {
        ptext = new vector<string>;
        // 打开file和file vector
    }
    // bad_alloc是个class，不是一个object。
    catch(bad_alloc) {
        cerr << "ouch. heap memory exhausted\n";
        // ……清理并退出
    }
    return ptext;
}   
```

​		也可以抑制不让bad_alloc异常被抛出：

```c++
ptext = new (nothrow) vector<string>;
```

​		如果new操作失败，会返回0。

#### 7.5.2 exception class hierarchy

1.  exception声明有一个what()虚函数，会返回一个const char*，用以表示被抛出异常的文字描述。

2. bad_alloc派生自exception基类，它有自己的what()。

3. 将自己编写的iterator_overflow继承于exception基类之下。

```c++
// 头文件exception
#include <exception>

class iterator_overflow : public exception {
public:
	iterator_overflow(int index, int max)
        : _index(index), _max(max)
    {}
    
    int index() { return _index; }
    int max() { return _max; }
    
    // overrides exception::what()
    const char* what() const;
    
private:
    int _index;
    int _max;
};
```

​		catch子句会捕捉exception的所有派生类。当bad_alloc异常被抛出，它会打印出“bad allocation”信息。当iterator_overflow异常被抛出，它会打印出“Internal error: current index exceeds maximum bound: 64”信息。

```c++
catch(const excption &ex)
{
    cerr << ex.what() << endl;
}
```

​		iterator_overflow的what()，其中运用ostringstream对象对输出信息进行了格式化:

```c+++
#include <sstream>
#include <string>

const char* 
iterator_overflow::
what() const 
{
	ostringstream ex_msg;
	static string msg;
	
	// 将输出信息写到内存内的ostringstream对象之中。
	// 将整数值转为字符串表示……
	
	ex_msg << "Internal error: current index "
    	   << _index << " exceeds maximum bound: "
    	   << _max;
    	   
   	// 萃取出string对象
   	msg = ex_msg.str();
   	
   	// 萃取出const char*表达式
   	return msg.c_str();
}
```

1. ostringstream class 提供“内存内的输出操作”，输出到一个string对象上。可以将多笔不同类型的数据格式化为字符串。str()会将“与ostringstream对象相呼应”的那个string对象返回。

2. 转换函数c_str()会返回一个const char*。



