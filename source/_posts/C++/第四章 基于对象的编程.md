---
title: 第四章 基于对象的编程
date: 2019-12-28 15:41:36
tags: Essential C++
categories: C++
---

## 第四章 基于对象的编程

### 4.1 Class

<!-- more -->

#### 4.1.1 定义

1. 声明 + 主体

```C++
calss Stack {
public:
    // ...public接口
private:
	// ...private的实现部分    
};
```

- public member可以在程序的任何地方被访问
- private member只能在member function 或是 friend 内被访问

2. 起始定义

```C++
class Stack {
piblic:
    // 任何操作函数如果执行成功，就返回true
    // pop和peek会将字符串内容置于elem内
    bool push(const string&);
    bool pop(string& elem);
    bool peek(string& elem);
    bool empty();
    bool full();
    
    //size()定义于class本身中，
    //其他member则仅仅只是声明。
    int size() { return _stack.size();}
    
private:
    vector<string> _stack;
};
```

- 如果在class主体内定义，这个member function 会被自动地视为 inline 函数。

#### 4.1.2 class scope resolution

类作用域解析运算符

```C++
inline bool 
Stack::empty()
{
    return _stack.empty();
}
//告诉编译器empty()是Stack class的一个member
```

- 全局作用域运算符也为::

```c++
char ch; //全局变量
　　void sleep（）
　　{
　　char ch; //局部变量
　　ch(局部变量) = ch(局部变量) *ch(局部变量) ;
　　::ch(全局变量) =::ch(全局变量) *ch(局部变量);
　　}
```



### 4.2 构造函数和析构函数

#### 4.2.1 构造函数

1. constructor的函数名称必须与class名称相同，语法规定，constructor不应指定返回类型，亦不用返回任何值。它可以被重载。

```c++
class Triangular {
public:
    // 一组重载的constructor
    Triangular();	// default constructors
    Triangular(int len);
    Triangular(int len, int beg_pos);
private:
    int _length;	// 元素个数
    int _beg_pos;	// 起始位置
    int _next;		// 下一个迭代目标
};
```

2. class object定义出来后，编译器便自动根据获得的参数，挑选出应被调用的constructor。

```c++
Triangular t;
Triangular t2(10, 3);
Triangular t3 = 8;	//调用constructor而非assignment operator

Triangular t5();	//错误的调用,t5被视为函数
```

3. default constructor

```c++
1.
Triangular::Triangular()
{
    _length = 1;
    _beg_pos = 1;
    _next = 0;
}

2.更常见
class Triangular {
    public:
    //也是default constructor
    Triangular(int len = 1, int bp = 1);
};

Triangular::Triangular(int len, int bp)
{
    // _length和_beg_pos 都必须>=1。
    // 最好不要相信“用户永远是对的”这句话:)
    _length = len > 0 ? len : 1;
    _beg_pos = bp > 0 ? bp : 1;
    _next = _beg_pos - 1;
}

由于提供了默认值，所以default constructor同时支持原本的三个constructor
    Triangular tri1;			// (1, 1)
	Triangular tri2(12);		// (12, 1)
	Triangular tri3(8, 3);		// (8 ,3)
```



#### 4.2.2 Member Initialization List

成员初始化列表

```c++
Triangular::Triangular(const Triangular &rhs)
    : _length (rhs._length),
	  _beg_pos (rhs._beg_pos), _next(rhs._beg_pos - 1)
{ }	//空的


例：
Triangular::Triangular(int len, int bp)
	:_name("Triangular")
{
    _length = len > 0 ? len : 1;
    _beg_pos = bp > 0 ? bp : 1;
    _next = _beg_pos - 1;
}
```



#### 4.2.3 析构函数

1. Destructor与constructor对立，主要用来释放在constructor中或对象生命周期中分配的资源。

2. Destructor的命名: **class名称 + '~'前缀**， 没有返回值和参数。

```c++
class Matrix {
public:
    Matrix(int row, int col)
        :_row(row), _col(col)
    {
        // constructor进行资源的分配。
        // 注意: 此处未检查成功与否。
        _pmat = new double[row * col];
     }
    ~Matrix()
    {
        // destructor进行资源的释放。
        delete [] _pmat;
    }
private:
    int 	_row, _col;
    double* _pmat;
}


Matrix mat(4, 4);
```

编译器会在mat被定义出来后，应用constructor, 初始化\_pmat语句结束之前，又会调用destructor释放\_pmat



#### 4.2.4 Memberwise Initialization

成员逐一初始化

```c++
//此为default memberwise initialization
Matrix mat2 = mat;
```

会复制所有的data member, **包括指针！！**



copy constructor

```c++
Matrix::Matrix(const Matrix &rhs) 
    :_row(rhs._row), _col(rhs,_col) 
{	// 对rhs._pmat所指的数组产生一份完全复本
    int elem_cnt = _row * _col;
    _pmat = new double[elem_cnt];
    
    for (int ix = 0; ix < elem_cnt; ++ix) 
        _pmat[ix] = rhs._pmat[ix];
}
```



### 4.3 mutable 和 const

#### 4.3.1 const

1. class设计者必须在member function 身上标注 const，以此告诉编译器：这个member function 不会更改 class object 的内容：

```c++
int length() const {return _length;}
```

2. 凡是在class主体以外定义者，必须同时在声明与定义中指定const。

```c++
int Triangular::elem(int pos) const
	{return _elems[pos - 1];}
```

![image-20191228093958479.png](https://i.loli.net/2019/12/28/ZyA7oWnCdLfavci.png)



#### 4.3.2 mutable Data Member

1. 在const member function中想要改变data member的值，需要把data member声明为mutable

```c++
class Triangular {
public:
	bool next(int &val) const;
    void next_reset() const { _next=_beg_pos -1;}
private:
    mutable int _next;
    int _beg_pos;
    int _length;
}

//对trian迭代
int sum(const Triangular &trian)
{
    if(!trian.length())
        return 0;
    
    int val, sum = 0;
    trian.next_reset();
    while (trian.next(val))
        sum += val;
    return sum;
}
```

这样next()和next_reset()既可以修改_next的值，又可以被声明为const member function。



### 4.4 this 指针

```c++
//tr1不仅是复制的目标，也是接受结果的对象
Triangular tr1(8), tr2(8, 9);
tr1.copy(tr2);
```

this指针在member function内用来指向其调用者

```c++
Triangular& Triangular::copy(Triangular *this, const Triangular &rhs)
{
    this->_length = rhs._length;
    return *this;
}

copy(&tr1, tr2);
```



### 4.5 静态类成员

1. Static Member Data
   - static data member用来表示唯一的、可共享的member，它可以在同一类的所有对象中被访问。

```C++
class Triangular {
private:
    static vector<int> _elems;
}

1. static data member只有唯一的一份实体，必须在程序代码文件中提供清楚的定义。
    vector<int> Triangular::_elems;
    
```



2. Static Member Function

member function只有在“不访问任何non-static member”的条件下才能被声明为static

```c++
class Triangular {
public:
    static bool is_elem(int);
private:
    static const int _max_elems = 1024;
    int _buffer[_buf_size];
}

//在class主体外部进行member function定义时，无须加上static
bool Triangular::is_elem(int value)
{
    //
}

//static可以在"与任何对象都无瓜葛"的情形之下被调用。
Triangular::is_elem(8);
//而不是tr1.is_elem(8);
```



### 4.6 Iterator Class

#### 4.6.1 运算符函数

```c++
class Triangular_iterator
{
public:
// 为了不要在每次访问元素时都执行-1操作，
// 此处将_index的值设为index-1
    Triangular_iterator(int index) : _index(index - 1){}
    bool oerator==(const Triangular_iterator&) const;
    bool oerator!=(const Triangular_iterator&) const;
    int operator*() const;
    Triangular_iterator& operator++();	// 前置(prefix)版
    Triangular_iterator operator++(int);// 后置(postfix)版
private:
    void check_integrity() const;
    int _index;
};
```



```c++
#include "Triangular_iterator.h"

class Triangular {
public:
    // 以下这么做， 可以让用户不必知晓iterator class的实际名称
    typedef Triangular_iterator iterator;
    Triangular_iterator begin() const 
    {
        return Triangular_iterator(_beg_pos);
    }
    Triangular_iterator end() const
    {
        return Triangular_iterator(_beg_pos + _length);
    }
private:
    int _beg_pos;
    int _length;
};
```



#### 4.6.2 嵌套类型(Nested Type)

```c++
Triangular::iterator it = trian.begin();
```

使用class scope运算符来指引编译器，让它在面对iterator这个字眼时，查看Triangular内部提供的定义。



### 4.7 Friendship

1. friend具备了与class member function相同的访问权限，可以访问class的private member。

```c++
class Triangular{
    friend int operator*(const Triangular_iterator &rhs);
};

class Triangular_iterator {
    friend int operator*(const Triangular_iterator &rhs);
};
```

2. 只要在某个函数的原型前加上friend，就可以将它声明为某个class的friend。

3. 也可令class A与class B建立friend关系

```c++
class Triangular {
    // 以下造成Triangular_iterator的所有member function
    // 都成为Triangular 的friend
    friend class Triangular_iterator;
};
```

4. 可以用public member function来替代友谊的建立



### 4.8 copy assignment operator

```c++
Matrix& Matrix::
operator=(const Matrix &rhs)
{
    if(this != &rhs)
    {
        _row = rhs._row; _col = rhs._col;
        int elem+cnt = _row * _col;
        delete [] _pmat;
        _pmat = new double[elem_cnt];
        for (int ix = 0; ix < elem_cnt; ++ix)
            _pmat[ix] = rhs._pmat[ix];
    }
    return *this;
}
```



### 4.9 function object

function object是一种"提供有function call运算符"的class

```c++
lt(ival) == lt.operator(ival);	// 内部转换结果

class LessThan
{
public:
    LessThan(int val ): _val(val) {}
    int comp+val()const {return _val;}	// 基值的读取
    void comp_val(int nval) {_val = nval;}	// 基值的写入
    bool operator()(int _value) const;
private:
    int _val;
};

inline bool LessThan::
operator()(int value) const {return value < _val;}
```



### 4.10 重载iostream 运算符

1. ostream

```c++
ostream& operator<<(ostream &os, const Triangular &rhs)
{
    os << "(" << rhs.beg_pos() << ","
       << rhs.length()		   <<")";
    
    rhs.display(rhs.length(), rhs.beg_pos(), os);
    return os;
}

cout << tri << '\n';
```

2. istream

```c++
istream& operator>>(istream &is, const Triangular &rhs)
{
    char ch1, ch2;
    int bp, len;
    
    // 假设输入为(3, 6) 6 10 15 21 28 36
    // 那么ch1 == '(', bp == 3, ch2 == ',', len ==6。
    is >> ch1 >> bp
       >> ch2 >> len;
    
    // 设定rhs的三个data member……
    rhs.beg_pos(bp);
    rhs.length(len);
    rhs.next_reset();
    
    return is;
}

cout << tri << '\n';
```



### 4.11 指向Class Member Function 的指针

与pointer to non-member function相似，但还得指定它所指的是哪一个class

```c++
void (num_sequence::*pm)(int) = 0;
//将pm声明为一个指针，指向num_sequence的member function。

//可以通过typedef简化
typedef void(num_sequence::*PtrType)(int);
PtrType pm = 0;

class num_sequence {
public:
    typedef void(num_sequence::*PtrType)(int);
    
    // _pmf可指向下列任何一个函数
    void fibonacci(int);
    void pell(int);
    void lucas(int);
    void triangular(int);
    void sequare(int);
    void pentagonal(int);
private:
    PtrType _pmf;
    vector<int>* _elem;		// 指向目前所用的vector
    static const int num_seq = 7;
    static PtrType func_tbl[num_seq];	// 六个member function的地址
    static vector< vector<int> > seq;	
};
```

```c++
const int num_sequence::num_seq;
vector<vector<int> > num_sequence::seq(num_seq);

num_sequence::PtrType
    num_sequence::func_tbl[num_seq] = 
	{	0,
     	&num_sequence::fibonacci,
     	&num_sequence::pell,
     	&num_sequence::lucas,
     	&num_sequence::triangular,
     	&num_sequence::sequare,
     	&num_sequence::pentagonal
	};
```

