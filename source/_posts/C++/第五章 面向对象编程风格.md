---
title: 第五章 面向对象编程风格
date: 2020-01-03 21:16:25
tags: Essential C++
categories: C++
---

## 第五章 面向对象编程风格

### 5.1 面向对象编程

继承(inheritance)和多态(polymorphism)

<!-- more -->

#### 5.1.1 继承

1. 将一群相关的类组织起来，并得以分享其间的共同数据和操作行为
2. 继承机制定义了父子(parent/child)关系。父类定义了所有子类共通的共有接口(public interface)和私有实现(private implementation)。每个子类都可以增加或覆盖(override)继承而来的东西，以实现其自身独特的行为。
3. 父类被称为基类(base class)，子类被称为派生类（derived class)。父类和子类之间的关系称为继承体系(inheritance hierarchy)。
4. 抽象基类(abstract base class)

![image-20191228203438372.png](https://i.loli.net/2019/12/28/R7Eocdzm8PVCbIY.png)

#### 5.1.2 多态

在这些类上进行编程时，可以如同操控单一个体，而非相互独立的类、并赋予我们更多弹性来加入或移除任何特定类。

#### 5.1.3 动态绑定(dynamic binding)

实际执行起来的操作要等到运行时，根据pointer或reference所指的实际对象的类型才能决定。



### 5.2 面向对象编程思维

#### 5.2.1 virtual

默认情形下，member function的解析(resolution)皆在编译时静态地进行。若要令其在运动时动态进行，我们就得在他的声明前加上关键字virtual。

```c++
class LibMat {
public:
    LibMat() {cout << "LibMat::LibMat() default constructor!\n";}
    virtual ~LibMat() {cout << "LibMat::~LibMat() destructor!\n";}
    virtual void print() const
    {cout << "LibMat::print() -- I am a LibMat object!\n";}
}
```

现在定义一个non-member function print()

```c++
void print(const LibMat &mat)
{
    cout << "in global print(): about to print mat.print()\n";
    
    // 下一行会根据mat实际指向的对象。
    // 解析该执行哪一个print()member function。
	mat.print();
}
```



#### 5.2.2 派生类

名称之后必须接一个冒号(:)，然后紧跟着关键字public和基类的名称

```c++
class Book : public LibMat {
public:
    Book(const string &title, const string &author)
        : _title(title), _author(author) {
            cout << "BookLLBook( " << _title
                 << ", " << )author << ") consturctor\n";
        }
    
    virtual ~Book() {
        cout << "Book::~Book() destructor!\n"
    }
    
    virtual voud print() const {
        cout << "Book::print() -- I am a Book object!\n"
             << "My title is: " << _title << '\n'
             << "My author is: " << _author << endl;
    }
    
    const string& title() const {return _title;}
    const string& author() const {return _author;}
    
protected:
    string _title;
    string _author;
};
```

1. Book中的print()覆盖(override)了LibMat的print()。

2. 声明为protected的所有成员都可以被派生类直接访问，除此之外，都不得直接访问protected成员。

3. 使用派生类时不必刻意区分"继承而来的成员"和"自身定义的成员"。两者的使用完全透明

### 5.3 不带继承的多态

### 5.4 抽象基类

1. 定义抽象类的第一个步骤是找出所有子类共通的操作行为。

```c++
class num_sequence {
public:
    // elem(pos): 返回pos位置上的元素
    // gen_elems(pos): 产生直到pos位置的所有元素
    // what_am_i(): 返回确切的数列类型
	// print(os): 将所有元素写入os
    // check_integrity(pos): 检查pos是否为有效位置
    // max_elems(): 返回所支持的最大位置值
	int elem(int pos);
    void gen_elems(int pos);
    const char* what_am_i() const;
    ostream& print(ostream &os = cout) const;
    bool check_integrity(int pos);
    static int max_elems();
}
```

2. 设计抽象基类的下一步，是设法找出哪些操作行为与类型相关(type-dependent)——也就是说，有哪些操作行为必须根据不同的派生类而有不同的实现方式。这些操作行为应该成为整个类继承体系中的virtual function。

   - 如gen_elems()
   - static member function无法被声明为虚函数。

3. 设计抽象基类的第三步，是试着找出每个操作行为的访问层级(access level)。 

   - 即使是该基类的派生类，亦无法访问基类中的private member。

   - protected访问层级可以让派生类访问

   

```c++
class num_sequence {
public:
    virtual ~num_sequence() {};
    
    virtual int elem(int pos) const = 0;
    virtual const char* what_am_i() const = 0;
    static int max_elems() {return _max_elems;}
    virtual ostream& print(ostream &os = cout) const = 0;
    
protected:
    virtual void gen_elems(int pos) const = 0;
    bool check integrity(int pos) const;
    
    const static int _max_elems = 1024;
};
```

​		如果对于该类而言，这个虚函数并无实质意义的话，可设为纯虚函数，即赋值为0。

​		任何类如果声明有纯虚函数，那么由于其接口的不完整性，程序无法为它产生任何对象。这种类只能作为派生类的子对象使用，而且前提是这些派生类必须为所有虚函数提供确切的定义。

​		凡基类定义有虚函数，应该要将其destructor声明为virtual。

```c++
num_sequence *ps = new Fibonacci(12);
// ...使用数列
delete ps;
```

​		ps是基类num_sequence的指针，但它实际上指向派生类Fibonacci的对象。当delete表达式被应用于该指针，destructor会先应用与指针所指的对象身上，所以通过ps调用的destructor一定是Fibonacci的destructor，不是num_sequence的destructor。



### 5.5 定义一个派生类

1. 派生类由两部分组成：以是基类构成的子对象，二是派生类的部分。

```c++
// 头文件"num_sequence.h"含有基类的定义
#include "num_sequence.h"

class Fibonacci : public num_sequence {
public:
    // ...
};
```

2. 派生类必须为从基类继承而来的每个纯虚函数提供对应的实现。

```c++
class Fibonacci : public num_sequence {
public:
    Fibonacci(int len = 1, int leg_pos = 1)
        : _length(len), _beg_pos(beg_pos){}
    
    virtual int elem(int pos) const;
    virtual const char* what_am_i() const {return "Fibonacci";}
    virtual ostream& print(ostream &os = cout) const;
    int length() const {return _length;}
    int beg_pos() const {return _beg_pos;}
    
protected:
    virtual void gen_elems(int pos) const;
    int _length;
    int _beg_pos;
    static vector<int> _elems;
};
```

在类之外对虚函数进行定义时，不必指明关键字virtual

```c++
int Fibonacci::elem(int pos) const
{
    if(!check_integrity(pos))
        return 0;
    if(pos > _elems.size())
        // 需求明确，不必等到运行时才解析
        Fibonacci::gen_elems(pos);
    return _elems[pos - 1];
}
```



### 5.6 运用继承体系

```c++
inline void display(ostream &os, const num_sequence &ns, int pos)
{
    os << "The element at position "
        << pos	<< " for the "
        << ns.what_am_i() << " sequence is "
        << ns.elem(pos) << endl;
}
```



### 5.7 基类该多抽象

可以将所有派生类共有的实现内容剥离出来，移至基类内。



### 5.8 初始化、析构、复制

#### 5.8.1 初始化

```c++
inline Fibonacci:;
Fibonacci(int len, int beg_pos)
    : num_sequence(len, beg_pos, elems)
    {}

num_sequence::
num_sequence(int len=1, int bp=1, vector<int> *pe=0)
    : _length(len), _beg_pos(bp), _pelems(pe){}
```

如果派生类的constructor未能明确指出调用基类的哪一个constructor，编译器便会自动调用基类的default constructor.



#### 5.8.2 copy

```c++
1. Fibonacci fib(12);
    Fibonacci::Fibonacci(const Fibonacci &rhs)
        :num_sequence(rhs)
    {}

2.Fibonacci fib2 = fib1;
    Finobacci& Fibonacci::
    operator=(const Fibonacci &rhs)
    {
        if (this != &rhs)
            num_sequence::operator = (rhs);

        return *this;
    }
```



#### 5.8.3 destructor

#### 基类的destructor会在派生类的destructor结束之后被自动调用。



### 5.9 在派生类中定义虚函数

1. 如果覆盖基类所提供的虚函数，那么派生类提供的新定义，其函数原型必须完全符合基类所声明的函数原型，包括：参数列表、返回类型、常量性。

2. exception

   ​	当基类的虚函数返回某个基类形式（通常是pointer或reference)时，派生类的同名函数便可以返回该基类所派生出来的类型。

```c++
class num_sequence {
public:
    // 派生类的clone()函数可返回一个指针，
    // 指向num_sequence 的任何一个派生类
    virtual num_sequence *clone() = 0;
    
    class Fibonacci : public num_sequence {
    public:
        // 在派生类中，关键字virtual并非必要
        Fibonacci *clone() {return new Fibonacci(*this);}
    };
};
```

   

#### 5.9.2 虚函数的静态解析

1. 基类的constructor和destructor

   当我们构造派生类对象时，基类的constructor会被先调用。此刻派生类中的data member 尚未初始化。如果调用派生类的那一份虚函数，它便有可能访问未经初始化的data member。

2. 基类对象的pointer和reference

   当我们为基类声明一个实际对象，同时也就分配出了足以容纳该实际对象的内存空间。如果稍后传入的却是个派生类对象，那就没有足够的内存放置派生类中的各个 data member。



### 5.10 类型鉴定机制

#### 5.10.1 RTTI运算符

运行时类型鉴定机制(Run-Time Type Identification)

1. typeid运算符

   它让我们得以查询多态化的 class pointer 或 class reference，获得其所指对象的实际类型。 

```c++
#include <typeinfo>

inline const char* num_sequence::
what_am_i() const 
	{ return typeid(*this).name();}

//等价判断
num_sequence *ps = &fib;
// ...
if (typeid(*ps) == typeid(Fibonacci))
```

使用typeid运算符之前，必须先包含头文件typeinfo。typeid运算符会返回一个type_info对象，储存着与类型相关的种种信息。



2. static_cast

```c++
num_sequence *ps = &fib;

// 错误，虽然ps指向Fibonacci对象，
// 但ps并非一个Fibonacci指针
ps->gen_elems(64);

// 应为
ps->Fibonacci::gen_elems(64);
```

static_cast可以进行指针类型转换

```c++
if(typeid(*ps) == typeid(Fibonacci))
{	
    // 无条件转化
    Fibonacci *pf = static_cast<Fibonacci*>(ps); 
    ps->gen_elems(64);
}
```

3. dynamic_cast

```c++
// 有条件转化
if(Fibonacci *pf = dynamic_cast<Fibonacci*>(ps))
    pf->gen_elems(64);
```

会进行运行时检验，检验ps所指对象是否属于Fibonacci类，如果不是则返回0。

