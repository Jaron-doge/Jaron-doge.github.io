---
title: 第三章 泛型编程风格
date: 2019-12-16 10:45:05
tags: Essential C++
categories: C++
---

## 第三章 泛型编程风格

### 3.4顺序性容器

<!-- more -->

#### 3.4.1 五种定义方式

```C++
//1. 产生空的容器：
list<string> slist;
vector<int> ivec;

//2. 产生特定大小的容器。每个元素都以其默认值作为初值。
list<int> ilist(1024);
vector<string> svec(32);

//3. 产生特定大小的容器，并为每个元素指定初值
vector<int> ivec(10, -1);
list<string> slist(16, "unassigned");

//4. 通过一堆iterator产生容器。这对iterator用来标示一整组作为初值的元素的范围：
int ia[8] = { 1, 1, 2, 3, 5, 8, 13, 21 };
vector<int> fib(ia, ia + 8);

//5. 根据某个容器产生出新容器。复制原容器内的元素，作为新容器的初值:
list<string> slist;	// 空容器
// 填充slist
list<string> slist2(slist);	// 将slist复制给slist2
```

#### 3.4.2 push和pop

- push_back()和pop_back()
- push_front()和pop_front()

#### 3.4.3 插入和删除

- insert

```C++
- iterator insert(iterator position, elemType value);

- void insert(iterator position, int count, elemType 
value);

- void insert(iterator1 position, iterator2 first, iterator2 last);

- iterator insert(iterator position);
```

- erase

```C++
- iterator erase(iterator posit);	// posit所指的元素

- iterator erase(iterator first, iterator last);	//[first, last)范围内的元素
```



### 3.5 泛型算法

#### 3.5.1 搜索算法

1. find()用于搜索无序集合中是否存在某值。范围由iterator[first,last)标出。返回iterator指向该值/last。
2. binary_search()用于有序集合的搜索。返回true/false。
3. count()返回数值相符的元素数目。
4. search()比对某个容器内是否存在某个子序列。返回iterator指向子序列起始处/last。

#### 3.5.2 max、sort、copy

```c++
max_element(vec.begin(), vec.end());

sort(temp.begin(), temp.end());

copy(vec.begin(), vec.end(), temp.begin());
```



### 3.6 设计泛型算法

#### 3.6.2 Function Object

#### 3.6.2.1  functional

```C++
- #include  <functional>

- 六个算数运算：plus <type>, minus <type>, negate <type>, 
		multiplies <type>, divides <type>, modules <type>
                  
- 六个关系运算：less <type>，less_equal <type>，greater <type>，
              greater_equal <type>，euqal_to <type>，not_equal_to <type>

- 三个逻辑运算：logical_and <type>，logical_or <type>，logical_not <type>
```



#### 3.6.2.2  示例

```C++
- sort(vec.begin(), bec.end(), greater <int>());

- binary_search(vec,begin(), vc.end(), elem, greater <int>());

- transform(fib.begin(), fib.end(),		// (1) 欲转换的元素范围
			pell.begin(),		// (2) 所指元素将应用于转换操作
			fib_plus_pell.begin(), 	// (3) 所指位指（及后续空间）用来存放转换结果
			plus <int>());		// (4) 想要应用的转换操作
```



#### 3.6.3 Function Object Adapter

​		function object adapter 会对 function object 进行修改操作。所谓binder adapter（绑定适配器）会将 function object 的参数绑定至某特定值，使binary（二元）function object 转化为unary（一元）function object。

```C++
bind2nd(less<int>,  val);

// 会把val绑定与less<int>的第二个参数身上。

// 于是，less<int>会将每个元素拿来和val比较。
```





### 3.7 Map

#### 3.7.1 定义

map被定义为一对(pair)数值，带有key和value

```C++
//创建
#include <map>
#include <string>
map<string,int> words;

//赋值
words["vermeer"] = 1;

string tword;
while (cin >> tword) {
    words[tword]++;
}
//words[tword]会取出tword相应的value， 如果tword不在map内，它便会因此被放到map内，并获得默认值0。
```



#### 3.7.2 查询

```C++
1.
    if(!count = words["vermeer"]);
	//这种方法会将vermeer加入words中
2.find()函数
    words.find("vermeer");
	//返回一个iterator，指向key/value形成的pair，反之返回end()
3.count()函数
    words.count("vermeer");
    //返回某特定项在map内的个数
```



### 3.8 Set

#### 3.8.1 定义

1. set由一群key组合而成，如果想知道某值是否存在于某个集合内，就可以使用set.

```C++
//创建
#include <set>
#include <string>
set<string> word_exclusion;

//先排查set，再加入map
while( cin >> tword) {
    if (word_exclusion.count(tword))
        //如果在“排除字集”内
        continue;
    
    words[tword]++;
}
```



#### 3.8.2 操作

1. set只能储存一份key值

```C++
1.创建
    int ia[10] = {1, 3, 5, 8, 5, 3, 1, 5, 8, 1};
    vector<int> vec(ia,ia+10);
    set<int> iset(vec.begin(), vec.end());
    //iset的元素将是{1, 3, 5, 8}
2.insert
    iset.insert(ival);
	iset.insert(vec.begin(), vec.end());
3.迭代
    set<int>::iterator it = iset.begin();
	for (; it != set.end(); ++it) {
        cout << *it << '';
    }
4.其他算法
    set_intersection(), set_union(), set_difference()和set_symmetric_difference()
```



### 3.9 Iterator Inserter

#### 3.9.1 insertion adapter

``` C++
#include <iterator>
1.back_inserter
    //会以容器的push_back()取代assignment运算符
    vector<int> result_vec;
	unique_copy(ivec.begin(), ivec.end(),
                back_inserter(result_vec));
2.inserter
    //会以容器的insert()函数取代assignment运算符
    //两个参数：容器、iterator
    vector<string> svec_res;
unique_copy(svec.begin(), svec.end(),
           inserter(svec_res, svec_res.edn()));
3.front_inserter
    //会以容器的push_front()函数取代assignment运算符
    //只适用于list和deque
    list<int> ilist_clone;
	copy(ilist.begin(), ilist.end(),
        front_inserter(ilist_clone));
```



### 3.10 iostream Iterator

#### 3.1.1 定义

```C++
#include <iterator>

1.istream_iterator
    istream_iterator<string> is(cin);
    //将is定义为一个“绑至标准输入设备”的istream_iterator
    istream_iterator<string> eof;
    //eof代表EOF

2.ostream_iterator
    ostream_iterator<string> os(cout, " ");
    //将os定义为一个“绑至标准输出设备”的ostream_iterator
    //第二个参数表示各个元素被输出时的分隔符

```



#### 3.1.2 用法

1. 标准输入输出

```C++
#include <iostream>
#include <iterator>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int main()
{
    istream_iterator<string> is(cin);
    istream_iterator<string> eof;
    
    vector<string> text;
    copy(is, eof, back_inserter(text));
    
    sort(text.begin(), text.end());
    
    ostream_iterator<string> os(cout, " ");
    copy(text.begin(), text.end(), os);
}
```



2. 文件输入输出

```C++
#include <iostream>
#include <fstream>
#include <iterator>
#include <algorithm>
#include <vector>
#include <string>
using namespace std;

int main()
{
    ifstream in_file("input_file.txt");
    ofstream out_file("output_file.txt");
    
    if (!in_file || !out_file) {
		cerr << "!! unable to open the necessary files.\n";
        return -1;
    }
    
    istream_iterator<string> is(in_file);
    istream_iterator<string> eof;
    
    vector<string> text;
    copy(is, eof, back_inserter(text));
    
    sort(text.begin(), text.end());
    
    ostream_iterator<string> os(out_file, " ");
    copy(text.begin(), text.end(), os);
}
```

